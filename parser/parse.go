// @generated by pegen from python.gram
package parser

import (
	"github.com/AvoidMe/gpython/builtin"
)

var reserved_keywords = [][]KeywordToken{
	{},
	{},
	{},
	{},
	{
		{"pass", 500},
	},
}
var soft_keywords = []string{}
var (
	file_type          = 1000
	statements_type    = 1001
	statement_type     = 1002
	simple_stmts_type  = 1003
	simple_stmt_type   = 1004
	assignment_type    = 1005
	single_target_type = 1006
	_loop1_1_type      = 1007
	_loop0_3_type      = 1008
	_gather_2_type     = 1009
)

// file: statements? $
func file_rule(p *Parser) mod_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res mod_ty
	_mark := p.mark
	{ // statements? $
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a any
		var endmarker_var *Token
		condition := func() bool {
			a = statements_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// statements?
			endmarker_var = _PyPegen_expect_token(p, ENDMARKER)
			if endmarker_var == nil {
				return false
			} // token='ENDMARKER'
			return true
		}
		if condition() {
			_res = _PyPegen_make_module(p, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// statements: statement+
func statements_rule(p *Parser) *asdl_stmt_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_stmt_seq
	_mark := p.mark
	{ // statement+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_seq
		condition := func() bool {
			a = _loop1_1_rule(p)
			if a == nil {
				return false
			} // statement+
			return true
		}
		if condition() {
			_res = _PyPegen_seq_flatten(p, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// statement: simple_stmts
func statement_rule(p *Parser) *asdl_stmt_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_stmt_seq
	_mark := p.mark
	{ // simple_stmts
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_stmt_seq
		condition := func() bool {
			a = *asdl_stmt_seqsimple_stmts_rule(p)
			if a == nil {
				return false
			} // simple_stmts
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// simple_stmts: ';'.simple_stmt+ ';'? NEWLINE
func simple_stmts_rule(p *Parser) *asdl_stmt_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_stmt_seq
	_mark := p.mark
	{ // ';'.simple_stmt+ ';'? NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a *asdl_stmt_seq
		var newline_var *Token
		condition := func() bool {
			a = *asdl_stmt_seq_gather_2_rule(p)
			if a == nil {
				return false
			} // ';'.simple_stmt+
			_opt_var = _PyPegen_expect_token(p, 13)
			if p.error_indicator != 0 {
				return false
			}
			// ';'?
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// simple_stmt: assignment | 'pass'
func simple_stmt_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	if _PyPegen_is_memoized(p, simple_stmt_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // assignment
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var assignment_var stmt_ty
		condition := func() bool {
			assignment_var = assignment_rule(p)
			if assignment_var == nil {
				return false
			} // assignment
			return true
		}
		if condition() {
			_res = assignment_var
			goto done
		}
		p.mark = _mark
	}
	{ // 'pass'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 500)
			if _keyword == nil {
				return false
			} // token='pass'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Pass(EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	_PyPegen_insert_memo(p, _mark, simple_stmt_type, _res)
	p.level--
	return _res
}

// assignment: '(' single_target ')'
func assignment_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	{ // '(' single_target ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *Token
		var b expr_ty
		condition := func() bool {
			a = _PyPegen_expect_token(p, 7)
			if a == nil {
				return false
			} // token='('
			b = single_target_rule(p)
			if b == nil {
				return false
			} // single_target
			_literal = _PyPegen_expect_token(p, 8)
			if _literal == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = b
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// single_target: NAME | '(' single_target ')'
func single_target_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	{ // NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		condition := func() bool {
			a = _PyPegen_name_token(p)
			if a == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_res = _PyPegen_set_expr_context(p, a, Store)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '(' single_target ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			a = single_target_rule(p)
			if a == nil {
				return false
			} // single_target
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop1_1: statement
func _loop1_1_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // statement
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var statement_var *asdl_stmt_seq
		condition := func() bool {
			statement_var = statement_rule(p)
			if statement_var == nil {
				return false
			} // statement
			return true
		}
		for condition() {
			_res = statement_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_1_type, _seq)
	p.level--
	return _seq
}

// _loop0_3: ';' simple_stmt
func _loop0_3_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ';' simple_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem stmt_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 13)
			if _literal == nil {
				return false
			} // token=';'
			elem = simple_stmt_rule(p)
			if elem == nil {
				return false
			} // simple_stmt
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_3_type, _seq)
	p.level--
	return _seq
}

// _gather_2: simple_stmt _loop0_3
func _gather_2_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // simple_stmt _loop0_3
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem stmt_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = simple_stmt_rule(p)
			if elem == nil {
				return false
			} // simple_stmt
			seq = _loop0_3_rule(p)
			if seq == nil {
				return false
			} // _loop0_3
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

func _PyPegen_parse(p *Parser) *AST {
	// Initialize keywords
	p.Keywords = reserved_keywords
	p.SoftKeywords = soft_keywords

	// Run parser
	var result *AST
	switch p.StartRule {
	case Py_file_input:
		return file_rule(p)
	}

	return result
}
