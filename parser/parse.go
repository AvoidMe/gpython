// @generated by pegen from python.gram
package parser

import (
	"github.com/AvoidMe/gpython/builtin"
)

var reserved_keywords = [][]KeywordToken{
	{},
	{},
	{
		{"if", 639},
		{"as", 637},
		{"in", 648},
		{"or", 574},
		{"is", 582},
	},
	{
		{"del", 603},
		{"def", 649},
		{"for", 647},
		{"try", 621},
		{"and", 575},
		{"not", 581},
	},
	{
		{"from", 572},
		{"pass", 504},
		{"with", 612},
		{"elif", 641},
		{"else", 642},
		{"None", 601},
		{"True", 600},
	},
	{
		{"raise", 522},
		{"yield", 573},
		{"break", 508},
		{"class", 651},
		{"while", 644},
		{"False", 602},
	},
	{
		{"return", 519},
		{"import", 531},
		{"assert", 526},
		{"global", 523},
		{"except", 634},
		{"lambda", 586},
	},
	{
		{"finally", 630},
	},
	{
		{"continue", 509},
		{"nonlocal", 524},
	},
}
var soft_keywords = []string{
	"_",
	"case",
	"match",
}
var (
	file_type                              = 1000
	interactive_type                       = 1001
	eval_type                              = 1002
	func_type_type                         = 1003
	fstring_type                           = 1004
	statements_type                        = 1005
	statement_type                         = 1006
	statement_newline_type                 = 1007
	simple_stmts_type                      = 1008
	simple_stmt_type                       = 1009
	compound_stmt_type                     = 1010
	assignment_type                        = 1011
	annotated_rhs_type                     = 1012
	augassign_type                         = 1013
	return_stmt_type                       = 1014
	raise_stmt_type                        = 1015
	global_stmt_type                       = 1016
	nonlocal_stmt_type                     = 1017
	del_stmt_type                          = 1018
	yield_stmt_type                        = 1019
	assert_stmt_type                       = 1020
	import_stmt_type                       = 1021
	import_name_type                       = 1022
	import_from_type                       = 1023
	import_from_targets_type               = 1024
	import_from_as_names_type              = 1025
	import_from_as_name_type               = 1026
	dotted_as_names_type                   = 1027
	dotted_as_name_type                    = 1028
	dotted_name_type                       = 1029 // Left-recursive
	block_type                             = 1030
	decorators_type                        = 1031
	class_def_type                         = 1032
	class_def_raw_type                     = 1033
	function_def_type                      = 1034
	function_def_raw_type                  = 1035
	params_type                            = 1036
	parameters_type                        = 1037
	slash_no_default_type                  = 1038
	slash_with_default_type                = 1039
	star_etc_type                          = 1040
	kwds_type                              = 1041
	param_no_default_type                  = 1042
	param_no_default_star_annotation_type  = 1043
	param_with_default_type                = 1044
	param_maybe_default_type               = 1045
	param_type                             = 1046
	param_star_annotation_type             = 1047
	annotation_type                        = 1048
	star_annotation_type                   = 1049
	default_type                           = 1050
	if_stmt_type                           = 1051
	elif_stmt_type                         = 1052
	else_block_type                        = 1053
	while_stmt_type                        = 1054
	for_stmt_type                          = 1055
	with_stmt_type                         = 1056
	with_item_type                         = 1057
	try_stmt_type                          = 1058
	except_block_type                      = 1059
	except_star_block_type                 = 1060
	finally_block_type                     = 1061
	match_stmt_type                        = 1062
	subject_expr_type                      = 1063
	case_block_type                        = 1064
	guard_type                             = 1065
	patterns_type                          = 1066
	pattern_type                           = 1067
	as_pattern_type                        = 1068
	or_pattern_type                        = 1069
	closed_pattern_type                    = 1070
	literal_pattern_type                   = 1071
	literal_expr_type                      = 1072
	complex_number_type                    = 1073
	signed_number_type                     = 1074
	signed_real_number_type                = 1075
	real_number_type                       = 1076
	imaginary_number_type                  = 1077
	capture_pattern_type                   = 1078
	pattern_capture_target_type            = 1079
	wildcard_pattern_type                  = 1080
	value_pattern_type                     = 1081
	attr_type                              = 1082 // Left-recursive
	name_or_attr_type                      = 1083 // Left-recursive
	group_pattern_type                     = 1084
	sequence_pattern_type                  = 1085
	open_sequence_pattern_type             = 1086
	maybe_sequence_pattern_type            = 1087
	maybe_star_pattern_type                = 1088
	star_pattern_type                      = 1089
	mapping_pattern_type                   = 1090
	items_pattern_type                     = 1091
	key_value_pattern_type                 = 1092
	double_star_pattern_type               = 1093
	class_pattern_type                     = 1094
	positional_patterns_type               = 1095
	keyword_patterns_type                  = 1096
	keyword_pattern_type                   = 1097
	expressions_type                       = 1098
	expression_type                        = 1099
	yield_expr_type                        = 1100
	star_expressions_type                  = 1101
	star_expression_type                   = 1102
	star_named_expressions_type            = 1103
	star_named_expression_type             = 1104
	assignment_expression_type             = 1105
	named_expression_type                  = 1106
	disjunction_type                       = 1107
	conjunction_type                       = 1108
	inversion_type                         = 1109
	comparison_type                        = 1110
	compare_op_bitwise_or_pair_type        = 1111
	eq_bitwise_or_type                     = 1112
	noteq_bitwise_or_type                  = 1113
	lte_bitwise_or_type                    = 1114
	lt_bitwise_or_type                     = 1115
	gte_bitwise_or_type                    = 1116
	gt_bitwise_or_type                     = 1117
	notin_bitwise_or_type                  = 1118
	in_bitwise_or_type                     = 1119
	isnot_bitwise_or_type                  = 1120
	is_bitwise_or_type                     = 1121
	bitwise_or_type                        = 1122 // Left-recursive
	bitwise_xor_type                       = 1123 // Left-recursive
	bitwise_and_type                       = 1124 // Left-recursive
	shift_expr_type                        = 1125 // Left-recursive
	sum_type                               = 1126 // Left-recursive
	term_type                              = 1127 // Left-recursive
	factor_type                            = 1128
	power_type                             = 1129
	await_primary_type                     = 1130
	primary_type                           = 1131 // Left-recursive
	slices_type                            = 1132
	slice_type                             = 1133
	atom_type                              = 1134
	group_type                             = 1135
	lambdef_type                           = 1136
	lambda_params_type                     = 1137
	lambda_parameters_type                 = 1138
	lambda_slash_no_default_type           = 1139
	lambda_slash_with_default_type         = 1140
	lambda_star_etc_type                   = 1141
	lambda_kwds_type                       = 1142
	lambda_param_no_default_type           = 1143
	lambda_param_with_default_type         = 1144
	lambda_param_maybe_default_type        = 1145
	lambda_param_type                      = 1146
	strings_type                           = 1147
	list_type                              = 1148
	tuple_type                             = 1149
	set_type                               = 1150
	dict_type                              = 1151
	double_starred_kvpairs_type            = 1152
	double_starred_kvpair_type             = 1153
	kvpair_type                            = 1154
	for_if_clauses_type                    = 1155
	for_if_clause_type                     = 1156
	listcomp_type                          = 1157
	setcomp_type                           = 1158
	genexp_type                            = 1159
	dictcomp_type                          = 1160
	arguments_type                         = 1161
	args_type                              = 1162
	kwargs_type                            = 1163
	starred_expression_type                = 1164
	kwarg_or_starred_type                  = 1165
	kwarg_or_double_starred_type           = 1166
	star_targets_type                      = 1167
	star_targets_list_seq_type             = 1168
	star_targets_tuple_seq_type            = 1169
	star_target_type                       = 1170
	target_with_star_atom_type             = 1171
	star_atom_type                         = 1172
	single_target_type                     = 1173
	single_subscript_attribute_target_type = 1174
	t_primary_type                         = 1175 // Left-recursive
	t_lookahead_type                       = 1176
	del_targets_type                       = 1177
	del_target_type                        = 1178
	del_t_atom_type                        = 1179
	type_expressions_type                  = 1180
	func_type_comment_type                 = 1181
	invalid_arguments_type                 = 1182
	invalid_kwarg_type                     = 1183
	expression_without_invalid_type        = 1184
	invalid_legacy_expression_type         = 1185
	invalid_expression_type                = 1186
	invalid_named_expression_type          = 1187
	invalid_assignment_type                = 1188
	invalid_ann_assign_target_type         = 1189
	invalid_del_stmt_type                  = 1190
	invalid_block_type                     = 1191
	invalid_comprehension_type             = 1192
	invalid_dict_comprehension_type        = 1193
	invalid_parameters_type                = 1194
	invalid_default_type                   = 1195
	invalid_star_etc_type                  = 1196
	invalid_kwds_type                      = 1197
	invalid_parameters_helper_type         = 1198
	invalid_lambda_parameters_type         = 1199
	invalid_lambda_parameters_helper_type  = 1200
	invalid_lambda_star_etc_type           = 1201
	invalid_lambda_kwds_type               = 1202
	invalid_double_type_comments_type      = 1203
	invalid_with_item_type                 = 1204
	invalid_for_target_type                = 1205
	invalid_group_type                     = 1206
	invalid_import_from_targets_type       = 1207
	invalid_with_stmt_type                 = 1208
	invalid_with_stmt_indent_type          = 1209
	invalid_try_stmt_type                  = 1210
	invalid_except_stmt_type               = 1211
	invalid_finally_stmt_type              = 1212
	invalid_except_stmt_indent_type        = 1213
	invalid_except_star_stmt_indent_type   = 1214
	invalid_match_stmt_type                = 1215
	invalid_case_block_type                = 1216
	invalid_as_pattern_type                = 1217
	invalid_class_pattern_type             = 1218
	invalid_class_argument_pattern_type    = 1219
	invalid_if_stmt_type                   = 1220
	invalid_elif_stmt_type                 = 1221
	invalid_else_stmt_type                 = 1222
	invalid_while_stmt_type                = 1223
	invalid_for_stmt_type                  = 1224
	invalid_def_raw_type                   = 1225
	invalid_class_def_raw_type             = 1226
	invalid_double_starred_kvpairs_type    = 1227
	invalid_kvpair_type                    = 1228
	_loop0_1_type                          = 1229
	_loop0_2_type                          = 1230
	_loop1_3_type                          = 1231
	_loop0_5_type                          = 1232
	_gather_4_type                         = 1233
	_tmp_6_type                            = 1234
	_tmp_7_type                            = 1235
	_tmp_8_type                            = 1236
	_tmp_9_type                            = 1237
	_tmp_10_type                           = 1238
	_tmp_11_type                           = 1239
	_tmp_12_type                           = 1240
	_tmp_13_type                           = 1241
	_loop1_14_type                         = 1242
	_tmp_15_type                           = 1243
	_tmp_16_type                           = 1244
	_tmp_17_type                           = 1245
	_loop0_19_type                         = 1246
	_gather_18_type                        = 1247
	_loop0_21_type                         = 1248
	_gather_20_type                        = 1249
	_tmp_22_type                           = 1250
	_tmp_23_type                           = 1251
	_loop0_24_type                         = 1252
	_loop1_25_type                         = 1253
	_loop0_27_type                         = 1254
	_gather_26_type                        = 1255
	_tmp_28_type                           = 1256
	_loop0_30_type                         = 1257
	_gather_29_type                        = 1258
	_tmp_31_type                           = 1259
	_loop1_32_type                         = 1260
	_tmp_33_type                           = 1261
	_tmp_34_type                           = 1262
	_tmp_35_type                           = 1263
	_loop0_36_type                         = 1264
	_loop0_37_type                         = 1265
	_loop0_38_type                         = 1266
	_loop1_39_type                         = 1267
	_loop0_40_type                         = 1268
	_loop1_41_type                         = 1269
	_loop1_42_type                         = 1270
	_loop1_43_type                         = 1271
	_loop0_44_type                         = 1272
	_loop1_45_type                         = 1273
	_loop0_46_type                         = 1274
	_loop1_47_type                         = 1275
	_loop0_48_type                         = 1276
	_loop0_49_type                         = 1277
	_loop1_50_type                         = 1278
	_loop0_52_type                         = 1279
	_gather_51_type                        = 1280
	_loop0_54_type                         = 1281
	_gather_53_type                        = 1282
	_loop0_56_type                         = 1283
	_gather_55_type                        = 1284
	_loop0_58_type                         = 1285
	_gather_57_type                        = 1286
	_tmp_59_type                           = 1287
	_loop1_60_type                         = 1288
	_loop1_61_type                         = 1289
	_tmp_62_type                           = 1290
	_tmp_63_type                           = 1291
	_loop1_64_type                         = 1292
	_loop0_66_type                         = 1293
	_gather_65_type                        = 1294
	_tmp_67_type                           = 1295
	_tmp_68_type                           = 1296
	_tmp_69_type                           = 1297
	_tmp_70_type                           = 1298
	_loop0_72_type                         = 1299
	_gather_71_type                        = 1300
	_loop0_74_type                         = 1301
	_gather_73_type                        = 1302
	_tmp_75_type                           = 1303
	_loop0_77_type                         = 1304
	_gather_76_type                        = 1305
	_loop0_79_type                         = 1306
	_gather_78_type                        = 1307
	_loop1_80_type                         = 1308
	_loop1_81_type                         = 1309
	_loop0_83_type                         = 1310
	_gather_82_type                        = 1311
	_loop1_84_type                         = 1312
	_loop1_85_type                         = 1313
	_loop1_86_type                         = 1314
	_tmp_87_type                           = 1315
	_loop0_89_type                         = 1316
	_gather_88_type                        = 1317
	_tmp_90_type                           = 1318
	_tmp_91_type                           = 1319
	_tmp_92_type                           = 1320
	_tmp_93_type                           = 1321
	_tmp_94_type                           = 1322
	_loop0_95_type                         = 1323
	_loop0_96_type                         = 1324
	_loop0_97_type                         = 1325
	_loop1_98_type                         = 1326
	_loop0_99_type                         = 1327
	_loop1_100_type                        = 1328
	_loop1_101_type                        = 1329
	_loop1_102_type                        = 1330
	_loop0_103_type                        = 1331
	_loop1_104_type                        = 1332
	_loop0_105_type                        = 1333
	_loop1_106_type                        = 1334
	_loop0_107_type                        = 1335
	_loop1_108_type                        = 1336
	_loop1_109_type                        = 1337
	_tmp_110_type                          = 1338
	_loop0_112_type                        = 1339
	_gather_111_type                       = 1340
	_loop1_113_type                        = 1341
	_loop0_114_type                        = 1342
	_loop0_115_type                        = 1343
	_tmp_116_type                          = 1344
	_loop0_118_type                        = 1345
	_gather_117_type                       = 1346
	_tmp_119_type                          = 1347
	_loop0_121_type                        = 1348
	_gather_120_type                       = 1349
	_loop0_123_type                        = 1350
	_gather_122_type                       = 1351
	_loop0_125_type                        = 1352
	_gather_124_type                       = 1353
	_loop0_127_type                        = 1354
	_gather_126_type                       = 1355
	_loop0_128_type                        = 1356
	_loop0_130_type                        = 1357
	_gather_129_type                       = 1358
	_loop1_131_type                        = 1359
	_tmp_132_type                          = 1360
	_loop0_134_type                        = 1361
	_gather_133_type                       = 1362
	_loop0_136_type                        = 1363
	_gather_135_type                       = 1364
	_loop0_138_type                        = 1365
	_gather_137_type                       = 1366
	_loop0_140_type                        = 1367
	_gather_139_type                       = 1368
	_loop0_142_type                        = 1369
	_gather_141_type                       = 1370
	_tmp_143_type                          = 1371
	_tmp_144_type                          = 1372
	_tmp_145_type                          = 1373
	_tmp_146_type                          = 1374
	_tmp_147_type                          = 1375
	_tmp_148_type                          = 1376
	_tmp_149_type                          = 1377
	_tmp_150_type                          = 1378
	_tmp_151_type                          = 1379
	_loop0_152_type                        = 1380
	_loop0_153_type                        = 1381
	_loop0_154_type                        = 1382
	_tmp_155_type                          = 1383
	_tmp_156_type                          = 1384
	_tmp_157_type                          = 1385
	_tmp_158_type                          = 1386
	_loop0_159_type                        = 1387
	_loop0_160_type                        = 1388
	_loop1_161_type                        = 1389
	_tmp_162_type                          = 1390
	_loop0_163_type                        = 1391
	_tmp_164_type                          = 1392
	_loop0_165_type                        = 1393
	_tmp_166_type                          = 1394
	_loop0_167_type                        = 1395
	_loop1_168_type                        = 1396
	_tmp_169_type                          = 1397
	_tmp_170_type                          = 1398
	_tmp_171_type                          = 1399
	_loop0_172_type                        = 1400
	_tmp_173_type                          = 1401
	_tmp_174_type                          = 1402
	_loop1_175_type                        = 1403
	_loop0_176_type                        = 1404
	_loop0_177_type                        = 1405
	_loop0_179_type                        = 1406
	_gather_178_type                       = 1407
	_tmp_180_type                          = 1408
	_loop0_181_type                        = 1409
	_tmp_182_type                          = 1410
	_loop0_183_type                        = 1411
	_tmp_184_type                          = 1412
	_loop0_185_type                        = 1413
	_loop1_186_type                        = 1414
	_loop1_187_type                        = 1415
	_tmp_188_type                          = 1416
	_tmp_189_type                          = 1417
	_loop0_190_type                        = 1418
	_tmp_191_type                          = 1419
	_tmp_192_type                          = 1420
	_tmp_193_type                          = 1421
	_loop0_195_type                        = 1422
	_gather_194_type                       = 1423
	_loop0_197_type                        = 1424
	_gather_196_type                       = 1425
	_loop0_199_type                        = 1426
	_gather_198_type                       = 1427
	_loop0_201_type                        = 1428
	_gather_200_type                       = 1429
	_tmp_202_type                          = 1430
	_loop0_203_type                        = 1431
	_loop1_204_type                        = 1432
	_tmp_205_type                          = 1433
	_loop0_206_type                        = 1434
	_loop1_207_type                        = 1435
	_tmp_208_type                          = 1436
	_tmp_209_type                          = 1437
	_tmp_210_type                          = 1438
	_tmp_211_type                          = 1439
	_tmp_212_type                          = 1440
	_tmp_213_type                          = 1441
	_tmp_214_type                          = 1442
	_tmp_215_type                          = 1443
	_tmp_216_type                          = 1444
	_tmp_217_type                          = 1445
	_loop0_219_type                        = 1446
	_gather_218_type                       = 1447
	_tmp_220_type                          = 1448
	_tmp_221_type                          = 1449
	_tmp_222_type                          = 1450
	_tmp_223_type                          = 1451
	_tmp_224_type                          = 1452
	_tmp_225_type                          = 1453
	_tmp_226_type                          = 1454
	_tmp_227_type                          = 1455
	_tmp_228_type                          = 1456
	_tmp_229_type                          = 1457
	_tmp_230_type                          = 1458
	_tmp_231_type                          = 1459
	_tmp_232_type                          = 1460
	_tmp_233_type                          = 1461
	_tmp_234_type                          = 1462
	_tmp_235_type                          = 1463
	_tmp_236_type                          = 1464
	_tmp_237_type                          = 1465
	_tmp_238_type                          = 1466
	_tmp_239_type                          = 1467
	_tmp_240_type                          = 1468
	_tmp_241_type                          = 1469
	_tmp_242_type                          = 1470
	_tmp_243_type                          = 1471
	_tmp_244_type                          = 1472
	_tmp_245_type                          = 1473
	_tmp_246_type                          = 1474
	_tmp_247_type                          = 1475
	_tmp_248_type                          = 1476
	_tmp_249_type                          = 1477
)

// file: statements? $
func file_rule(p *Parser) mod_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res mod_ty
	_mark := p.mark
	{ // statements? $
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a any
		var endmarker_var *Token
		condition := func() bool {
			a = statements_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// statements?
			endmarker_var = _PyPegen_expect_token(p, ENDMARKER)
			if endmarker_var == nil {
				return false
			} // token='ENDMARKER'
			return true
		}
		if condition() {
			_res = _PyPegen_make_module(p, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// interactive: statement_newline
func interactive_rule(p *Parser) mod_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res mod_ty
	_mark := p.mark
	{ // statement_newline
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_stmt_seq
		condition := func() bool {
			a = statement_newline_rule(p)
			if a == nil {
				return false
			} // statement_newline
			return true
		}
		if condition() {
			_res = _PyAST_Interactive(a, p.arena)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// eval: expressions NEWLINE* $
func eval_rule(p *Parser) mod_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res mod_ty
	_mark := p.mark
	{ // expressions NEWLINE* $
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _loop0_1_var *asdl_seq
		var a expr_ty
		var endmarker_var *Token
		condition := func() bool {
			a = expressions_rule(p)
			if a == nil {
				return false
			} // expressions
			_loop0_1_var = _loop0_1_rule(p)
			if _loop0_1_var == nil {
				return false
			} // NEWLINE*
			endmarker_var = _PyPegen_expect_token(p, ENDMARKER)
			if endmarker_var == nil {
				return false
			} // token='ENDMARKER'
			return true
		}
		if condition() {
			_res = _PyAST_Expression(a, p.arena)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// func_type: '(' type_expressions? ')' '->' expression NEWLINE* $
func func_type_rule(p *Parser) mod_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res mod_ty
	_mark := p.mark
	{ // '(' type_expressions? ')' '->' expression NEWLINE* $
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var _literal_2 *Token
		var _loop0_2_var *asdl_seq
		var a any
		var b expr_ty
		var endmarker_var *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			a = type_expressions_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// type_expressions?
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			_literal_2 = _PyPegen_expect_token(p, 51)
			if _literal_2 == nil {
				return false
			} // token='->'
			b = expression_rule(p)
			if b == nil {
				return false
			} // expression
			_loop0_2_var = _loop0_2_rule(p)
			if _loop0_2_var == nil {
				return false
			} // NEWLINE*
			endmarker_var = _PyPegen_expect_token(p, ENDMARKER)
			if endmarker_var == nil {
				return false
			} // token='ENDMARKER'
			return true
		}
		if condition() {
			_res = _PyAST_FunctionType(a, b, p.arena)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// fstring: star_expressions
func fstring_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	{ // star_expressions
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var star_expressions_var expr_ty
		condition := func() bool {
			star_expressions_var = star_expressions_rule(p)
			if star_expressions_var == nil {
				return false
			} // star_expressions
			return true
		}
		if condition() {
			_res = star_expressions_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// statements: statement+
func statements_rule(p *Parser) *asdl_stmt_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_stmt_seq
	_mark := p.mark
	{ // statement+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_seq
		condition := func() bool {
			a = _loop1_3_rule(p)
			if a == nil {
				return false
			} // statement+
			return true
		}
		if condition() {
			_res = _PyPegen_seq_flatten(p, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// statement: compound_stmt | simple_stmts
func statement_rule(p *Parser) *asdl_stmt_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_stmt_seq
	_mark := p.mark
	{ // compound_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a stmt_ty
		condition := func() bool {
			a = compound_stmt_rule(p)
			if a == nil {
				return false
			} // compound_stmt
			return true
		}
		if condition() {
			_res = _PyPegen_singleton_seq(p, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // simple_stmts
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_stmt_seq
		condition := func() bool {
			a = *asdl_stmt_seqsimple_stmts_rule(p)
			if a == nil {
				return false
			} // simple_stmts
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// statement_newline: compound_stmt NEWLINE | simple_stmts | NEWLINE | $
func statement_newline_rule(p *Parser) *asdl_stmt_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_stmt_seq
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // compound_stmt NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a stmt_ty
		var newline_var *Token
		condition := func() bool {
			a = compound_stmt_rule(p)
			if a == nil {
				return false
			} // compound_stmt
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		if condition() {
			_res = _PyPegen_singleton_seq(p, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // simple_stmts
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var simple_stmts_var *asdl_stmt_seq
		condition := func() bool {
			simple_stmts_var = simple_stmts_rule(p)
			if simple_stmts_var == nil {
				return false
			} // simple_stmts
			return true
		}
		if condition() {
			_res = simple_stmts_var
			goto done
		}
		p.mark = _mark
	}
	{ // NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var newline_var *Token
		condition := func() bool {
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyPegen_singleton_seq(p, CHECK(stmt_ty, _PyAST_Pass(EXTRA)))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // $
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var endmarker_var *Token
		condition := func() bool {
			endmarker_var = _PyPegen_expect_token(p, ENDMARKER)
			if endmarker_var == nil {
				return false
			} // token='ENDMARKER'
			return true
		}
		if condition() {
			_res = _PyPegen_interactive_exit(p)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// simple_stmts: simple_stmt !';' NEWLINE | ';'.simple_stmt+ ';'? NEWLINE
func simple_stmts_rule(p *Parser) *asdl_stmt_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_stmt_seq
	_mark := p.mark
	{ // simple_stmt !';' NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a stmt_ty
		var newline_var *Token
		condition := func() bool {
			a = simple_stmt_rule(p)
			if a == nil {
				return false
			} // simple_stmt
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 13)
			if _tmp == 0 {
				return false
			} // token=';'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		if condition() {
			_res = _PyPegen_singleton_seq(p, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // ';'.simple_stmt+ ';'? NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a *asdl_stmt_seq
		var newline_var *Token
		condition := func() bool {
			a = *asdl_stmt_seq_gather_4_rule(p)
			if a == nil {
				return false
			} // ';'.simple_stmt+
			_opt_var = _PyPegen_expect_token(p, 13)
			if p.error_indicator != 0 {
				return false
			}
			// ';'?
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// simple_stmt:
//     | assignment
//     | star_expressions
//     | &'return' return_stmt
//     | &('import' | 'from') import_stmt
//     | &'raise' raise_stmt
//     | 'pass'
//     | &'del' del_stmt
//     | &'yield' yield_stmt
//     | &'assert' assert_stmt
//     | 'break'
//     | 'continue'
//     | &'global' global_stmt
//     | &'nonlocal' nonlocal_stmt
func simple_stmt_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	if _PyPegen_is_memoized(p, simple_stmt_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // assignment
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var assignment_var stmt_ty
		condition := func() bool {
			assignment_var = assignment_rule(p)
			if assignment_var == nil {
				return false
			} // assignment
			return true
		}
		if condition() {
			_res = assignment_var
			goto done
		}
		p.mark = _mark
	}
	{ // star_expressions
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var e expr_ty
		condition := func() bool {
			e = star_expressions_rule(p)
			if e == nil {
				return false
			} // star_expressions
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Expr(e, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // &'return' return_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var return_stmt_var stmt_ty
		condition := func() bool {
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 519)
			if _tmp == 0 {
				return false
			} // token='return'
			return_stmt_var = return_stmt_rule(p)
			if return_stmt_var == nil {
				return false
			} // return_stmt
			return true
		}
		if condition() {
			_res = return_stmt_var
			goto done
		}
		p.mark = _mark
	}
	{ // &('import' | 'from') import_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var import_stmt_var stmt_ty
		condition := func() bool {
			_tmp := _PyPegen_lookahead(1, _tmp_6_rule, p)
			if _tmp == 0 {
				return false
			}
			import_stmt_var = import_stmt_rule(p)
			if import_stmt_var == nil {
				return false
			} // import_stmt
			return true
		}
		if condition() {
			_res = import_stmt_var
			goto done
		}
		p.mark = _mark
	}
	{ // &'raise' raise_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var raise_stmt_var stmt_ty
		condition := func() bool {
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 522)
			if _tmp == 0 {
				return false
			} // token='raise'
			raise_stmt_var = raise_stmt_rule(p)
			if raise_stmt_var == nil {
				return false
			} // raise_stmt
			return true
		}
		if condition() {
			_res = raise_stmt_var
			goto done
		}
		p.mark = _mark
	}
	{ // 'pass'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 504)
			if _keyword == nil {
				return false
			} // token='pass'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Pass(EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // &'del' del_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var del_stmt_var stmt_ty
		condition := func() bool {
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 603)
			if _tmp == 0 {
				return false
			} // token='del'
			del_stmt_var = del_stmt_rule(p)
			if del_stmt_var == nil {
				return false
			} // del_stmt
			return true
		}
		if condition() {
			_res = del_stmt_var
			goto done
		}
		p.mark = _mark
	}
	{ // &'yield' yield_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var yield_stmt_var stmt_ty
		condition := func() bool {
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 573)
			if _tmp == 0 {
				return false
			} // token='yield'
			yield_stmt_var = yield_stmt_rule(p)
			if yield_stmt_var == nil {
				return false
			} // yield_stmt
			return true
		}
		if condition() {
			_res = yield_stmt_var
			goto done
		}
		p.mark = _mark
	}
	{ // &'assert' assert_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var assert_stmt_var stmt_ty
		condition := func() bool {
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 526)
			if _tmp == 0 {
				return false
			} // token='assert'
			assert_stmt_var = assert_stmt_rule(p)
			if assert_stmt_var == nil {
				return false
			} // assert_stmt
			return true
		}
		if condition() {
			_res = assert_stmt_var
			goto done
		}
		p.mark = _mark
	}
	{ // 'break'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 508)
			if _keyword == nil {
				return false
			} // token='break'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Break(EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'continue'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 509)
			if _keyword == nil {
				return false
			} // token='continue'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Continue(EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // &'global' global_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var global_stmt_var stmt_ty
		condition := func() bool {
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 523)
			if _tmp == 0 {
				return false
			} // token='global'
			global_stmt_var = global_stmt_rule(p)
			if global_stmt_var == nil {
				return false
			} // global_stmt
			return true
		}
		if condition() {
			_res = global_stmt_var
			goto done
		}
		p.mark = _mark
	}
	{ // &'nonlocal' nonlocal_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var nonlocal_stmt_var stmt_ty
		condition := func() bool {
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 524)
			if _tmp == 0 {
				return false
			} // token='nonlocal'
			nonlocal_stmt_var = nonlocal_stmt_rule(p)
			if nonlocal_stmt_var == nil {
				return false
			} // nonlocal_stmt
			return true
		}
		if condition() {
			_res = nonlocal_stmt_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	_PyPegen_insert_memo(p, _mark, simple_stmt_type, _res)
	p.level--
	return _res
}

// compound_stmt:
//     | &('def' | '@' | ASYNC) function_def
//     | &'if' if_stmt
//     | &('class' | '@') class_def
//     | &('with' | ASYNC) with_stmt
//     | &('for' | ASYNC) for_stmt
//     | &'try' try_stmt
//     | &'while' while_stmt
//     | match_stmt
func compound_stmt_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	{ // &('def' | '@' | ASYNC) function_def
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var function_def_var stmt_ty
		condition := func() bool {
			_tmp := _PyPegen_lookahead(1, _tmp_7_rule, p)
			if _tmp == 0 {
				return false
			}
			function_def_var = function_def_rule(p)
			if function_def_var == nil {
				return false
			} // function_def
			return true
		}
		if condition() {
			_res = function_def_var
			goto done
		}
		p.mark = _mark
	}
	{ // &'if' if_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var if_stmt_var stmt_ty
		condition := func() bool {
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 639)
			if _tmp == 0 {
				return false
			} // token='if'
			if_stmt_var = if_stmt_rule(p)
			if if_stmt_var == nil {
				return false
			} // if_stmt
			return true
		}
		if condition() {
			_res = if_stmt_var
			goto done
		}
		p.mark = _mark
	}
	{ // &('class' | '@') class_def
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var class_def_var stmt_ty
		condition := func() bool {
			_tmp := _PyPegen_lookahead(1, _tmp_8_rule, p)
			if _tmp == 0 {
				return false
			}
			class_def_var = class_def_rule(p)
			if class_def_var == nil {
				return false
			} // class_def
			return true
		}
		if condition() {
			_res = class_def_var
			goto done
		}
		p.mark = _mark
	}
	{ // &('with' | ASYNC) with_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var with_stmt_var stmt_ty
		condition := func() bool {
			_tmp := _PyPegen_lookahead(1, _tmp_9_rule, p)
			if _tmp == 0 {
				return false
			}
			with_stmt_var = with_stmt_rule(p)
			if with_stmt_var == nil {
				return false
			} // with_stmt
			return true
		}
		if condition() {
			_res = with_stmt_var
			goto done
		}
		p.mark = _mark
	}
	{ // &('for' | ASYNC) for_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var for_stmt_var stmt_ty
		condition := func() bool {
			_tmp := _PyPegen_lookahead(1, _tmp_10_rule, p)
			if _tmp == 0 {
				return false
			}
			for_stmt_var = for_stmt_rule(p)
			if for_stmt_var == nil {
				return false
			} // for_stmt
			return true
		}
		if condition() {
			_res = for_stmt_var
			goto done
		}
		p.mark = _mark
	}
	{ // &'try' try_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var try_stmt_var stmt_ty
		condition := func() bool {
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 621)
			if _tmp == 0 {
				return false
			} // token='try'
			try_stmt_var = try_stmt_rule(p)
			if try_stmt_var == nil {
				return false
			} // try_stmt
			return true
		}
		if condition() {
			_res = try_stmt_var
			goto done
		}
		p.mark = _mark
	}
	{ // &'while' while_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var while_stmt_var stmt_ty
		condition := func() bool {
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 644)
			if _tmp == 0 {
				return false
			} // token='while'
			while_stmt_var = while_stmt_rule(p)
			if while_stmt_var == nil {
				return false
			} // while_stmt
			return true
		}
		if condition() {
			_res = while_stmt_var
			goto done
		}
		p.mark = _mark
	}
	{ // match_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var match_stmt_var stmt_ty
		condition := func() bool {
			match_stmt_var = match_stmt_rule(p)
			if match_stmt_var == nil {
				return false
			} // match_stmt
			return true
		}
		if condition() {
			_res = match_stmt_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// assignment:
//     | NAME ':' expression ['=' annotated_rhs]
//     | ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs]
//     | ((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT?
//     | single_target augassign ~ (yield_expr | star_expressions)
//     | invalid_assignment
func assignment_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // NAME ':' expression ['=' annotated_rhs]
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		var c any
		condition := func() bool {
			a = _PyPegen_name_token(p)
			if a == nil {
				return false
			} // NAME
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			b = expression_rule(p)
			if b == nil {
				return false
			} // expression
			c = _tmp_11_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['=' annotated_rhs]
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = CHECK_VERSION(stmt_ty, 6, "Variable annotation syntax is", _PyAST_AnnAssign(CHECK(expr_ty, _PyPegen_set_expr_context(p, a, Store)), b, c, 1, EXTRA))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs]
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a any
		var b expr_ty
		var c any
		condition := func() bool {
			a = _tmp_12_rule(p)
			if a == nil {
				return false
			} // '(' single_target ')' | single_subscript_attribute_target
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			b = expression_rule(p)
			if b == nil {
				return false
			} // expression
			c = _tmp_13_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['=' annotated_rhs]
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = CHECK_VERSION(stmt_ty, 6, "Variable annotations syntax is", _PyAST_AnnAssign(a, b, c, 0, EXTRA))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // ((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_expr_seq
		var b any
		var tc any
		condition := func() bool {
			a = *asdl_expr_seq_loop1_14_rule(p)
			if a == nil {
				return false
			} // ((star_targets '='))+
			b = _tmp_15_rule(p)
			if b == nil {
				return false
			} // yield_expr | star_expressions
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 22)
			if _tmp == 0 {
				return false
			} // token='='
			tc = _PyPegen_expect_token(p, TYPE_COMMENT)
			if p.error_indicator != 0 {
				return false
			}
			// TYPE_COMMENT?
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Assign(a, b, NEW_TYPE_COMMENT(p, tc), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // single_target augassign ~ (yield_expr | star_expressions)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		_cut_var := 0
		var a expr_ty
		var b *AugOperator
		var c any
		condition := func() bool {
			a = single_target_rule(p)
			if a == nil {
				return false
			} // single_target
			b = augassign_rule(p)
			if b == nil {
				return false
			} // augassign
			_cut_var = 1
			if _cut_var == nil {
				return false
			}
			c = _tmp_16_rule(p)
			if c == nil {
				return false
			} // yield_expr | star_expressions
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_AugAssign(a, b.kind, c, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
		if _cut_var {
			p.level--
			return nil
		}
	}
	if p.call_invalid_rules { // invalid_assignment
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_assignment_var any
		condition := func() bool {
			invalid_assignment_var = invalid_assignment_rule(p)
			if invalid_assignment_var == nil {
				return false
			} // invalid_assignment
			return true
		}
		if condition() {
			_res = invalid_assignment_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// annotated_rhs: yield_expr | star_expressions
func annotated_rhs_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	{ // yield_expr
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var yield_expr_var expr_ty
		condition := func() bool {
			yield_expr_var = yield_expr_rule(p)
			if yield_expr_var == nil {
				return false
			} // yield_expr
			return true
		}
		if condition() {
			_res = yield_expr_var
			goto done
		}
		p.mark = _mark
	}
	{ // star_expressions
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var star_expressions_var expr_ty
		condition := func() bool {
			star_expressions_var = star_expressions_rule(p)
			if star_expressions_var == nil {
				return false
			} // star_expressions
			return true
		}
		if condition() {
			_res = star_expressions_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// augassign:
//     | '+='
//     | '-='
//     | '*='
//     | '@='
//     | '/='
//     | '%='
//     | '&='
//     | '|='
//     | '^='
//     | '<<='
//     | '>>='
//     | '**='
//     | '//='
func augassign_rule(p *Parser) *AugOperator {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *AugOperator
	_mark := p.mark
	{ // '+='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 36)
			if _literal == nil {
				return false
			} // token='+='
			return true
		}
		if condition() {
			_res = _PyPegen_augoperator(p, Add)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '-='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 37)
			if _literal == nil {
				return false
			} // token='-='
			return true
		}
		if condition() {
			_res = _PyPegen_augoperator(p, Sub)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '*='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 38)
			if _literal == nil {
				return false
			} // token='*='
			return true
		}
		if condition() {
			_res = _PyPegen_augoperator(p, Mult)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '@='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 50)
			if _literal == nil {
				return false
			} // token='@='
			return true
		}
		if condition() {
			_res = CHECK_VERSION(*AugOperator, 5, "The '@' operator is", _PyPegen_augoperator(p, MatMult))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '/='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 39)
			if _literal == nil {
				return false
			} // token='/='
			return true
		}
		if condition() {
			_res = _PyPegen_augoperator(p, Div)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '%='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 40)
			if _literal == nil {
				return false
			} // token='%='
			return true
		}
		if condition() {
			_res = _PyPegen_augoperator(p, Mod)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '&='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 41)
			if _literal == nil {
				return false
			} // token='&='
			return true
		}
		if condition() {
			_res = _PyPegen_augoperator(p, BitAnd)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '|='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 42)
			if _literal == nil {
				return false
			} // token='|='
			return true
		}
		if condition() {
			_res = _PyPegen_augoperator(p, BitOr)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '^='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 43)
			if _literal == nil {
				return false
			} // token='^='
			return true
		}
		if condition() {
			_res = _PyPegen_augoperator(p, BitXor)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '<<='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 44)
			if _literal == nil {
				return false
			} // token='<<='
			return true
		}
		if condition() {
			_res = _PyPegen_augoperator(p, LShift)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '>>='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 45)
			if _literal == nil {
				return false
			} // token='>>='
			return true
		}
		if condition() {
			_res = _PyPegen_augoperator(p, RShift)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '**='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 46)
			if _literal == nil {
				return false
			} // token='**='
			return true
		}
		if condition() {
			_res = _PyPegen_augoperator(p, Pow)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '//='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 48)
			if _literal == nil {
				return false
			} // token='//='
			return true
		}
		if condition() {
			_res = _PyPegen_augoperator(p, FloorDiv)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// return_stmt: 'return' star_expressions?
func return_stmt_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // 'return' star_expressions?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var a any
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 519)
			if _keyword == nil {
				return false
			} // token='return'
			a = star_expressions_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// star_expressions?
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Return(a, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// raise_stmt: 'raise' expression ['from' expression] | 'raise'
func raise_stmt_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // 'raise' expression ['from' expression]
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var a expr_ty
		var b any
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 522)
			if _keyword == nil {
				return false
			} // token='raise'
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			b = _tmp_17_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['from' expression]
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Raise(a, b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'raise'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 522)
			if _keyword == nil {
				return false
			} // token='raise'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Raise(nil, nil, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// global_stmt: 'global' ','.NAME+
func global_stmt_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // 'global' ','.NAME+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var a *asdl_expr_seq
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 523)
			if _keyword == nil {
				return false
			} // token='global'
			a = *asdl_expr_seq_gather_18_rule(p)
			if a == nil {
				return false
			} // ','.NAME+
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Global(CHECK(*asdl_identifier_seq, _PyPegen_map_names_to_ids(p, a)), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// nonlocal_stmt: 'nonlocal' ','.NAME+
func nonlocal_stmt_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // 'nonlocal' ','.NAME+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var a *asdl_expr_seq
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 524)
			if _keyword == nil {
				return false
			} // token='nonlocal'
			a = *asdl_expr_seq_gather_20_rule(p)
			if a == nil {
				return false
			} // ','.NAME+
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Nonlocal(CHECK(*asdl_identifier_seq, _PyPegen_map_names_to_ids(p, a)), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// del_stmt: 'del' del_targets &(';' | NEWLINE) | invalid_del_stmt
func del_stmt_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // 'del' del_targets &(';' | NEWLINE)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var a *asdl_expr_seq
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 603)
			if _keyword == nil {
				return false
			} // token='del'
			a = del_targets_rule(p)
			if a == nil {
				return false
			} // del_targets
			_tmp := _PyPegen_lookahead(1, _tmp_22_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Delete(a, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	if p.call_invalid_rules { // invalid_del_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_del_stmt_var any
		condition := func() bool {
			invalid_del_stmt_var = invalid_del_stmt_rule(p)
			if invalid_del_stmt_var == nil {
				return false
			} // invalid_del_stmt
			return true
		}
		if condition() {
			_res = invalid_del_stmt_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// yield_stmt: yield_expr
func yield_stmt_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // yield_expr
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var y expr_ty
		condition := func() bool {
			y = yield_expr_rule(p)
			if y == nil {
				return false
			} // yield_expr
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Expr(y, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// assert_stmt: 'assert' expression [',' expression]
func assert_stmt_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // 'assert' expression [',' expression]
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var a expr_ty
		var b any
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 526)
			if _keyword == nil {
				return false
			} // token='assert'
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			b = _tmp_23_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// [',' expression]
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Assert(a, b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// import_stmt: import_name | import_from
func import_stmt_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	{ // import_name
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var import_name_var stmt_ty
		condition := func() bool {
			import_name_var = import_name_rule(p)
			if import_name_var == nil {
				return false
			} // import_name
			return true
		}
		if condition() {
			_res = import_name_var
			goto done
		}
		p.mark = _mark
	}
	{ // import_from
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var import_from_var stmt_ty
		condition := func() bool {
			import_from_var = import_from_rule(p)
			if import_from_var == nil {
				return false
			} // import_from
			return true
		}
		if condition() {
			_res = import_from_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// import_name: 'import' dotted_as_names
func import_name_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // 'import' dotted_as_names
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var a *asdl_alias_seq
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 531)
			if _keyword == nil {
				return false
			} // token='import'
			a = dotted_as_names_rule(p)
			if a == nil {
				return false
			} // dotted_as_names
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Import(a, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// import_from:
//     | 'from' (('.' | '...'))* dotted_name 'import' import_from_targets
//     | 'from' (('.' | '...'))+ 'import' import_from_targets
func import_from_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // 'from' (('.' | '...'))* dotted_name 'import' import_from_targets
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _keyword_1 *Token
		var a *asdl_seq
		var b expr_ty
		var c *asdl_alias_seq
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 572)
			if _keyword == nil {
				return false
			} // token='from'
			a = _loop0_24_rule(p)
			if a == nil {
				return false
			} // (('.' | '...'))*
			b = dotted_name_rule(p)
			if b == nil {
				return false
			} // dotted_name
			_keyword_1 = _PyPegen_expect_token(p, 531)
			if _keyword_1 == nil {
				return false
			} // token='import'
			c = import_from_targets_rule(p)
			if c == nil {
				return false
			} // import_from_targets
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_ImportFrom(b.v.Name.id, c, _PyPegen_seq_count_dots(a), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'from' (('.' | '...'))+ 'import' import_from_targets
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _keyword_1 *Token
		var a *asdl_seq
		var b *asdl_alias_seq
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 572)
			if _keyword == nil {
				return false
			} // token='from'
			a = _loop1_25_rule(p)
			if a == nil {
				return false
			} // (('.' | '...'))+
			_keyword_1 = _PyPegen_expect_token(p, 531)
			if _keyword_1 == nil {
				return false
			} // token='import'
			b = import_from_targets_rule(p)
			if b == nil {
				return false
			} // import_from_targets
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_ImportFrom(nil, b, _PyPegen_seq_count_dots(a), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// import_from_targets:
//     | '(' import_from_as_names ','? ')'
//     | import_from_as_names !','
//     | '*'
//     | invalid_import_from_targets
func import_from_targets_rule(p *Parser) *asdl_alias_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_alias_seq
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // '(' import_from_as_names ','? ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a *asdl_alias_seq
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			a = import_from_as_names_rule(p)
			if a == nil {
				return false
			} // import_from_as_names
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // import_from_as_names !','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var import_from_as_names_var *asdl_alias_seq
		condition := func() bool {
			import_from_as_names_var = import_from_as_names_rule(p)
			if import_from_as_names_var == nil {
				return false
			} // import_from_as_names
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 12)
			if _tmp == 0 {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = import_from_as_names_var
			goto done
		}
		p.mark = _mark
	}
	{ // '*'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyPegen_singleton_seq(p, CHECK(alias_ty, _PyPegen_alias_for_star(p, EXTRA)))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	if p.call_invalid_rules { // invalid_import_from_targets
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_import_from_targets_var any
		condition := func() bool {
			invalid_import_from_targets_var = invalid_import_from_targets_rule(p)
			if invalid_import_from_targets_var == nil {
				return false
			} // invalid_import_from_targets
			return true
		}
		if condition() {
			_res = invalid_import_from_targets_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// import_from_as_names: ','.import_from_as_name+
func import_from_as_names_rule(p *Parser) *asdl_alias_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_alias_seq
	_mark := p.mark
	{ // ','.import_from_as_name+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_alias_seq
		condition := func() bool {
			a = *asdl_alias_seq_gather_26_rule(p)
			if a == nil {
				return false
			} // ','.import_from_as_name+
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// import_from_as_name: NAME ['as' NAME]
func import_from_as_name_rule(p *Parser) alias_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res alias_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // NAME ['as' NAME]
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		var b any
		condition := func() bool {
			a = _PyPegen_name_token(p)
			if a == nil {
				return false
			} // NAME
			b = _tmp_28_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['as' NAME]
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_alias(a.v.Name.id, ternary_operator(b, b.v.Name.id, nil), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// dotted_as_names: ','.dotted_as_name+
func dotted_as_names_rule(p *Parser) *asdl_alias_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_alias_seq
	_mark := p.mark
	{ // ','.dotted_as_name+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_alias_seq
		condition := func() bool {
			a = *asdl_alias_seq_gather_29_rule(p)
			if a == nil {
				return false
			} // ','.dotted_as_name+
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// dotted_as_name: dotted_name ['as' NAME]
func dotted_as_name_rule(p *Parser) alias_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res alias_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // dotted_name ['as' NAME]
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		var b any
		condition := func() bool {
			a = dotted_name_rule(p)
			if a == nil {
				return false
			} // dotted_name
			b = _tmp_31_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['as' NAME]
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_alias(a.v.Name.id, ternary_operator(b, b.v.Name.id, nil), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// Left-recursive
// dotted_name: dotted_name '.' NAME | NAME
func dotted_name_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	var expr_ty _res
	if _PyPegen_is_memoized(p, dotted_name_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	_resmark := p.mark
	for {
		tmpvar_0 := _PyPegen_update_memo(p, _mark, dotted_name_type, _res)
		if tmpvar_0 {
			p.level--
			return _res
		}
		p.mark = _mark
		_raw := dotted_name_raw(p)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		if _raw == nil || p.mark <= _resmark {
			break
		}
		_resmark = p.mark
		_res = _raw
	}
	p.mark = _resmark
	p.level--
	return _res
}
func dotted_name_raw(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	{ // dotted_name '.' NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = dotted_name_rule(p)
			if a == nil {
				return false
			} // dotted_name
			_literal = _PyPegen_expect_token(p, 23)
			if _literal == nil {
				return false
			} // token='.'
			b = _PyPegen_name_token(p)
			if b == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_res = _PyPegen_join_names_with_dot(p, a, b)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var name_var expr_ty
		condition := func() bool {
			name_var = _PyPegen_name_token(p)
			if name_var == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_res = name_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// block: NEWLINE INDENT statements DEDENT | simple_stmts | invalid_block
func block_rule(p *Parser) *asdl_stmt_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_stmt_seq
	if _PyPegen_is_memoized(p, block_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	{ // NEWLINE INDENT statements DEDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_stmt_seq
		var dedent_var *Token
		var indent_var *Token
		var newline_var *Token
		condition := func() bool {
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			indent_var = _PyPegen_expect_token(p, INDENT)
			if indent_var == nil {
				return false
			} // token='INDENT'
			a = statements_rule(p)
			if a == nil {
				return false
			} // statements
			dedent_var = _PyPegen_expect_token(p, DEDENT)
			if dedent_var == nil {
				return false
			} // token='DEDENT'
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // simple_stmts
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var simple_stmts_var *asdl_stmt_seq
		condition := func() bool {
			simple_stmts_var = simple_stmts_rule(p)
			if simple_stmts_var == nil {
				return false
			} // simple_stmts
			return true
		}
		if condition() {
			_res = simple_stmts_var
			goto done
		}
		p.mark = _mark
	}
	if p.call_invalid_rules { // invalid_block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_block_var any
		condition := func() bool {
			invalid_block_var = invalid_block_rule(p)
			if invalid_block_var == nil {
				return false
			} // invalid_block
			return true
		}
		if condition() {
			_res = invalid_block_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	_PyPegen_insert_memo(p, _mark, block_type, _res)
	p.level--
	return _res
}

// decorators: (('@' named_expression NEWLINE))+
func decorators_rule(p *Parser) *asdl_expr_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_expr_seq
	_mark := p.mark
	{ // (('@' named_expression NEWLINE))+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_expr_seq
		condition := func() bool {
			a = *asdl_expr_seq_loop1_32_rule(p)
			if a == nil {
				return false
			} // (('@' named_expression NEWLINE))+
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// class_def: decorators class_def_raw | class_def_raw
func class_def_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	{ // decorators class_def_raw
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_expr_seq
		var b stmt_ty
		condition := func() bool {
			a = decorators_rule(p)
			if a == nil {
				return false
			} // decorators
			b = class_def_raw_rule(p)
			if b == nil {
				return false
			} // class_def_raw
			return true
		}
		if condition() {
			_res = _PyPegen_class_def_decorators(p, a, b)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // class_def_raw
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var class_def_raw_var stmt_ty
		condition := func() bool {
			class_def_raw_var = class_def_raw_rule(p)
			if class_def_raw_var == nil {
				return false
			} // class_def_raw
			return true
		}
		if condition() {
			_res = class_def_raw_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// class_def_raw: invalid_class_def_raw | 'class' NAME ['(' arguments? ')'] ':' block
func class_def_raw_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	if p.call_invalid_rules { // invalid_class_def_raw
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_class_def_raw_var any
		condition := func() bool {
			invalid_class_def_raw_var = invalid_class_def_raw_rule(p)
			if invalid_class_def_raw_var == nil {
				return false
			} // invalid_class_def_raw
			return true
		}
		if condition() {
			_res = invalid_class_def_raw_var
			goto done
		}
		p.mark = _mark
	}
	{ // 'class' NAME ['(' arguments? ')'] ':' block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var a expr_ty
		var b any
		var c *asdl_stmt_seq
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 651)
			if _keyword == nil {
				return false
			} // token='class'
			a = _PyPegen_name_token(p)
			if a == nil {
				return false
			} // NAME
			b = _tmp_33_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['(' arguments? ')']
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			c = block_rule(p)
			if c == nil {
				return false
			} // block
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_ClassDef(a.v.Name.id, ternary_operator(b, b.v.Call.args, nil), ternary_operator(b, b.v.Call.keywords, nil), c, nil, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// function_def: decorators function_def_raw | function_def_raw
func function_def_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	{ // decorators function_def_raw
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var d *asdl_expr_seq
		var f stmt_ty
		condition := func() bool {
			d = decorators_rule(p)
			if d == nil {
				return false
			} // decorators
			f = function_def_raw_rule(p)
			if f == nil {
				return false
			} // function_def_raw
			return true
		}
		if condition() {
			_res = _PyPegen_function_def_decorators(p, d, f)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // function_def_raw
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var function_def_raw_var stmt_ty
		condition := func() bool {
			function_def_raw_var = function_def_raw_rule(p)
			if function_def_raw_var == nil {
				return false
			} // function_def_raw
			return true
		}
		if condition() {
			_res = function_def_raw_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// function_def_raw:
//     | invalid_def_raw
//     | 'def' NAME &&'(' params? ')' ['->' expression] &&':' func_type_comment? block
//     | ASYNC 'def' NAME &&'(' params? ')' ['->' expression] &&':' func_type_comment? block
func function_def_raw_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	if p.call_invalid_rules { // invalid_def_raw
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_def_raw_var any
		condition := func() bool {
			invalid_def_raw_var = invalid_def_raw_rule(p)
			if invalid_def_raw_var == nil {
				return false
			} // invalid_def_raw
			return true
		}
		if condition() {
			_res = invalid_def_raw_var
			goto done
		}
		p.mark = _mark
	}
	{ // 'def' NAME &&'(' params? ')' ['->' expression] &&':' func_type_comment? block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var _literal_1 *Token
		var _literal_2 *Token
		var a any
		var b *asdl_stmt_seq
		var n expr_ty
		var params any
		var tc any
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 649)
			if _keyword == nil {
				return false
			} // token='def'
			n = _PyPegen_name_token(p)
			if n == nil {
				return false
			} // NAME
			_literal = _PyPegen_expect_forced_token(p, 7, "(")
			if _literal == nil {
				return false
			} // forced_token='('
			params = params_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// params?
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			a = _tmp_34_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['->' expression]
			_literal_2 = _PyPegen_expect_forced_token(p, 11, ":")
			if _literal_2 == nil {
				return false
			} // forced_token=':'
			tc = func_type_comment_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// func_type_comment?
			b = block_rule(p)
			if b == nil {
				return false
			} // block
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_FunctionDef(n.v.Name.id, ternary_operator(params, params, CHECK(arguments_ty, _PyPegen_empty_arguments(p))), b, nil, a, NEW_TYPE_COMMENT(p, tc), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // ASYNC 'def' NAME &&'(' params? ')' ['->' expression] &&':' func_type_comment? block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var _literal_1 *Token
		var _literal_2 *Token
		var a any
		var async_var *Token
		var b *asdl_stmt_seq
		var n expr_ty
		var params any
		var tc any
		condition := func() bool {
			async_var = _PyPegen_expect_token(p, ASYNC)
			if async_var == nil {
				return false
			} // token='ASYNC'
			_keyword = _PyPegen_expect_token(p, 649)
			if _keyword == nil {
				return false
			} // token='def'
			n = _PyPegen_name_token(p)
			if n == nil {
				return false
			} // NAME
			_literal = _PyPegen_expect_forced_token(p, 7, "(")
			if _literal == nil {
				return false
			} // forced_token='('
			params = params_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// params?
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			a = _tmp_35_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['->' expression]
			_literal_2 = _PyPegen_expect_forced_token(p, 11, ":")
			if _literal_2 == nil {
				return false
			} // forced_token=':'
			tc = func_type_comment_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// func_type_comment?
			b = block_rule(p)
			if b == nil {
				return false
			} // block
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = CHECK_VERSION(stmt_ty, 5, "Async functions are", _PyAST_AsyncFunctionDef(n.v.Name.id, ternary_operator(params, params, CHECK(arguments_ty, _PyPegen_empty_arguments(p))), b, nil, a, NEW_TYPE_COMMENT(p, tc), EXTRA))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// params: invalid_parameters | parameters
func params_rule(p *Parser) arguments_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res arguments_ty
	_mark := p.mark
	if p.call_invalid_rules { // invalid_parameters
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_parameters_var any
		condition := func() bool {
			invalid_parameters_var = invalid_parameters_rule(p)
			if invalid_parameters_var == nil {
				return false
			} // invalid_parameters
			return true
		}
		if condition() {
			_res = invalid_parameters_var
			goto done
		}
		p.mark = _mark
	}
	{ // parameters
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var parameters_var arguments_ty
		condition := func() bool {
			parameters_var = parameters_rule(p)
			if parameters_var == nil {
				return false
			} // parameters
			return true
		}
		if condition() {
			_res = parameters_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// parameters:
//     | slash_no_default param_no_default* param_with_default* star_etc?
//     | slash_with_default param_with_default* star_etc?
//     | param_no_default+ param_with_default* star_etc?
//     | param_with_default+ star_etc?
//     | star_etc
func parameters_rule(p *Parser) arguments_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res arguments_ty
	_mark := p.mark
	{ // slash_no_default param_no_default* param_with_default* star_etc?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_arg_seq
		var b *asdl_arg_seq
		var c *asdl_seq
		var d any
		condition := func() bool {
			a = slash_no_default_rule(p)
			if a == nil {
				return false
			} // slash_no_default
			b = *asdl_arg_seq_loop0_36_rule(p)
			if b == nil {
				return false
			} // param_no_default*
			c = _loop0_37_rule(p)
			if c == nil {
				return false
			} // param_with_default*
			d = star_etc_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// star_etc?
			return true
		}
		if condition() {
			_res = CHECK_VERSION(arguments_ty, 8, "Positional-only parameters are", _PyPegen_make_arguments(p, a, nil, b, c, d))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // slash_with_default param_with_default* star_etc?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *SlashWithDefault
		var b *asdl_seq
		var c any
		condition := func() bool {
			a = slash_with_default_rule(p)
			if a == nil {
				return false
			} // slash_with_default
			b = _loop0_38_rule(p)
			if b == nil {
				return false
			} // param_with_default*
			c = star_etc_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// star_etc?
			return true
		}
		if condition() {
			_res = CHECK_VERSION(arguments_ty, 8, "Positional-only parameters are", _PyPegen_make_arguments(p, nil, a, nil, b, c))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // param_no_default+ param_with_default* star_etc?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_arg_seq
		var b *asdl_seq
		var c any
		condition := func() bool {
			a = *asdl_arg_seq_loop1_39_rule(p)
			if a == nil {
				return false
			} // param_no_default+
			b = _loop0_40_rule(p)
			if b == nil {
				return false
			} // param_with_default*
			c = star_etc_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// star_etc?
			return true
		}
		if condition() {
			_res = _PyPegen_make_arguments(p, nil, nil, a, b, c)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // param_with_default+ star_etc?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_seq
		var b any
		condition := func() bool {
			a = _loop1_41_rule(p)
			if a == nil {
				return false
			} // param_with_default+
			b = star_etc_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// star_etc?
			return true
		}
		if condition() {
			_res = _PyPegen_make_arguments(p, nil, nil, nil, a, b)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // star_etc
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *StarEtc
		condition := func() bool {
			a = star_etc_rule(p)
			if a == nil {
				return false
			} // star_etc
			return true
		}
		if condition() {
			_res = _PyPegen_make_arguments(p, nil, nil, nil, nil, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// slash_no_default: param_no_default+ '/' ',' | param_no_default+ '/' &')'
func slash_no_default_rule(p *Parser) *asdl_arg_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_arg_seq
	_mark := p.mark
	{ // param_no_default+ '/' ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a *asdl_arg_seq
		condition := func() bool {
			a = *asdl_arg_seq_loop1_42_rule(p)
			if a == nil {
				return false
			} // param_no_default+
			_literal = _PyPegen_expect_token(p, 17)
			if _literal == nil {
				return false
			} // token='/'
			_literal_1 = _PyPegen_expect_token(p, 12)
			if _literal_1 == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // param_no_default+ '/' &')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *asdl_arg_seq
		condition := func() bool {
			a = *asdl_arg_seq_loop1_43_rule(p)
			if a == nil {
				return false
			} // param_no_default+
			_literal = _PyPegen_expect_token(p, 17)
			if _literal == nil {
				return false
			} // token='/'
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)
			if _tmp == 0 {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// slash_with_default:
//     | param_no_default* param_with_default+ '/' ','
//     | param_no_default* param_with_default+ '/' &')'
func slash_with_default_rule(p *Parser) *SlashWithDefault {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *SlashWithDefault
	_mark := p.mark
	{ // param_no_default* param_with_default+ '/' ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a *asdl_seq
		var b *asdl_seq
		condition := func() bool {
			a = _loop0_44_rule(p)
			if a == nil {
				return false
			} // param_no_default*
			b = _loop1_45_rule(p)
			if b == nil {
				return false
			} // param_with_default+
			_literal = _PyPegen_expect_token(p, 17)
			if _literal == nil {
				return false
			} // token='/'
			_literal_1 = _PyPegen_expect_token(p, 12)
			if _literal_1 == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = _PyPegen_slash_with_default(p, a, b)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // param_no_default* param_with_default+ '/' &')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *asdl_seq
		var b *asdl_seq
		condition := func() bool {
			a = _loop0_46_rule(p)
			if a == nil {
				return false
			} // param_no_default*
			b = _loop1_47_rule(p)
			if b == nil {
				return false
			} // param_with_default+
			_literal = _PyPegen_expect_token(p, 17)
			if _literal == nil {
				return false
			} // token='/'
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)
			if _tmp == 0 {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = _PyPegen_slash_with_default(p, a, b)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// star_etc:
//     | invalid_star_etc
//     | '*' param_no_default param_maybe_default* kwds?
//     | '*' param_no_default_star_annotation param_maybe_default* kwds?
//     | '*' ',' param_maybe_default+ kwds?
//     | kwds
func star_etc_rule(p *Parser) *StarEtc {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *StarEtc
	_mark := p.mark
	if p.call_invalid_rules { // invalid_star_etc
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_star_etc_var any
		condition := func() bool {
			invalid_star_etc_var = invalid_star_etc_rule(p)
			if invalid_star_etc_var == nil {
				return false
			} // invalid_star_etc
			return true
		}
		if condition() {
			_res = invalid_star_etc_var
			goto done
		}
		p.mark = _mark
	}
	{ // '*' param_no_default param_maybe_default* kwds?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a arg_ty
		var b *asdl_seq
		var c any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			a = param_no_default_rule(p)
			if a == nil {
				return false
			} // param_no_default
			b = _loop0_48_rule(p)
			if b == nil {
				return false
			} // param_maybe_default*
			c = kwds_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// kwds?
			return true
		}
		if condition() {
			_res = _PyPegen_star_etc(p, a, b, c)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '*' param_no_default_star_annotation param_maybe_default* kwds?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a arg_ty
		var b *asdl_seq
		var c any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			a = param_no_default_star_annotation_rule(p)
			if a == nil {
				return false
			} // param_no_default_star_annotation
			b = _loop0_49_rule(p)
			if b == nil {
				return false
			} // param_maybe_default*
			c = kwds_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// kwds?
			return true
		}
		if condition() {
			_res = _PyPegen_star_etc(p, a, b, c)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '*' ',' param_maybe_default+ kwds?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var b *asdl_seq
		var c any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			_literal_1 = _PyPegen_expect_token(p, 12)
			if _literal_1 == nil {
				return false
			} // token=','
			b = _loop1_50_rule(p)
			if b == nil {
				return false
			} // param_maybe_default+
			c = kwds_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// kwds?
			return true
		}
		if condition() {
			_res = _PyPegen_star_etc(p, nil, b, c)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // kwds
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a arg_ty
		condition := func() bool {
			a = kwds_rule(p)
			if a == nil {
				return false
			} // kwds
			return true
		}
		if condition() {
			_res = _PyPegen_star_etc(p, nil, nil, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// kwds: invalid_kwds | '**' param_no_default
func kwds_rule(p *Parser) arg_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res arg_ty
	_mark := p.mark
	if p.call_invalid_rules { // invalid_kwds
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_kwds_var any
		condition := func() bool {
			invalid_kwds_var = invalid_kwds_rule(p)
			if invalid_kwds_var == nil {
				return false
			} // invalid_kwds
			return true
		}
		if condition() {
			_res = invalid_kwds_var
			goto done
		}
		p.mark = _mark
	}
	{ // '**' param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a arg_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 35)
			if _literal == nil {
				return false
			} // token='**'
			a = param_no_default_rule(p)
			if a == nil {
				return false
			} // param_no_default
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// param_no_default: param ',' TYPE_COMMENT? | param TYPE_COMMENT? &')'
func param_no_default_rule(p *Parser) arg_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res arg_ty
	_mark := p.mark
	{ // param ',' TYPE_COMMENT?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a arg_ty
		var tc any
		condition := func() bool {
			a = param_rule(p)
			if a == nil {
				return false
			} // param
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			tc = _PyPegen_expect_token(p, TYPE_COMMENT)
			if p.error_indicator != 0 {
				return false
			}
			// TYPE_COMMENT?
			return true
		}
		if condition() {
			_res = _PyPegen_add_type_comment_to_arg(p, a, tc)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // param TYPE_COMMENT? &')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a arg_ty
		var tc any
		condition := func() bool {
			a = param_rule(p)
			if a == nil {
				return false
			} // param
			tc = _PyPegen_expect_token(p, TYPE_COMMENT)
			if p.error_indicator != 0 {
				return false
			}
			// TYPE_COMMENT?
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)
			if _tmp == 0 {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = _PyPegen_add_type_comment_to_arg(p, a, tc)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// param_no_default_star_annotation:
//     | param_star_annotation ',' TYPE_COMMENT?
//     | param_star_annotation TYPE_COMMENT? &')'
func param_no_default_star_annotation_rule(p *Parser) arg_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res arg_ty
	_mark := p.mark
	{ // param_star_annotation ',' TYPE_COMMENT?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a arg_ty
		var tc any
		condition := func() bool {
			a = param_star_annotation_rule(p)
			if a == nil {
				return false
			} // param_star_annotation
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			tc = _PyPegen_expect_token(p, TYPE_COMMENT)
			if p.error_indicator != 0 {
				return false
			}
			// TYPE_COMMENT?
			return true
		}
		if condition() {
			_res = _PyPegen_add_type_comment_to_arg(p, a, tc)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // param_star_annotation TYPE_COMMENT? &')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a arg_ty
		var tc any
		condition := func() bool {
			a = param_star_annotation_rule(p)
			if a == nil {
				return false
			} // param_star_annotation
			tc = _PyPegen_expect_token(p, TYPE_COMMENT)
			if p.error_indicator != 0 {
				return false
			}
			// TYPE_COMMENT?
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)
			if _tmp == 0 {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = _PyPegen_add_type_comment_to_arg(p, a, tc)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// param_with_default: param default ',' TYPE_COMMENT? | param default TYPE_COMMENT? &')'
func param_with_default_rule(p *Parser) *NameDefaultPair {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *NameDefaultPair
	_mark := p.mark
	{ // param default ',' TYPE_COMMENT?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a arg_ty
		var c expr_ty
		var tc any
		condition := func() bool {
			a = param_rule(p)
			if a == nil {
				return false
			} // param
			c = default_rule(p)
			if c == nil {
				return false
			} // default
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			tc = _PyPegen_expect_token(p, TYPE_COMMENT)
			if p.error_indicator != 0 {
				return false
			}
			// TYPE_COMMENT?
			return true
		}
		if condition() {
			_res = _PyPegen_name_default_pair(p, a, c, tc)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // param default TYPE_COMMENT? &')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a arg_ty
		var c expr_ty
		var tc any
		condition := func() bool {
			a = param_rule(p)
			if a == nil {
				return false
			} // param
			c = default_rule(p)
			if c == nil {
				return false
			} // default
			tc = _PyPegen_expect_token(p, TYPE_COMMENT)
			if p.error_indicator != 0 {
				return false
			}
			// TYPE_COMMENT?
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)
			if _tmp == 0 {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = _PyPegen_name_default_pair(p, a, c, tc)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// param_maybe_default:
//     | param default? ',' TYPE_COMMENT?
//     | param default? TYPE_COMMENT? &')'
func param_maybe_default_rule(p *Parser) *NameDefaultPair {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *NameDefaultPair
	_mark := p.mark
	{ // param default? ',' TYPE_COMMENT?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a arg_ty
		var c any
		var tc any
		condition := func() bool {
			a = param_rule(p)
			if a == nil {
				return false
			} // param
			c = default_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// default?
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			tc = _PyPegen_expect_token(p, TYPE_COMMENT)
			if p.error_indicator != 0 {
				return false
			}
			// TYPE_COMMENT?
			return true
		}
		if condition() {
			_res = _PyPegen_name_default_pair(p, a, c, tc)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // param default? TYPE_COMMENT? &')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a arg_ty
		var c any
		var tc any
		condition := func() bool {
			a = param_rule(p)
			if a == nil {
				return false
			} // param
			c = default_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// default?
			tc = _PyPegen_expect_token(p, TYPE_COMMENT)
			if p.error_indicator != 0 {
				return false
			}
			// TYPE_COMMENT?
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)
			if _tmp == 0 {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = _PyPegen_name_default_pair(p, a, c, tc)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// param: NAME annotation?
func param_rule(p *Parser) arg_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res arg_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // NAME annotation?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		var b any
		condition := func() bool {
			a = _PyPegen_name_token(p)
			if a == nil {
				return false
			} // NAME
			b = annotation_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// annotation?
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_arg(a.v.Name.id, b, nil, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// param_star_annotation: NAME star_annotation
func param_star_annotation_rule(p *Parser) arg_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res arg_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // NAME star_annotation
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = _PyPegen_name_token(p)
			if a == nil {
				return false
			} // NAME
			b = star_annotation_rule(p)
			if b == nil {
				return false
			} // star_annotation
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_arg(a.v.Name.id, b, nil, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// annotation: ':' expression
func annotation_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	{ // ':' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// star_annotation: ':' star_expression
func star_annotation_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	{ // ':' star_expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			a = star_expression_rule(p)
			if a == nil {
				return false
			} // star_expression
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// default: '=' expression | invalid_default
func default_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	{ // '=' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 22)
			if _literal == nil {
				return false
			} // token='='
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	if p.call_invalid_rules { // invalid_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_default_var any
		condition := func() bool {
			invalid_default_var = invalid_default_rule(p)
			if invalid_default_var == nil {
				return false
			} // invalid_default
			return true
		}
		if condition() {
			_res = invalid_default_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// if_stmt:
//     | invalid_if_stmt
//     | 'if' named_expression ':' block elif_stmt
//     | 'if' named_expression ':' block else_block?
func if_stmt_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	if p.call_invalid_rules { // invalid_if_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_if_stmt_var any
		condition := func() bool {
			invalid_if_stmt_var = invalid_if_stmt_rule(p)
			if invalid_if_stmt_var == nil {
				return false
			} // invalid_if_stmt
			return true
		}
		if condition() {
			_res = invalid_if_stmt_var
			goto done
		}
		p.mark = _mark
	}
	{ // 'if' named_expression ':' block elif_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var a expr_ty
		var b *asdl_stmt_seq
		var c stmt_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 639)
			if _keyword == nil {
				return false
			} // token='if'
			a = named_expression_rule(p)
			if a == nil {
				return false
			} // named_expression
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			b = block_rule(p)
			if b == nil {
				return false
			} // block
			c = elif_stmt_rule(p)
			if c == nil {
				return false
			} // elif_stmt
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_If(a, b, CHECK(*asdl_stmt_seq, _PyPegen_singleton_seq(p, c)), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'if' named_expression ':' block else_block?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var a expr_ty
		var b *asdl_stmt_seq
		var c any
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 639)
			if _keyword == nil {
				return false
			} // token='if'
			a = named_expression_rule(p)
			if a == nil {
				return false
			} // named_expression
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			b = block_rule(p)
			if b == nil {
				return false
			} // block
			c = else_block_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// else_block?
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_If(a, b, c, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// elif_stmt:
//     | invalid_elif_stmt
//     | 'elif' named_expression ':' block elif_stmt
//     | 'elif' named_expression ':' block else_block?
func elif_stmt_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	if p.call_invalid_rules { // invalid_elif_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_elif_stmt_var any
		condition := func() bool {
			invalid_elif_stmt_var = invalid_elif_stmt_rule(p)
			if invalid_elif_stmt_var == nil {
				return false
			} // invalid_elif_stmt
			return true
		}
		if condition() {
			_res = invalid_elif_stmt_var
			goto done
		}
		p.mark = _mark
	}
	{ // 'elif' named_expression ':' block elif_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var a expr_ty
		var b *asdl_stmt_seq
		var c stmt_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 641)
			if _keyword == nil {
				return false
			} // token='elif'
			a = named_expression_rule(p)
			if a == nil {
				return false
			} // named_expression
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			b = block_rule(p)
			if b == nil {
				return false
			} // block
			c = elif_stmt_rule(p)
			if c == nil {
				return false
			} // elif_stmt
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_If(a, b, CHECK(*asdl_stmt_seq, _PyPegen_singleton_seq(p, c)), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'elif' named_expression ':' block else_block?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var a expr_ty
		var b *asdl_stmt_seq
		var c any
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 641)
			if _keyword == nil {
				return false
			} // token='elif'
			a = named_expression_rule(p)
			if a == nil {
				return false
			} // named_expression
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			b = block_rule(p)
			if b == nil {
				return false
			} // block
			c = else_block_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// else_block?
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_If(a, b, c, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// else_block: invalid_else_stmt | 'else' &&':' block
func else_block_rule(p *Parser) *asdl_stmt_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_stmt_seq
	_mark := p.mark
	if p.call_invalid_rules { // invalid_else_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_else_stmt_var any
		condition := func() bool {
			invalid_else_stmt_var = invalid_else_stmt_rule(p)
			if invalid_else_stmt_var == nil {
				return false
			} // invalid_else_stmt
			return true
		}
		if condition() {
			_res = invalid_else_stmt_var
			goto done
		}
		p.mark = _mark
	}
	{ // 'else' &&':' block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var b *asdl_stmt_seq
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 642)
			if _keyword == nil {
				return false
			} // token='else'
			_literal = _PyPegen_expect_forced_token(p, 11, ":")
			if _literal == nil {
				return false
			} // forced_token=':'
			b = block_rule(p)
			if b == nil {
				return false
			} // block
			return true
		}
		if condition() {
			_res = b
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// while_stmt: invalid_while_stmt | 'while' named_expression ':' block else_block?
func while_stmt_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	if p.call_invalid_rules { // invalid_while_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_while_stmt_var any
		condition := func() bool {
			invalid_while_stmt_var = invalid_while_stmt_rule(p)
			if invalid_while_stmt_var == nil {
				return false
			} // invalid_while_stmt
			return true
		}
		if condition() {
			_res = invalid_while_stmt_var
			goto done
		}
		p.mark = _mark
	}
	{ // 'while' named_expression ':' block else_block?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var a expr_ty
		var b *asdl_stmt_seq
		var c any
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 644)
			if _keyword == nil {
				return false
			} // token='while'
			a = named_expression_rule(p)
			if a == nil {
				return false
			} // named_expression
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			b = block_rule(p)
			if b == nil {
				return false
			} // block
			c = else_block_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// else_block?
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_While(a, b, c, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// for_stmt:
//     | invalid_for_stmt
//     | 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?
//     | ASYNC 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?
//     | invalid_for_target
func for_stmt_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	if p.call_invalid_rules { // invalid_for_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_for_stmt_var any
		condition := func() bool {
			invalid_for_stmt_var = invalid_for_stmt_rule(p)
			if invalid_for_stmt_var == nil {
				return false
			} // invalid_for_stmt
			return true
		}
		if condition() {
			_res = invalid_for_stmt_var
			goto done
		}
		p.mark = _mark
	}
	{ // 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		_cut_var := 0
		var _keyword *Token
		var _keyword_1 *Token
		var _literal *Token
		var b *asdl_stmt_seq
		var el any
		var ex expr_ty
		var t expr_ty
		var tc any
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 647)
			if _keyword == nil {
				return false
			} // token='for'
			t = star_targets_rule(p)
			if t == nil {
				return false
			} // star_targets
			_keyword_1 = _PyPegen_expect_token(p, 648)
			if _keyword_1 == nil {
				return false
			} // token='in'
			_cut_var = 1
			if _cut_var == nil {
				return false
			}
			ex = star_expressions_rule(p)
			if ex == nil {
				return false
			} // star_expressions
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			tc = _PyPegen_expect_token(p, TYPE_COMMENT)
			if p.error_indicator != 0 {
				return false
			}
			// TYPE_COMMENT?
			b = block_rule(p)
			if b == nil {
				return false
			} // block
			el = else_block_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// else_block?
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_For(t, ex, b, el, NEW_TYPE_COMMENT(p, tc), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
		if _cut_var {
			p.level--
			return nil
		}
	}
	{ // ASYNC 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		_cut_var := 0
		var _keyword *Token
		var _keyword_1 *Token
		var _literal *Token
		var async_var *Token
		var b *asdl_stmt_seq
		var el any
		var ex expr_ty
		var t expr_ty
		var tc any
		condition := func() bool {
			async_var = _PyPegen_expect_token(p, ASYNC)
			if async_var == nil {
				return false
			} // token='ASYNC'
			_keyword = _PyPegen_expect_token(p, 647)
			if _keyword == nil {
				return false
			} // token='for'
			t = star_targets_rule(p)
			if t == nil {
				return false
			} // star_targets
			_keyword_1 = _PyPegen_expect_token(p, 648)
			if _keyword_1 == nil {
				return false
			} // token='in'
			_cut_var = 1
			if _cut_var == nil {
				return false
			}
			ex = star_expressions_rule(p)
			if ex == nil {
				return false
			} // star_expressions
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			tc = _PyPegen_expect_token(p, TYPE_COMMENT)
			if p.error_indicator != 0 {
				return false
			}
			// TYPE_COMMENT?
			b = block_rule(p)
			if b == nil {
				return false
			} // block
			el = else_block_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// else_block?
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = CHECK_VERSION(stmt_ty, 5, "Async for loops are", _PyAST_AsyncFor(t, ex, b, el, NEW_TYPE_COMMENT(p, tc), EXTRA))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
		if _cut_var {
			p.level--
			return nil
		}
	}
	if p.call_invalid_rules { // invalid_for_target
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_for_target_var any
		condition := func() bool {
			invalid_for_target_var = invalid_for_target_rule(p)
			if invalid_for_target_var == nil {
				return false
			} // invalid_for_target
			return true
		}
		if condition() {
			_res = invalid_for_target_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// with_stmt:
//     | invalid_with_stmt_indent
//     | 'with' '(' ','.with_item+ ','? ')' ':' block
//     | 'with' ','.with_item+ ':' TYPE_COMMENT? block
//     | ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block
//     | ASYNC 'with' ','.with_item+ ':' TYPE_COMMENT? block
//     | invalid_with_stmt
func with_stmt_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	if p.call_invalid_rules { // invalid_with_stmt_indent
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_with_stmt_indent_var any
		condition := func() bool {
			invalid_with_stmt_indent_var = invalid_with_stmt_indent_rule(p)
			if invalid_with_stmt_indent_var == nil {
				return false
			} // invalid_with_stmt_indent
			return true
		}
		if condition() {
			_res = invalid_with_stmt_indent_var
			goto done
		}
		p.mark = _mark
	}
	{ // 'with' '(' ','.with_item+ ','? ')' ':' block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var _literal_1 *Token
		var _literal_2 *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a *asdl_withitem_seq
		var b *asdl_stmt_seq
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 612)
			if _keyword == nil {
				return false
			} // token='with'
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			a = *asdl_withitem_seq_gather_51_rule(p)
			if a == nil {
				return false
			} // ','.with_item+
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			_literal_2 = _PyPegen_expect_token(p, 11)
			if _literal_2 == nil {
				return false
			} // token=':'
			b = block_rule(p)
			if b == nil {
				return false
			} // block
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = CHECK_VERSION(stmt_ty, 9, "Parenthesized context managers are", _PyAST_With(a, b, nil, EXTRA))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'with' ','.with_item+ ':' TYPE_COMMENT? block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var a *asdl_withitem_seq
		var b *asdl_stmt_seq
		var tc any
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 612)
			if _keyword == nil {
				return false
			} // token='with'
			a = *asdl_withitem_seq_gather_53_rule(p)
			if a == nil {
				return false
			} // ','.with_item+
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			tc = _PyPegen_expect_token(p, TYPE_COMMENT)
			if p.error_indicator != 0 {
				return false
			}
			// TYPE_COMMENT?
			b = block_rule(p)
			if b == nil {
				return false
			} // block
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_With(a, b, NEW_TYPE_COMMENT(p, tc), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var _literal_1 *Token
		var _literal_2 *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a *asdl_withitem_seq
		var async_var *Token
		var b *asdl_stmt_seq
		condition := func() bool {
			async_var = _PyPegen_expect_token(p, ASYNC)
			if async_var == nil {
				return false
			} // token='ASYNC'
			_keyword = _PyPegen_expect_token(p, 612)
			if _keyword == nil {
				return false
			} // token='with'
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			a = *asdl_withitem_seq_gather_55_rule(p)
			if a == nil {
				return false
			} // ','.with_item+
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			_literal_2 = _PyPegen_expect_token(p, 11)
			if _literal_2 == nil {
				return false
			} // token=':'
			b = block_rule(p)
			if b == nil {
				return false
			} // block
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = CHECK_VERSION(stmt_ty, 5, "Async with statements are", _PyAST_AsyncWith(a, b, nil, EXTRA))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // ASYNC 'with' ','.with_item+ ':' TYPE_COMMENT? block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var a *asdl_withitem_seq
		var async_var *Token
		var b *asdl_stmt_seq
		var tc any
		condition := func() bool {
			async_var = _PyPegen_expect_token(p, ASYNC)
			if async_var == nil {
				return false
			} // token='ASYNC'
			_keyword = _PyPegen_expect_token(p, 612)
			if _keyword == nil {
				return false
			} // token='with'
			a = *asdl_withitem_seq_gather_57_rule(p)
			if a == nil {
				return false
			} // ','.with_item+
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			tc = _PyPegen_expect_token(p, TYPE_COMMENT)
			if p.error_indicator != 0 {
				return false
			}
			// TYPE_COMMENT?
			b = block_rule(p)
			if b == nil {
				return false
			} // block
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = CHECK_VERSION(stmt_ty, 5, "Async with statements are", _PyAST_AsyncWith(a, b, NEW_TYPE_COMMENT(p, tc), EXTRA))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	if p.call_invalid_rules { // invalid_with_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_with_stmt_var any
		condition := func() bool {
			invalid_with_stmt_var = invalid_with_stmt_rule(p)
			if invalid_with_stmt_var == nil {
				return false
			} // invalid_with_stmt
			return true
		}
		if condition() {
			_res = invalid_with_stmt_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// with_item:
//     | expression 'as' star_target &(',' | ')' | ':')
//     | invalid_with_item
//     | expression
func with_item_rule(p *Parser) withitem_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res withitem_ty
	_mark := p.mark
	{ // expression 'as' star_target &(',' | ')' | ':')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var e expr_ty
		var t expr_ty
		condition := func() bool {
			e = expression_rule(p)
			if e == nil {
				return false
			} // expression
			_keyword = _PyPegen_expect_token(p, 637)
			if _keyword == nil {
				return false
			} // token='as'
			t = star_target_rule(p)
			if t == nil {
				return false
			} // star_target
			_tmp := _PyPegen_lookahead(1, _tmp_59_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_res = _PyAST_withitem(e, t, p.arena)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	if p.call_invalid_rules { // invalid_with_item
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_with_item_var any
		condition := func() bool {
			invalid_with_item_var = invalid_with_item_rule(p)
			if invalid_with_item_var == nil {
				return false
			} // invalid_with_item
			return true
		}
		if condition() {
			_res = invalid_with_item_var
			goto done
		}
		p.mark = _mark
	}
	{ // expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var e expr_ty
		condition := func() bool {
			e = expression_rule(p)
			if e == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = _PyAST_withitem(e, nil, p.arena)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// try_stmt:
//     | invalid_try_stmt
//     | 'try' &&':' block finally_block
//     | 'try' &&':' block except_block+ else_block? finally_block?
//     | 'try' &&':' block except_star_block+ else_block? finally_block?
func try_stmt_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	if p.call_invalid_rules { // invalid_try_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_try_stmt_var any
		condition := func() bool {
			invalid_try_stmt_var = invalid_try_stmt_rule(p)
			if invalid_try_stmt_var == nil {
				return false
			} // invalid_try_stmt
			return true
		}
		if condition() {
			_res = invalid_try_stmt_var
			goto done
		}
		p.mark = _mark
	}
	{ // 'try' &&':' block finally_block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var b *asdl_stmt_seq
		var f *asdl_stmt_seq
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 621)
			if _keyword == nil {
				return false
			} // token='try'
			_literal = _PyPegen_expect_forced_token(p, 11, ":")
			if _literal == nil {
				return false
			} // forced_token=':'
			b = block_rule(p)
			if b == nil {
				return false
			} // block
			f = finally_block_rule(p)
			if f == nil {
				return false
			} // finally_block
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Try(b, nil, nil, f, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'try' &&':' block except_block+ else_block? finally_block?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var b *asdl_stmt_seq
		var el any
		var ex *asdl_excepthandler_seq
		var f any
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 621)
			if _keyword == nil {
				return false
			} // token='try'
			_literal = _PyPegen_expect_forced_token(p, 11, ":")
			if _literal == nil {
				return false
			} // forced_token=':'
			b = block_rule(p)
			if b == nil {
				return false
			} // block
			ex = *asdl_excepthandler_seq_loop1_60_rule(p)
			if ex == nil {
				return false
			} // except_block+
			el = else_block_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// else_block?
			f = finally_block_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// finally_block?
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Try(b, ex, el, f, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'try' &&':' block except_star_block+ else_block? finally_block?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var b *asdl_stmt_seq
		var el any
		var ex *asdl_excepthandler_seq
		var f any
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 621)
			if _keyword == nil {
				return false
			} // token='try'
			_literal = _PyPegen_expect_forced_token(p, 11, ":")
			if _literal == nil {
				return false
			} // forced_token=':'
			b = block_rule(p)
			if b == nil {
				return false
			} // block
			ex = *asdl_excepthandler_seq_loop1_61_rule(p)
			if ex == nil {
				return false
			} // except_star_block+
			el = else_block_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// else_block?
			f = finally_block_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// finally_block?
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = CHECK_VERSION(stmt_ty, 11, "Exception groups are", _PyAST_TryStar(b, ex, el, f, EXTRA))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// except_block:
//     | invalid_except_stmt_indent
//     | 'except' expression ['as' NAME] ':' block
//     | 'except' ':' block
//     | invalid_except_stmt
func except_block_rule(p *Parser) excepthandler_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res excepthandler_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	if p.call_invalid_rules { // invalid_except_stmt_indent
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_except_stmt_indent_var any
		condition := func() bool {
			invalid_except_stmt_indent_var = invalid_except_stmt_indent_rule(p)
			if invalid_except_stmt_indent_var == nil {
				return false
			} // invalid_except_stmt_indent
			return true
		}
		if condition() {
			_res = invalid_except_stmt_indent_var
			goto done
		}
		p.mark = _mark
	}
	{ // 'except' expression ['as' NAME] ':' block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var b *asdl_stmt_seq
		var e expr_ty
		var t any
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 634)
			if _keyword == nil {
				return false
			} // token='except'
			e = expression_rule(p)
			if e == nil {
				return false
			} // expression
			t = _tmp_62_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['as' NAME]
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			b = block_rule(p)
			if b == nil {
				return false
			} // block
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_ExceptHandler(e, ternary_operator(t, t.v.Name.id, nil), b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'except' ':' block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var b *asdl_stmt_seq
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 634)
			if _keyword == nil {
				return false
			} // token='except'
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			b = block_rule(p)
			if b == nil {
				return false
			} // block
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_ExceptHandler(nil, nil, b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	if p.call_invalid_rules { // invalid_except_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_except_stmt_var any
		condition := func() bool {
			invalid_except_stmt_var = invalid_except_stmt_rule(p)
			if invalid_except_stmt_var == nil {
				return false
			} // invalid_except_stmt
			return true
		}
		if condition() {
			_res = invalid_except_stmt_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// except_star_block:
//     | invalid_except_star_stmt_indent
//     | 'except' '*' expression ['as' NAME] ':' block
//     | invalid_except_stmt
func except_star_block_rule(p *Parser) excepthandler_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res excepthandler_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	if p.call_invalid_rules { // invalid_except_star_stmt_indent
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_except_star_stmt_indent_var any
		condition := func() bool {
			invalid_except_star_stmt_indent_var = invalid_except_star_stmt_indent_rule(p)
			if invalid_except_star_stmt_indent_var == nil {
				return false
			} // invalid_except_star_stmt_indent
			return true
		}
		if condition() {
			_res = invalid_except_star_stmt_indent_var
			goto done
		}
		p.mark = _mark
	}
	{ // 'except' '*' expression ['as' NAME] ':' block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var _literal_1 *Token
		var b *asdl_stmt_seq
		var e expr_ty
		var t any
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 634)
			if _keyword == nil {
				return false
			} // token='except'
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			e = expression_rule(p)
			if e == nil {
				return false
			} // expression
			t = _tmp_63_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['as' NAME]
			_literal_1 = _PyPegen_expect_token(p, 11)
			if _literal_1 == nil {
				return false
			} // token=':'
			b = block_rule(p)
			if b == nil {
				return false
			} // block
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_ExceptHandler(e, ternary_operator(t, t.v.Name.id, nil), b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	if p.call_invalid_rules { // invalid_except_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_except_stmt_var any
		condition := func() bool {
			invalid_except_stmt_var = invalid_except_stmt_rule(p)
			if invalid_except_stmt_var == nil {
				return false
			} // invalid_except_stmt
			return true
		}
		if condition() {
			_res = invalid_except_stmt_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// finally_block: invalid_finally_stmt | 'finally' &&':' block
func finally_block_rule(p *Parser) *asdl_stmt_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_stmt_seq
	_mark := p.mark
	if p.call_invalid_rules { // invalid_finally_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_finally_stmt_var any
		condition := func() bool {
			invalid_finally_stmt_var = invalid_finally_stmt_rule(p)
			if invalid_finally_stmt_var == nil {
				return false
			} // invalid_finally_stmt
			return true
		}
		if condition() {
			_res = invalid_finally_stmt_var
			goto done
		}
		p.mark = _mark
	}
	{ // 'finally' &&':' block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var a *asdl_stmt_seq
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 630)
			if _keyword == nil {
				return false
			} // token='finally'
			_literal = _PyPegen_expect_forced_token(p, 11, ":")
			if _literal == nil {
				return false
			} // forced_token=':'
			a = block_rule(p)
			if a == nil {
				return false
			} // block
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// match_stmt:
//     | "match" subject_expr ':' NEWLINE INDENT case_block+ DEDENT
//     | invalid_match_stmt
func match_stmt_rule(p *Parser) stmt_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res stmt_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // "match" subject_expr ':' NEWLINE INDENT case_block+ DEDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword expr_ty
		var _literal *Token
		var cases *asdl_match_case_seq
		var dedent_var *Token
		var indent_var *Token
		var newline_var *Token
		var subject expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_soft_keyword(p, "match")
			if _keyword == nil {
				return false
			} // soft_keyword='"match"'
			subject = subject_expr_rule(p)
			if subject == nil {
				return false
			} // subject_expr
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			indent_var = _PyPegen_expect_token(p, INDENT)
			if indent_var == nil {
				return false
			} // token='INDENT'
			cases = *asdl_match_case_seq_loop1_64_rule(p)
			if cases == nil {
				return false
			} // case_block+
			dedent_var = _PyPegen_expect_token(p, DEDENT)
			if dedent_var == nil {
				return false
			} // token='DEDENT'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = CHECK_VERSION(stmt_ty, 10, "Pattern matching is", _PyAST_Match(subject, cases, EXTRA))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	if p.call_invalid_rules { // invalid_match_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_match_stmt_var any
		condition := func() bool {
			invalid_match_stmt_var = invalid_match_stmt_rule(p)
			if invalid_match_stmt_var == nil {
				return false
			} // invalid_match_stmt
			return true
		}
		if condition() {
			_res = invalid_match_stmt_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// subject_expr: star_named_expression ',' star_named_expressions? | named_expression
func subject_expr_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // star_named_expression ',' star_named_expressions?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var value expr_ty
		var values any
		condition := func() bool {
			value = star_named_expression_rule(p)
			if value == nil {
				return false
			} // star_named_expression
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			values = star_named_expressions_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// star_named_expressions?
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Tuple(CHECK(*asdl_expr_seq, _PyPegen_seq_insert_in_front(p, value, values)), Load, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // named_expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var named_expression_var expr_ty
		condition := func() bool {
			named_expression_var = named_expression_rule(p)
			if named_expression_var == nil {
				return false
			} // named_expression
			return true
		}
		if condition() {
			_res = named_expression_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// case_block: invalid_case_block | "case" patterns guard? ':' block
func case_block_rule(p *Parser) match_case_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res match_case_ty
	_mark := p.mark
	if p.call_invalid_rules { // invalid_case_block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_case_block_var any
		condition := func() bool {
			invalid_case_block_var = invalid_case_block_rule(p)
			if invalid_case_block_var == nil {
				return false
			} // invalid_case_block
			return true
		}
		if condition() {
			_res = invalid_case_block_var
			goto done
		}
		p.mark = _mark
	}
	{ // "case" patterns guard? ':' block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword expr_ty
		var _literal *Token
		var body *asdl_stmt_seq
		var guard any
		var pattern pattern_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_soft_keyword(p, "case")
			if _keyword == nil {
				return false
			} // soft_keyword='"case"'
			pattern = patterns_rule(p)
			if pattern == nil {
				return false
			} // patterns
			guard = guard_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// guard?
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			body = block_rule(p)
			if body == nil {
				return false
			} // block
			return true
		}
		if condition() {
			_res = _PyAST_match_case(pattern, guard, body, p.arena)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// guard: 'if' named_expression
func guard_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	{ // 'if' named_expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var guard expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 639)
			if _keyword == nil {
				return false
			} // token='if'
			guard = named_expression_rule(p)
			if guard == nil {
				return false
			} // named_expression
			return true
		}
		if condition() {
			_res = guard
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// patterns: open_sequence_pattern | pattern
func patterns_rule(p *Parser) pattern_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res pattern_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // open_sequence_pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var patterns *asdl_pattern_seq
		condition := func() bool {
			patterns = *asdl_pattern_seqopen_sequence_pattern_rule(p)
			if patterns == nil {
				return false
			} // open_sequence_pattern
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchSequence(patterns, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var pattern_var pattern_ty
		condition := func() bool {
			pattern_var = pattern_rule(p)
			if pattern_var == nil {
				return false
			} // pattern
			return true
		}
		if condition() {
			_res = pattern_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// pattern: as_pattern | or_pattern
func pattern_rule(p *Parser) pattern_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res pattern_ty
	_mark := p.mark
	{ // as_pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var as_pattern_var pattern_ty
		condition := func() bool {
			as_pattern_var = as_pattern_rule(p)
			if as_pattern_var == nil {
				return false
			} // as_pattern
			return true
		}
		if condition() {
			_res = as_pattern_var
			goto done
		}
		p.mark = _mark
	}
	{ // or_pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var or_pattern_var pattern_ty
		condition := func() bool {
			or_pattern_var = or_pattern_rule(p)
			if or_pattern_var == nil {
				return false
			} // or_pattern
			return true
		}
		if condition() {
			_res = or_pattern_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// as_pattern: or_pattern 'as' pattern_capture_target | invalid_as_pattern
func as_pattern_rule(p *Parser) pattern_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res pattern_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // or_pattern 'as' pattern_capture_target
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var pattern pattern_ty
		var target expr_ty
		condition := func() bool {
			pattern = or_pattern_rule(p)
			if pattern == nil {
				return false
			} // or_pattern
			_keyword = _PyPegen_expect_token(p, 637)
			if _keyword == nil {
				return false
			} // token='as'
			target = pattern_capture_target_rule(p)
			if target == nil {
				return false
			} // pattern_capture_target
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchAs(pattern, target.v.Name.id, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	if p.call_invalid_rules { // invalid_as_pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_as_pattern_var any
		condition := func() bool {
			invalid_as_pattern_var = invalid_as_pattern_rule(p)
			if invalid_as_pattern_var == nil {
				return false
			} // invalid_as_pattern
			return true
		}
		if condition() {
			_res = invalid_as_pattern_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// or_pattern: '|'.closed_pattern+
func or_pattern_rule(p *Parser) pattern_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res pattern_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // '|'.closed_pattern+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var patterns *asdl_pattern_seq
		condition := func() bool {
			patterns = *asdl_pattern_seq_gather_65_rule(p)
			if patterns == nil {
				return false
			} // '|'.closed_pattern+
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = ternary_operator(asdl_seq_LEN(patterns) == 1, asdl_seq_GET(patterns, 0), _PyAST_MatchOr(patterns, EXTRA))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// closed_pattern:
//     | literal_pattern
//     | capture_pattern
//     | wildcard_pattern
//     | value_pattern
//     | group_pattern
//     | sequence_pattern
//     | mapping_pattern
//     | class_pattern
func closed_pattern_rule(p *Parser) pattern_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res pattern_ty
	if _PyPegen_is_memoized(p, closed_pattern_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	{ // literal_pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var literal_pattern_var pattern_ty
		condition := func() bool {
			literal_pattern_var = literal_pattern_rule(p)
			if literal_pattern_var == nil {
				return false
			} // literal_pattern
			return true
		}
		if condition() {
			_res = literal_pattern_var
			goto done
		}
		p.mark = _mark
	}
	{ // capture_pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var capture_pattern_var pattern_ty
		condition := func() bool {
			capture_pattern_var = capture_pattern_rule(p)
			if capture_pattern_var == nil {
				return false
			} // capture_pattern
			return true
		}
		if condition() {
			_res = capture_pattern_var
			goto done
		}
		p.mark = _mark
	}
	{ // wildcard_pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var wildcard_pattern_var pattern_ty
		condition := func() bool {
			wildcard_pattern_var = wildcard_pattern_rule(p)
			if wildcard_pattern_var == nil {
				return false
			} // wildcard_pattern
			return true
		}
		if condition() {
			_res = wildcard_pattern_var
			goto done
		}
		p.mark = _mark
	}
	{ // value_pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var value_pattern_var pattern_ty
		condition := func() bool {
			value_pattern_var = value_pattern_rule(p)
			if value_pattern_var == nil {
				return false
			} // value_pattern
			return true
		}
		if condition() {
			_res = value_pattern_var
			goto done
		}
		p.mark = _mark
	}
	{ // group_pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var group_pattern_var pattern_ty
		condition := func() bool {
			group_pattern_var = group_pattern_rule(p)
			if group_pattern_var == nil {
				return false
			} // group_pattern
			return true
		}
		if condition() {
			_res = group_pattern_var
			goto done
		}
		p.mark = _mark
	}
	{ // sequence_pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var sequence_pattern_var pattern_ty
		condition := func() bool {
			sequence_pattern_var = sequence_pattern_rule(p)
			if sequence_pattern_var == nil {
				return false
			} // sequence_pattern
			return true
		}
		if condition() {
			_res = sequence_pattern_var
			goto done
		}
		p.mark = _mark
	}
	{ // mapping_pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var mapping_pattern_var pattern_ty
		condition := func() bool {
			mapping_pattern_var = mapping_pattern_rule(p)
			if mapping_pattern_var == nil {
				return false
			} // mapping_pattern
			return true
		}
		if condition() {
			_res = mapping_pattern_var
			goto done
		}
		p.mark = _mark
	}
	{ // class_pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var class_pattern_var pattern_ty
		condition := func() bool {
			class_pattern_var = class_pattern_rule(p)
			if class_pattern_var == nil {
				return false
			} // class_pattern
			return true
		}
		if condition() {
			_res = class_pattern_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	_PyPegen_insert_memo(p, _mark, closed_pattern_type, _res)
	p.level--
	return _res
}

// literal_pattern:
//     | signed_number !('+' | '-')
//     | complex_number
//     | strings
//     | 'None'
//     | 'True'
//     | 'False'
func literal_pattern_rule(p *Parser) pattern_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res pattern_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // signed_number !('+' | '-')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var value expr_ty
		condition := func() bool {
			value = signed_number_rule(p)
			if value == nil {
				return false
			} // signed_number
			_tmp := _PyPegen_lookahead(0, _tmp_67_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchValue(value, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // complex_number
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var value expr_ty
		condition := func() bool {
			value = complex_number_rule(p)
			if value == nil {
				return false
			} // complex_number
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchValue(value, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // strings
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var value expr_ty
		condition := func() bool {
			value = strings_rule(p)
			if value == nil {
				return false
			} // strings
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchValue(value, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'None'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 601)
			if _keyword == nil {
				return false
			} // token='None'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchSingleton(builtin.PyNone, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'True'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 600)
			if _keyword == nil {
				return false
			} // token='True'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchSingleton(builtin.PyTrue, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'False'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 602)
			if _keyword == nil {
				return false
			} // token='False'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchSingleton(builtin.PyFalse, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// literal_expr:
//     | signed_number !('+' | '-')
//     | complex_number
//     | strings
//     | 'None'
//     | 'True'
//     | 'False'
func literal_expr_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // signed_number !('+' | '-')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var signed_number_var expr_ty
		condition := func() bool {
			signed_number_var = signed_number_rule(p)
			if signed_number_var == nil {
				return false
			} // signed_number
			_tmp := _PyPegen_lookahead(0, _tmp_68_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_res = signed_number_var
			goto done
		}
		p.mark = _mark
	}
	{ // complex_number
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var complex_number_var expr_ty
		condition := func() bool {
			complex_number_var = complex_number_rule(p)
			if complex_number_var == nil {
				return false
			} // complex_number
			return true
		}
		if condition() {
			_res = complex_number_var
			goto done
		}
		p.mark = _mark
	}
	{ // strings
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var strings_var expr_ty
		condition := func() bool {
			strings_var = strings_rule(p)
			if strings_var == nil {
				return false
			} // strings
			return true
		}
		if condition() {
			_res = strings_var
			goto done
		}
		p.mark = _mark
	}
	{ // 'None'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 601)
			if _keyword == nil {
				return false
			} // token='None'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Constant(builtin.PyNone, nil, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'True'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 600)
			if _keyword == nil {
				return false
			} // token='True'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Constant(builtin.PyTrue, nil, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'False'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 602)
			if _keyword == nil {
				return false
			} // token='False'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Constant(builtin.PyFalse, nil, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// complex_number:
//     | signed_real_number '+' imaginary_number
//     | signed_real_number '-' imaginary_number
func complex_number_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // signed_real_number '+' imaginary_number
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var imag expr_ty
		var real expr_ty
		condition := func() bool {
			real = signed_real_number_rule(p)
			if real == nil {
				return false
			} // signed_real_number
			_literal = _PyPegen_expect_token(p, 14)
			if _literal == nil {
				return false
			} // token='+'
			imag = imaginary_number_rule(p)
			if imag == nil {
				return false
			} // imaginary_number
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_BinOp(real, Add, imag, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // signed_real_number '-' imaginary_number
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var imag expr_ty
		var real expr_ty
		condition := func() bool {
			real = signed_real_number_rule(p)
			if real == nil {
				return false
			} // signed_real_number
			_literal = _PyPegen_expect_token(p, 15)
			if _literal == nil {
				return false
			} // token='-'
			imag = imaginary_number_rule(p)
			if imag == nil {
				return false
			} // imaginary_number
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_BinOp(real, Sub, imag, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// signed_number: NUMBER | '-' NUMBER
func signed_number_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // NUMBER
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var number_var expr_ty
		condition := func() bool {
			number_var = _PyPegen_number_token(p)
			if number_var == nil {
				return false
			} // NUMBER
			return true
		}
		if condition() {
			_res = number_var
			goto done
		}
		p.mark = _mark
	}
	{ // '-' NUMBER
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var number expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 15)
			if _literal == nil {
				return false
			} // token='-'
			number = _PyPegen_number_token(p)
			if number == nil {
				return false
			} // NUMBER
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_UnaryOp(USub, number, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// signed_real_number: real_number | '-' real_number
func signed_real_number_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // real_number
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var real_number_var expr_ty
		condition := func() bool {
			real_number_var = real_number_rule(p)
			if real_number_var == nil {
				return false
			} // real_number
			return true
		}
		if condition() {
			_res = real_number_var
			goto done
		}
		p.mark = _mark
	}
	{ // '-' real_number
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var real expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 15)
			if _literal == nil {
				return false
			} // token='-'
			real = real_number_rule(p)
			if real == nil {
				return false
			} // real_number
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_UnaryOp(USub, real, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// real_number: NUMBER
func real_number_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	{ // NUMBER
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var real expr_ty
		condition := func() bool {
			real = _PyPegen_number_token(p)
			if real == nil {
				return false
			} // NUMBER
			return true
		}
		if condition() {
			_res = _PyPegen_ensure_real(p, real)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// imaginary_number: NUMBER
func imaginary_number_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	{ // NUMBER
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var imag expr_ty
		condition := func() bool {
			imag = _PyPegen_number_token(p)
			if imag == nil {
				return false
			} // NUMBER
			return true
		}
		if condition() {
			_res = _PyPegen_ensure_imaginary(p, imag)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// capture_pattern: pattern_capture_target
func capture_pattern_rule(p *Parser) pattern_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res pattern_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // pattern_capture_target
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var target expr_ty
		condition := func() bool {
			target = pattern_capture_target_rule(p)
			if target == nil {
				return false
			} // pattern_capture_target
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchAs(nil, target.v.Name.id, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// pattern_capture_target: !"_" NAME !('.' | '(' | '=')
func pattern_capture_target_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	{ // !"_" NAME !('.' | '(' | '=')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var name expr_ty
		condition := func() bool {
			_tmp := _PyPegen_lookahead_with_string(0, _PyPegen_expect_soft_keyword, p, "_")
			if _tmp == 0 {
				return false
			}
			name = _PyPegen_name_token(p)
			if name == nil {
				return false
			} // NAME
			_tmp := _PyPegen_lookahead(0, _tmp_69_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_res = _PyPegen_set_expr_context(p, name, Store)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// wildcard_pattern: "_"
func wildcard_pattern_rule(p *Parser) pattern_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res pattern_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // "_"
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_soft_keyword(p, "_")
			if _keyword == nil {
				return false
			} // soft_keyword='"_"'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchAs(nil, nil, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// value_pattern: attr !('.' | '(' | '=')
func value_pattern_rule(p *Parser) pattern_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res pattern_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // attr !('.' | '(' | '=')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var attr expr_ty
		condition := func() bool {
			attr = attr_rule(p)
			if attr == nil {
				return false
			} // attr
			_tmp := _PyPegen_lookahead(0, _tmp_70_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchValue(attr, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// Left-recursive
// attr: name_or_attr '.' NAME
func attr_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	var expr_ty _res
	if _PyPegen_is_memoized(p, attr_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	_resmark := p.mark
	for {
		tmpvar_1 := _PyPegen_update_memo(p, _mark, attr_type, _res)
		if tmpvar_1 {
			p.level--
			return _res
		}
		p.mark = _mark
		_raw := attr_raw(p)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		if _raw == nil || p.mark <= _resmark {
			break
		}
		_resmark = p.mark
		_res = _raw
	}
	p.mark = _resmark
	p.level--
	return _res
}
func attr_raw(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // name_or_attr '.' NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var attr expr_ty
		var value expr_ty
		condition := func() bool {
			value = name_or_attr_rule(p)
			if value == nil {
				return false
			} // name_or_attr
			_literal = _PyPegen_expect_token(p, 23)
			if _literal == nil {
				return false
			} // token='.'
			attr = _PyPegen_name_token(p)
			if attr == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Attribute(value, attr.v.Name.id, Load, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// Left-recursive
// name_or_attr: attr | NAME
func name_or_attr_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	{ // attr
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var attr_var expr_ty
		condition := func() bool {
			attr_var = attr_rule(p)
			if attr_var == nil {
				return false
			} // attr
			return true
		}
		if condition() {
			_res = attr_var
			goto done
		}
		p.mark = _mark
	}
	{ // NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var name_var expr_ty
		condition := func() bool {
			name_var = _PyPegen_name_token(p)
			if name_var == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_res = name_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// group_pattern: '(' pattern ')'
func group_pattern_rule(p *Parser) pattern_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res pattern_ty
	_mark := p.mark
	{ // '(' pattern ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var pattern pattern_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			pattern = pattern_rule(p)
			if pattern == nil {
				return false
			} // pattern
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = pattern
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// sequence_pattern: '[' maybe_sequence_pattern? ']' | '(' open_sequence_pattern? ')'
func sequence_pattern_rule(p *Parser) pattern_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res pattern_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // '[' maybe_sequence_pattern? ']'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var patterns any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 9)
			if _literal == nil {
				return false
			} // token='['
			patterns = maybe_sequence_pattern_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// maybe_sequence_pattern?
			_literal_1 = _PyPegen_expect_token(p, 10)
			if _literal_1 == nil {
				return false
			} // token=']'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchSequence(patterns, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '(' open_sequence_pattern? ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var patterns any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			patterns = open_sequence_pattern_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// open_sequence_pattern?
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchSequence(patterns, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// open_sequence_pattern: maybe_star_pattern ',' maybe_sequence_pattern?
func open_sequence_pattern_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // maybe_star_pattern ',' maybe_sequence_pattern?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var pattern pattern_ty
		var patterns any
		condition := func() bool {
			pattern = maybe_star_pattern_rule(p)
			if pattern == nil {
				return false
			} // maybe_star_pattern
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			patterns = maybe_sequence_pattern_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// maybe_sequence_pattern?
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, pattern, patterns)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// maybe_sequence_pattern: ','.maybe_star_pattern+ ','?
func maybe_sequence_pattern_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // ','.maybe_star_pattern+ ','?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var patterns *asdl_seq
		condition := func() bool {
			patterns = _gather_71_rule(p)
			if patterns == nil {
				return false
			} // ','.maybe_star_pattern+
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			return true
		}
		if condition() {
			_res = patterns
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// maybe_star_pattern: star_pattern | pattern
func maybe_star_pattern_rule(p *Parser) pattern_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res pattern_ty
	_mark := p.mark
	{ // star_pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var star_pattern_var pattern_ty
		condition := func() bool {
			star_pattern_var = star_pattern_rule(p)
			if star_pattern_var == nil {
				return false
			} // star_pattern
			return true
		}
		if condition() {
			_res = star_pattern_var
			goto done
		}
		p.mark = _mark
	}
	{ // pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var pattern_var pattern_ty
		condition := func() bool {
			pattern_var = pattern_rule(p)
			if pattern_var == nil {
				return false
			} // pattern
			return true
		}
		if condition() {
			_res = pattern_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// star_pattern: '*' pattern_capture_target | '*' wildcard_pattern
func star_pattern_rule(p *Parser) pattern_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res pattern_ty
	if _PyPegen_is_memoized(p, star_pattern_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // '*' pattern_capture_target
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var target expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			target = pattern_capture_target_rule(p)
			if target == nil {
				return false
			} // pattern_capture_target
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchStar(target.v.Name.id, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '*' wildcard_pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var wildcard_pattern_var pattern_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			wildcard_pattern_var = wildcard_pattern_rule(p)
			if wildcard_pattern_var == nil {
				return false
			} // wildcard_pattern
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchStar(nil, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	_PyPegen_insert_memo(p, _mark, star_pattern_type, _res)
	p.level--
	return _res
}

// mapping_pattern:
//     | '{' '}'
//     | '{' double_star_pattern ','? '}'
//     | '{' items_pattern ',' double_star_pattern ','? '}'
//     | '{' items_pattern ','? '}'
func mapping_pattern_rule(p *Parser) pattern_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res pattern_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // '{' '}'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 25)
			if _literal == nil {
				return false
			} // token='{'
			_literal_1 = _PyPegen_expect_token(p, 26)
			if _literal_1 == nil {
				return false
			} // token='}'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchMapping(nil, nil, nil, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '{' double_star_pattern ','? '}'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var rest expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 25)
			if _literal == nil {
				return false
			} // token='{'
			rest = double_star_pattern_rule(p)
			if rest == nil {
				return false
			} // double_star_pattern
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			_literal_1 = _PyPegen_expect_token(p, 26)
			if _literal_1 == nil {
				return false
			} // token='}'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchMapping(nil, nil, rest.v.Name.id, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '{' items_pattern ',' double_star_pattern ','? '}'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var _literal_2 *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var items *asdl_seq
		var rest expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 25)
			if _literal == nil {
				return false
			} // token='{'
			items = items_pattern_rule(p)
			if items == nil {
				return false
			} // items_pattern
			_literal_1 = _PyPegen_expect_token(p, 12)
			if _literal_1 == nil {
				return false
			} // token=','
			rest = double_star_pattern_rule(p)
			if rest == nil {
				return false
			} // double_star_pattern
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			_literal_2 = _PyPegen_expect_token(p, 26)
			if _literal_2 == nil {
				return false
			} // token='}'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchMapping(CHECK(*asdl_expr_seq, _PyPegen_get_pattern_keys(p, items)), CHECK(*asdl_pattern_seq, _PyPegen_get_patterns(p, items)), rest.v.Name.id, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '{' items_pattern ','? '}'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var items *asdl_seq
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 25)
			if _literal == nil {
				return false
			} // token='{'
			items = items_pattern_rule(p)
			if items == nil {
				return false
			} // items_pattern
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			_literal_1 = _PyPegen_expect_token(p, 26)
			if _literal_1 == nil {
				return false
			} // token='}'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchMapping(CHECK(*asdl_expr_seq, _PyPegen_get_pattern_keys(p, items)), CHECK(*asdl_pattern_seq, _PyPegen_get_patterns(p, items)), nil, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// items_pattern: ','.key_value_pattern+
func items_pattern_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // ','.key_value_pattern+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _gather_73_var *asdl_seq
		condition := func() bool {
			_gather_73_var = _gather_73_rule(p)
			if _gather_73_var == nil {
				return false
			} // ','.key_value_pattern+
			return true
		}
		if condition() {
			_res = _gather_73_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// key_value_pattern: (literal_expr | attr) ':' pattern
func key_value_pattern_rule(p *Parser) *KeyPatternPair {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *KeyPatternPair
	_mark := p.mark
	{ // (literal_expr | attr) ':' pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var key any
		var pattern pattern_ty
		condition := func() bool {
			key = _tmp_75_rule(p)
			if key == nil {
				return false
			} // literal_expr | attr
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			pattern = pattern_rule(p)
			if pattern == nil {
				return false
			} // pattern
			return true
		}
		if condition() {
			_res = _PyPegen_key_pattern_pair(p, key, pattern)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// double_star_pattern: '**' pattern_capture_target
func double_star_pattern_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	{ // '**' pattern_capture_target
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var target expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 35)
			if _literal == nil {
				return false
			} // token='**'
			target = pattern_capture_target_rule(p)
			if target == nil {
				return false
			} // pattern_capture_target
			return true
		}
		if condition() {
			_res = target
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// class_pattern:
//     | name_or_attr '(' ')'
//     | name_or_attr '(' positional_patterns ','? ')'
//     | name_or_attr '(' keyword_patterns ','? ')'
//     | name_or_attr '(' positional_patterns ',' keyword_patterns ','? ')'
//     | invalid_class_pattern
func class_pattern_rule(p *Parser) pattern_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res pattern_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // name_or_attr '(' ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var cls expr_ty
		condition := func() bool {
			cls = name_or_attr_rule(p)
			if cls == nil {
				return false
			} // name_or_attr
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchClass(cls, nil, nil, nil, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // name_or_attr '(' positional_patterns ','? ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var cls expr_ty
		var patterns *asdl_pattern_seq
		condition := func() bool {
			cls = name_or_attr_rule(p)
			if cls == nil {
				return false
			} // name_or_attr
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			patterns = positional_patterns_rule(p)
			if patterns == nil {
				return false
			} // positional_patterns
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchClass(cls, patterns, nil, nil, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // name_or_attr '(' keyword_patterns ','? ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var cls expr_ty
		var keywords *asdl_seq
		condition := func() bool {
			cls = name_or_attr_rule(p)
			if cls == nil {
				return false
			} // name_or_attr
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			keywords = keyword_patterns_rule(p)
			if keywords == nil {
				return false
			} // keyword_patterns
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchClass(cls, nil, CHECK(*asdl_identifier_seq, _PyPegen_map_names_to_ids(p, CHECK(*asdl_expr_seq, _PyPegen_get_pattern_keys(p, keywords)))), CHECK(*asdl_pattern_seq, _PyPegen_get_patterns(p, keywords)), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // name_or_attr '(' positional_patterns ',' keyword_patterns ','? ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var _literal_2 *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var cls expr_ty
		var keywords *asdl_seq
		var patterns *asdl_pattern_seq
		condition := func() bool {
			cls = name_or_attr_rule(p)
			if cls == nil {
				return false
			} // name_or_attr
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			patterns = positional_patterns_rule(p)
			if patterns == nil {
				return false
			} // positional_patterns
			_literal_1 = _PyPegen_expect_token(p, 12)
			if _literal_1 == nil {
				return false
			} // token=','
			keywords = keyword_patterns_rule(p)
			if keywords == nil {
				return false
			} // keyword_patterns
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			_literal_2 = _PyPegen_expect_token(p, 8)
			if _literal_2 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_MatchClass(cls, patterns, CHECK(*asdl_identifier_seq, _PyPegen_map_names_to_ids(p, CHECK(*asdl_expr_seq, _PyPegen_get_pattern_keys(p, keywords)))), CHECK(*asdl_pattern_seq, _PyPegen_get_patterns(p, keywords)), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	if p.call_invalid_rules { // invalid_class_pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_class_pattern_var any
		condition := func() bool {
			invalid_class_pattern_var = invalid_class_pattern_rule(p)
			if invalid_class_pattern_var == nil {
				return false
			} // invalid_class_pattern
			return true
		}
		if condition() {
			_res = invalid_class_pattern_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// positional_patterns: ','.pattern+
func positional_patterns_rule(p *Parser) *asdl_pattern_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_pattern_seq
	_mark := p.mark
	{ // ','.pattern+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var args *asdl_pattern_seq
		condition := func() bool {
			args = *asdl_pattern_seq_gather_76_rule(p)
			if args == nil {
				return false
			} // ','.pattern+
			return true
		}
		if condition() {
			_res = args
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// keyword_patterns: ','.keyword_pattern+
func keyword_patterns_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // ','.keyword_pattern+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _gather_78_var *asdl_seq
		condition := func() bool {
			_gather_78_var = _gather_78_rule(p)
			if _gather_78_var == nil {
				return false
			} // ','.keyword_pattern+
			return true
		}
		if condition() {
			_res = _gather_78_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// keyword_pattern: NAME '=' pattern
func keyword_pattern_rule(p *Parser) *KeyPatternPair {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *KeyPatternPair
	_mark := p.mark
	{ // NAME '=' pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var arg expr_ty
		var value pattern_ty
		condition := func() bool {
			arg = _PyPegen_name_token(p)
			if arg == nil {
				return false
			} // NAME
			_literal = _PyPegen_expect_token(p, 22)
			if _literal == nil {
				return false
			} // token='='
			value = pattern_rule(p)
			if value == nil {
				return false
			} // pattern
			return true
		}
		if condition() {
			_res = _PyPegen_key_pattern_pair(p, arg, value)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// expressions: expression ((',' expression))+ ','? | expression ',' | expression
func expressions_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // expression ((',' expression))+ ','?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a expr_ty
		var b *asdl_seq
		condition := func() bool {
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			b = _loop1_80_rule(p)
			if b == nil {
				return false
			} // ((',' expression))+
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Tuple(CHECK(*asdl_expr_seq, _PyPegen_seq_insert_in_front(p, a, b)), Load, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // expression ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Tuple(CHECK(*asdl_expr_seq, _PyPegen_singleton_seq(p, a)), Load, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var expression_var expr_ty
		condition := func() bool {
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = expression_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// expression:
//     | invalid_expression
//     | invalid_legacy_expression
//     | disjunction 'if' disjunction 'else' expression
//     | disjunction
//     | lambdef
func expression_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	if _PyPegen_is_memoized(p, expression_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	if p.call_invalid_rules { // invalid_expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_expression_var any
		condition := func() bool {
			invalid_expression_var = invalid_expression_rule(p)
			if invalid_expression_var == nil {
				return false
			} // invalid_expression
			return true
		}
		if condition() {
			_res = invalid_expression_var
			goto done
		}
		p.mark = _mark
	}
	if p.call_invalid_rules { // invalid_legacy_expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_legacy_expression_var any
		condition := func() bool {
			invalid_legacy_expression_var = invalid_legacy_expression_rule(p)
			if invalid_legacy_expression_var == nil {
				return false
			} // invalid_legacy_expression
			return true
		}
		if condition() {
			_res = invalid_legacy_expression_var
			goto done
		}
		p.mark = _mark
	}
	{ // disjunction 'if' disjunction 'else' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _keyword_1 *Token
		var a expr_ty
		var b expr_ty
		var c expr_ty
		condition := func() bool {
			a = disjunction_rule(p)
			if a == nil {
				return false
			} // disjunction
			_keyword = _PyPegen_expect_token(p, 639)
			if _keyword == nil {
				return false
			} // token='if'
			b = disjunction_rule(p)
			if b == nil {
				return false
			} // disjunction
			_keyword_1 = _PyPegen_expect_token(p, 642)
			if _keyword_1 == nil {
				return false
			} // token='else'
			c = expression_rule(p)
			if c == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_IfExp(b, a, c, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // disjunction
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var disjunction_var expr_ty
		condition := func() bool {
			disjunction_var = disjunction_rule(p)
			if disjunction_var == nil {
				return false
			} // disjunction
			return true
		}
		if condition() {
			_res = disjunction_var
			goto done
		}
		p.mark = _mark
	}
	{ // lambdef
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambdef_var expr_ty
		condition := func() bool {
			lambdef_var = lambdef_rule(p)
			if lambdef_var == nil {
				return false
			} // lambdef
			return true
		}
		if condition() {
			_res = lambdef_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	_PyPegen_insert_memo(p, _mark, expression_type, _res)
	p.level--
	return _res
}

// yield_expr: 'yield' 'from' expression | 'yield' star_expressions?
func yield_expr_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // 'yield' 'from' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _keyword_1 *Token
		var a expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 573)
			if _keyword == nil {
				return false
			} // token='yield'
			_keyword_1 = _PyPegen_expect_token(p, 572)
			if _keyword_1 == nil {
				return false
			} // token='from'
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_YieldFrom(a, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'yield' star_expressions?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var a any
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 573)
			if _keyword == nil {
				return false
			} // token='yield'
			a = star_expressions_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// star_expressions?
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Yield(a, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// star_expressions:
//     | star_expression ((',' star_expression))+ ','?
//     | star_expression ','
//     | star_expression
func star_expressions_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // star_expression ((',' star_expression))+ ','?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a expr_ty
		var b *asdl_seq
		condition := func() bool {
			a = star_expression_rule(p)
			if a == nil {
				return false
			} // star_expression
			b = _loop1_81_rule(p)
			if b == nil {
				return false
			} // ((',' star_expression))+
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Tuple(CHECK(*asdl_expr_seq, _PyPegen_seq_insert_in_front(p, a, b)), Load, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // star_expression ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			a = star_expression_rule(p)
			if a == nil {
				return false
			} // star_expression
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Tuple(CHECK(*asdl_expr_seq, _PyPegen_singleton_seq(p, a)), Load, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // star_expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var star_expression_var expr_ty
		condition := func() bool {
			star_expression_var = star_expression_rule(p)
			if star_expression_var == nil {
				return false
			} // star_expression
			return true
		}
		if condition() {
			_res = star_expression_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// star_expression: '*' bitwise_or | expression
func star_expression_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	if _PyPegen_is_memoized(p, star_expression_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // '*' bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			a = bitwise_or_rule(p)
			if a == nil {
				return false
			} // bitwise_or
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Starred(a, Load, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var expression_var expr_ty
		condition := func() bool {
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = expression_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	_PyPegen_insert_memo(p, _mark, star_expression_type, _res)
	p.level--
	return _res
}

// star_named_expressions: ','.star_named_expression+ ','?
func star_named_expressions_rule(p *Parser) *asdl_expr_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_expr_seq
	_mark := p.mark
	{ // ','.star_named_expression+ ','?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a *asdl_expr_seq
		condition := func() bool {
			a = *asdl_expr_seq_gather_82_rule(p)
			if a == nil {
				return false
			} // ','.star_named_expression+
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// star_named_expression: '*' bitwise_or | named_expression
func star_named_expression_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // '*' bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			a = bitwise_or_rule(p)
			if a == nil {
				return false
			} // bitwise_or
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Starred(a, Load, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // named_expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var named_expression_var expr_ty
		condition := func() bool {
			named_expression_var = named_expression_rule(p)
			if named_expression_var == nil {
				return false
			} // named_expression
			return true
		}
		if condition() {
			_res = named_expression_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// assignment_expression: NAME ':=' ~ expression
func assignment_expression_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // NAME ':=' ~ expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		_cut_var := 0
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = _PyPegen_name_token(p)
			if a == nil {
				return false
			} // NAME
			_literal = _PyPegen_expect_token(p, 53)
			if _literal == nil {
				return false
			} // token=':='
			_cut_var = 1
			if _cut_var == nil {
				return false
			}
			b = expression_rule(p)
			if b == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = CHECK_VERSION(expr_ty, 8, "Assignment expressions are", _PyAST_NamedExpr(CHECK(expr_ty, _PyPegen_set_expr_context(p, a, Store)), b, EXTRA))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
		if _cut_var {
			p.level--
			return nil
		}
	}
	_res = nil
done:
	p.level--
	return _res
}

// named_expression: assignment_expression | invalid_named_expression | expression !':='
func named_expression_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	{ // assignment_expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var assignment_expression_var expr_ty
		condition := func() bool {
			assignment_expression_var = assignment_expression_rule(p)
			if assignment_expression_var == nil {
				return false
			} // assignment_expression
			return true
		}
		if condition() {
			_res = assignment_expression_var
			goto done
		}
		p.mark = _mark
	}
	if p.call_invalid_rules { // invalid_named_expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_named_expression_var any
		condition := func() bool {
			invalid_named_expression_var = invalid_named_expression_rule(p)
			if invalid_named_expression_var == nil {
				return false
			} // invalid_named_expression
			return true
		}
		if condition() {
			_res = invalid_named_expression_var
			goto done
		}
		p.mark = _mark
	}
	{ // expression !':='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var expression_var expr_ty
		condition := func() bool {
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 53)
			if _tmp == 0 {
				return false
			} // token=':='
			return true
		}
		if condition() {
			_res = expression_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// disjunction: conjunction (('or' conjunction))+ | conjunction
func disjunction_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	if _PyPegen_is_memoized(p, disjunction_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // conjunction (('or' conjunction))+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		var b *asdl_seq
		condition := func() bool {
			a = conjunction_rule(p)
			if a == nil {
				return false
			} // conjunction
			b = _loop1_84_rule(p)
			if b == nil {
				return false
			} // (('or' conjunction))+
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_BoolOp(Or, CHECK(*asdl_expr_seq, _PyPegen_seq_insert_in_front(p, a, b)), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // conjunction
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var conjunction_var expr_ty
		condition := func() bool {
			conjunction_var = conjunction_rule(p)
			if conjunction_var == nil {
				return false
			} // conjunction
			return true
		}
		if condition() {
			_res = conjunction_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	_PyPegen_insert_memo(p, _mark, disjunction_type, _res)
	p.level--
	return _res
}

// conjunction: inversion (('and' inversion))+ | inversion
func conjunction_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	if _PyPegen_is_memoized(p, conjunction_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // inversion (('and' inversion))+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		var b *asdl_seq
		condition := func() bool {
			a = inversion_rule(p)
			if a == nil {
				return false
			} // inversion
			b = _loop1_85_rule(p)
			if b == nil {
				return false
			} // (('and' inversion))+
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_BoolOp(And, CHECK(*asdl_expr_seq, _PyPegen_seq_insert_in_front(p, a, b)), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // inversion
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var inversion_var expr_ty
		condition := func() bool {
			inversion_var = inversion_rule(p)
			if inversion_var == nil {
				return false
			} // inversion
			return true
		}
		if condition() {
			_res = inversion_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	_PyPegen_insert_memo(p, _mark, conjunction_type, _res)
	p.level--
	return _res
}

// inversion: 'not' inversion | comparison
func inversion_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	if _PyPegen_is_memoized(p, inversion_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // 'not' inversion
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var a expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 581)
			if _keyword == nil {
				return false
			} // token='not'
			a = inversion_rule(p)
			if a == nil {
				return false
			} // inversion
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_UnaryOp(Not, a, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // comparison
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var comparison_var expr_ty
		condition := func() bool {
			comparison_var = comparison_rule(p)
			if comparison_var == nil {
				return false
			} // comparison
			return true
		}
		if condition() {
			_res = comparison_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	_PyPegen_insert_memo(p, _mark, inversion_type, _res)
	p.level--
	return _res
}

// comparison: bitwise_or compare_op_bitwise_or_pair+ | bitwise_or
func comparison_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // bitwise_or compare_op_bitwise_or_pair+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		var b *asdl_seq
		condition := func() bool {
			a = bitwise_or_rule(p)
			if a == nil {
				return false
			} // bitwise_or
			b = _loop1_86_rule(p)
			if b == nil {
				return false
			} // compare_op_bitwise_or_pair+
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Compare(a, CHECK(*asdl_int_seq, _PyPegen_get_cmpops(p, b)), CHECK(*asdl_expr_seq, _PyPegen_get_exprs(p, b)), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var bitwise_or_var expr_ty
		condition := func() bool {
			bitwise_or_var = bitwise_or_rule(p)
			if bitwise_or_var == nil {
				return false
			} // bitwise_or
			return true
		}
		if condition() {
			_res = bitwise_or_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// compare_op_bitwise_or_pair:
//     | eq_bitwise_or
//     | noteq_bitwise_or
//     | lte_bitwise_or
//     | lt_bitwise_or
//     | gte_bitwise_or
//     | gt_bitwise_or
//     | notin_bitwise_or
//     | in_bitwise_or
//     | isnot_bitwise_or
//     | is_bitwise_or
func compare_op_bitwise_or_pair_rule(p *Parser) *CmpopExprPair {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *CmpopExprPair
	_mark := p.mark
	{ // eq_bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var eq_bitwise_or_var *CmpopExprPair
		condition := func() bool {
			eq_bitwise_or_var = eq_bitwise_or_rule(p)
			if eq_bitwise_or_var == nil {
				return false
			} // eq_bitwise_or
			return true
		}
		if condition() {
			_res = eq_bitwise_or_var
			goto done
		}
		p.mark = _mark
	}
	{ // noteq_bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var noteq_bitwise_or_var *CmpopExprPair
		condition := func() bool {
			noteq_bitwise_or_var = noteq_bitwise_or_rule(p)
			if noteq_bitwise_or_var == nil {
				return false
			} // noteq_bitwise_or
			return true
		}
		if condition() {
			_res = noteq_bitwise_or_var
			goto done
		}
		p.mark = _mark
	}
	{ // lte_bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lte_bitwise_or_var *CmpopExprPair
		condition := func() bool {
			lte_bitwise_or_var = lte_bitwise_or_rule(p)
			if lte_bitwise_or_var == nil {
				return false
			} // lte_bitwise_or
			return true
		}
		if condition() {
			_res = lte_bitwise_or_var
			goto done
		}
		p.mark = _mark
	}
	{ // lt_bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lt_bitwise_or_var *CmpopExprPair
		condition := func() bool {
			lt_bitwise_or_var = lt_bitwise_or_rule(p)
			if lt_bitwise_or_var == nil {
				return false
			} // lt_bitwise_or
			return true
		}
		if condition() {
			_res = lt_bitwise_or_var
			goto done
		}
		p.mark = _mark
	}
	{ // gte_bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var gte_bitwise_or_var *CmpopExprPair
		condition := func() bool {
			gte_bitwise_or_var = gte_bitwise_or_rule(p)
			if gte_bitwise_or_var == nil {
				return false
			} // gte_bitwise_or
			return true
		}
		if condition() {
			_res = gte_bitwise_or_var
			goto done
		}
		p.mark = _mark
	}
	{ // gt_bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var gt_bitwise_or_var *CmpopExprPair
		condition := func() bool {
			gt_bitwise_or_var = gt_bitwise_or_rule(p)
			if gt_bitwise_or_var == nil {
				return false
			} // gt_bitwise_or
			return true
		}
		if condition() {
			_res = gt_bitwise_or_var
			goto done
		}
		p.mark = _mark
	}
	{ // notin_bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var notin_bitwise_or_var *CmpopExprPair
		condition := func() bool {
			notin_bitwise_or_var = notin_bitwise_or_rule(p)
			if notin_bitwise_or_var == nil {
				return false
			} // notin_bitwise_or
			return true
		}
		if condition() {
			_res = notin_bitwise_or_var
			goto done
		}
		p.mark = _mark
	}
	{ // in_bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var in_bitwise_or_var *CmpopExprPair
		condition := func() bool {
			in_bitwise_or_var = in_bitwise_or_rule(p)
			if in_bitwise_or_var == nil {
				return false
			} // in_bitwise_or
			return true
		}
		if condition() {
			_res = in_bitwise_or_var
			goto done
		}
		p.mark = _mark
	}
	{ // isnot_bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var isnot_bitwise_or_var *CmpopExprPair
		condition := func() bool {
			isnot_bitwise_or_var = isnot_bitwise_or_rule(p)
			if isnot_bitwise_or_var == nil {
				return false
			} // isnot_bitwise_or
			return true
		}
		if condition() {
			_res = isnot_bitwise_or_var
			goto done
		}
		p.mark = _mark
	}
	{ // is_bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var is_bitwise_or_var *CmpopExprPair
		condition := func() bool {
			is_bitwise_or_var = is_bitwise_or_rule(p)
			if is_bitwise_or_var == nil {
				return false
			} // is_bitwise_or
			return true
		}
		if condition() {
			_res = is_bitwise_or_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// eq_bitwise_or: '==' bitwise_or
func eq_bitwise_or_rule(p *Parser) *CmpopExprPair {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *CmpopExprPair
	_mark := p.mark
	{ // '==' bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 27)
			if _literal == nil {
				return false
			} // token='=='
			a = bitwise_or_rule(p)
			if a == nil {
				return false
			} // bitwise_or
			return true
		}
		if condition() {
			_res = _PyPegen_cmpop_expr_pair(p, Eq, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// noteq_bitwise_or: ('!=') bitwise_or
func noteq_bitwise_or_rule(p *Parser) *CmpopExprPair {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *CmpopExprPair
	_mark := p.mark
	{ // ('!=') bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_87_var any
		var a expr_ty
		condition := func() bool {
			_tmp_87_var = _tmp_87_rule(p)
			if _tmp_87_var == nil {
				return false
			} // '!='
			a = bitwise_or_rule(p)
			if a == nil {
				return false
			} // bitwise_or
			return true
		}
		if condition() {
			_res = _PyPegen_cmpop_expr_pair(p, NotEq, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// lte_bitwise_or: '<=' bitwise_or
func lte_bitwise_or_rule(p *Parser) *CmpopExprPair {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *CmpopExprPair
	_mark := p.mark
	{ // '<=' bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 29)
			if _literal == nil {
				return false
			} // token='<='
			a = bitwise_or_rule(p)
			if a == nil {
				return false
			} // bitwise_or
			return true
		}
		if condition() {
			_res = _PyPegen_cmpop_expr_pair(p, LtE, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// lt_bitwise_or: '<' bitwise_or
func lt_bitwise_or_rule(p *Parser) *CmpopExprPair {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *CmpopExprPair
	_mark := p.mark
	{ // '<' bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 20)
			if _literal == nil {
				return false
			} // token='<'
			a = bitwise_or_rule(p)
			if a == nil {
				return false
			} // bitwise_or
			return true
		}
		if condition() {
			_res = _PyPegen_cmpop_expr_pair(p, Lt, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// gte_bitwise_or: '>=' bitwise_or
func gte_bitwise_or_rule(p *Parser) *CmpopExprPair {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *CmpopExprPair
	_mark := p.mark
	{ // '>=' bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 30)
			if _literal == nil {
				return false
			} // token='>='
			a = bitwise_or_rule(p)
			if a == nil {
				return false
			} // bitwise_or
			return true
		}
		if condition() {
			_res = _PyPegen_cmpop_expr_pair(p, GtE, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// gt_bitwise_or: '>' bitwise_or
func gt_bitwise_or_rule(p *Parser) *CmpopExprPair {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *CmpopExprPair
	_mark := p.mark
	{ // '>' bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 21)
			if _literal == nil {
				return false
			} // token='>'
			a = bitwise_or_rule(p)
			if a == nil {
				return false
			} // bitwise_or
			return true
		}
		if condition() {
			_res = _PyPegen_cmpop_expr_pair(p, Gt, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// notin_bitwise_or: 'not' 'in' bitwise_or
func notin_bitwise_or_rule(p *Parser) *CmpopExprPair {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *CmpopExprPair
	_mark := p.mark
	{ // 'not' 'in' bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _keyword_1 *Token
		var a expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 581)
			if _keyword == nil {
				return false
			} // token='not'
			_keyword_1 = _PyPegen_expect_token(p, 648)
			if _keyword_1 == nil {
				return false
			} // token='in'
			a = bitwise_or_rule(p)
			if a == nil {
				return false
			} // bitwise_or
			return true
		}
		if condition() {
			_res = _PyPegen_cmpop_expr_pair(p, NotIn, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// in_bitwise_or: 'in' bitwise_or
func in_bitwise_or_rule(p *Parser) *CmpopExprPair {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *CmpopExprPair
	_mark := p.mark
	{ // 'in' bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var a expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 648)
			if _keyword == nil {
				return false
			} // token='in'
			a = bitwise_or_rule(p)
			if a == nil {
				return false
			} // bitwise_or
			return true
		}
		if condition() {
			_res = _PyPegen_cmpop_expr_pair(p, In, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// isnot_bitwise_or: 'is' 'not' bitwise_or
func isnot_bitwise_or_rule(p *Parser) *CmpopExprPair {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *CmpopExprPair
	_mark := p.mark
	{ // 'is' 'not' bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _keyword_1 *Token
		var a expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 582)
			if _keyword == nil {
				return false
			} // token='is'
			_keyword_1 = _PyPegen_expect_token(p, 581)
			if _keyword_1 == nil {
				return false
			} // token='not'
			a = bitwise_or_rule(p)
			if a == nil {
				return false
			} // bitwise_or
			return true
		}
		if condition() {
			_res = _PyPegen_cmpop_expr_pair(p, IsNot, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// is_bitwise_or: 'is' bitwise_or
func is_bitwise_or_rule(p *Parser) *CmpopExprPair {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *CmpopExprPair
	_mark := p.mark
	{ // 'is' bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var a expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 582)
			if _keyword == nil {
				return false
			} // token='is'
			a = bitwise_or_rule(p)
			if a == nil {
				return false
			} // bitwise_or
			return true
		}
		if condition() {
			_res = _PyPegen_cmpop_expr_pair(p, Is, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// Left-recursive
// bitwise_or: bitwise_or '|' bitwise_xor | bitwise_xor
func bitwise_or_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	var expr_ty _res
	if _PyPegen_is_memoized(p, bitwise_or_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	_resmark := p.mark
	for {
		tmpvar_2 := _PyPegen_update_memo(p, _mark, bitwise_or_type, _res)
		if tmpvar_2 {
			p.level--
			return _res
		}
		p.mark = _mark
		_raw := bitwise_or_raw(p)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		if _raw == nil || p.mark <= _resmark {
			break
		}
		_resmark = p.mark
		_res = _raw
	}
	p.mark = _resmark
	p.level--
	return _res
}
func bitwise_or_raw(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // bitwise_or '|' bitwise_xor
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = bitwise_or_rule(p)
			if a == nil {
				return false
			} // bitwise_or
			_literal = _PyPegen_expect_token(p, 18)
			if _literal == nil {
				return false
			} // token='|'
			b = bitwise_xor_rule(p)
			if b == nil {
				return false
			} // bitwise_xor
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_BinOp(a, BitOr, b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // bitwise_xor
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var bitwise_xor_var expr_ty
		condition := func() bool {
			bitwise_xor_var = bitwise_xor_rule(p)
			if bitwise_xor_var == nil {
				return false
			} // bitwise_xor
			return true
		}
		if condition() {
			_res = bitwise_xor_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// Left-recursive
// bitwise_xor: bitwise_xor '^' bitwise_and | bitwise_and
func bitwise_xor_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	var expr_ty _res
	if _PyPegen_is_memoized(p, bitwise_xor_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	_resmark := p.mark
	for {
		tmpvar_3 := _PyPegen_update_memo(p, _mark, bitwise_xor_type, _res)
		if tmpvar_3 {
			p.level--
			return _res
		}
		p.mark = _mark
		_raw := bitwise_xor_raw(p)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		if _raw == nil || p.mark <= _resmark {
			break
		}
		_resmark = p.mark
		_res = _raw
	}
	p.mark = _resmark
	p.level--
	return _res
}
func bitwise_xor_raw(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // bitwise_xor '^' bitwise_and
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = bitwise_xor_rule(p)
			if a == nil {
				return false
			} // bitwise_xor
			_literal = _PyPegen_expect_token(p, 32)
			if _literal == nil {
				return false
			} // token='^'
			b = bitwise_and_rule(p)
			if b == nil {
				return false
			} // bitwise_and
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_BinOp(a, BitXor, b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // bitwise_and
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var bitwise_and_var expr_ty
		condition := func() bool {
			bitwise_and_var = bitwise_and_rule(p)
			if bitwise_and_var == nil {
				return false
			} // bitwise_and
			return true
		}
		if condition() {
			_res = bitwise_and_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// Left-recursive
// bitwise_and: bitwise_and '&' shift_expr | shift_expr
func bitwise_and_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	var expr_ty _res
	if _PyPegen_is_memoized(p, bitwise_and_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	_resmark := p.mark
	for {
		tmpvar_4 := _PyPegen_update_memo(p, _mark, bitwise_and_type, _res)
		if tmpvar_4 {
			p.level--
			return _res
		}
		p.mark = _mark
		_raw := bitwise_and_raw(p)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		if _raw == nil || p.mark <= _resmark {
			break
		}
		_resmark = p.mark
		_res = _raw
	}
	p.mark = _resmark
	p.level--
	return _res
}
func bitwise_and_raw(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // bitwise_and '&' shift_expr
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = bitwise_and_rule(p)
			if a == nil {
				return false
			} // bitwise_and
			_literal = _PyPegen_expect_token(p, 19)
			if _literal == nil {
				return false
			} // token='&'
			b = shift_expr_rule(p)
			if b == nil {
				return false
			} // shift_expr
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_BinOp(a, BitAnd, b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // shift_expr
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var shift_expr_var expr_ty
		condition := func() bool {
			shift_expr_var = shift_expr_rule(p)
			if shift_expr_var == nil {
				return false
			} // shift_expr
			return true
		}
		if condition() {
			_res = shift_expr_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// Left-recursive
// shift_expr: shift_expr '<<' sum | shift_expr '>>' sum | sum
func shift_expr_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	var expr_ty _res
	if _PyPegen_is_memoized(p, shift_expr_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	_resmark := p.mark
	for {
		tmpvar_5 := _PyPegen_update_memo(p, _mark, shift_expr_type, _res)
		if tmpvar_5 {
			p.level--
			return _res
		}
		p.mark = _mark
		_raw := shift_expr_raw(p)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		if _raw == nil || p.mark <= _resmark {
			break
		}
		_resmark = p.mark
		_res = _raw
	}
	p.mark = _resmark
	p.level--
	return _res
}
func shift_expr_raw(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // shift_expr '<<' sum
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = shift_expr_rule(p)
			if a == nil {
				return false
			} // shift_expr
			_literal = _PyPegen_expect_token(p, 33)
			if _literal == nil {
				return false
			} // token='<<'
			b = sum_rule(p)
			if b == nil {
				return false
			} // sum
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_BinOp(a, LShift, b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // shift_expr '>>' sum
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = shift_expr_rule(p)
			if a == nil {
				return false
			} // shift_expr
			_literal = _PyPegen_expect_token(p, 34)
			if _literal == nil {
				return false
			} // token='>>'
			b = sum_rule(p)
			if b == nil {
				return false
			} // sum
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_BinOp(a, RShift, b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // sum
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var sum_var expr_ty
		condition := func() bool {
			sum_var = sum_rule(p)
			if sum_var == nil {
				return false
			} // sum
			return true
		}
		if condition() {
			_res = sum_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// Left-recursive
// sum: sum '+' term | sum '-' term | term
func sum_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	var expr_ty _res
	if _PyPegen_is_memoized(p, sum_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	_resmark := p.mark
	for {
		tmpvar_6 := _PyPegen_update_memo(p, _mark, sum_type, _res)
		if tmpvar_6 {
			p.level--
			return _res
		}
		p.mark = _mark
		_raw := sum_raw(p)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		if _raw == nil || p.mark <= _resmark {
			break
		}
		_resmark = p.mark
		_res = _raw
	}
	p.mark = _resmark
	p.level--
	return _res
}
func sum_raw(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // sum '+' term
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = sum_rule(p)
			if a == nil {
				return false
			} // sum
			_literal = _PyPegen_expect_token(p, 14)
			if _literal == nil {
				return false
			} // token='+'
			b = term_rule(p)
			if b == nil {
				return false
			} // term
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_BinOp(a, Add, b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // sum '-' term
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = sum_rule(p)
			if a == nil {
				return false
			} // sum
			_literal = _PyPegen_expect_token(p, 15)
			if _literal == nil {
				return false
			} // token='-'
			b = term_rule(p)
			if b == nil {
				return false
			} // term
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_BinOp(a, Sub, b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // term
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var term_var expr_ty
		condition := func() bool {
			term_var = term_rule(p)
			if term_var == nil {
				return false
			} // term
			return true
		}
		if condition() {
			_res = term_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// Left-recursive
// term:
//     | term '*' factor
//     | term '/' factor
//     | term '//' factor
//     | term '%' factor
//     | term '@' factor
//     | factor
func term_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	var expr_ty _res
	if _PyPegen_is_memoized(p, term_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	_resmark := p.mark
	for {
		tmpvar_7 := _PyPegen_update_memo(p, _mark, term_type, _res)
		if tmpvar_7 {
			p.level--
			return _res
		}
		p.mark = _mark
		_raw := term_raw(p)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		if _raw == nil || p.mark <= _resmark {
			break
		}
		_resmark = p.mark
		_res = _raw
	}
	p.mark = _resmark
	p.level--
	return _res
}
func term_raw(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // term '*' factor
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = term_rule(p)
			if a == nil {
				return false
			} // term
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			b = factor_rule(p)
			if b == nil {
				return false
			} // factor
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_BinOp(a, Mult, b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // term '/' factor
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = term_rule(p)
			if a == nil {
				return false
			} // term
			_literal = _PyPegen_expect_token(p, 17)
			if _literal == nil {
				return false
			} // token='/'
			b = factor_rule(p)
			if b == nil {
				return false
			} // factor
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_BinOp(a, Div, b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // term '//' factor
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = term_rule(p)
			if a == nil {
				return false
			} // term
			_literal = _PyPegen_expect_token(p, 47)
			if _literal == nil {
				return false
			} // token='//'
			b = factor_rule(p)
			if b == nil {
				return false
			} // factor
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_BinOp(a, FloorDiv, b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // term '%' factor
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = term_rule(p)
			if a == nil {
				return false
			} // term
			_literal = _PyPegen_expect_token(p, 24)
			if _literal == nil {
				return false
			} // token='%'
			b = factor_rule(p)
			if b == nil {
				return false
			} // factor
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_BinOp(a, Mod, b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // term '@' factor
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = term_rule(p)
			if a == nil {
				return false
			} // term
			_literal = _PyPegen_expect_token(p, 49)
			if _literal == nil {
				return false
			} // token='@'
			b = factor_rule(p)
			if b == nil {
				return false
			} // factor
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = CHECK_VERSION(expr_ty, 5, "The '@' operator is", _PyAST_BinOp(a, MatMult, b, EXTRA))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // factor
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var factor_var expr_ty
		condition := func() bool {
			factor_var = factor_rule(p)
			if factor_var == nil {
				return false
			} // factor
			return true
		}
		if condition() {
			_res = factor_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// factor: '+' factor | '-' factor | '~' factor | power
func factor_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	if _PyPegen_is_memoized(p, factor_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // '+' factor
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 14)
			if _literal == nil {
				return false
			} // token='+'
			a = factor_rule(p)
			if a == nil {
				return false
			} // factor
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_UnaryOp(UAdd, a, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '-' factor
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 15)
			if _literal == nil {
				return false
			} // token='-'
			a = factor_rule(p)
			if a == nil {
				return false
			} // factor
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_UnaryOp(USub, a, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '~' factor
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 31)
			if _literal == nil {
				return false
			} // token='~'
			a = factor_rule(p)
			if a == nil {
				return false
			} // factor
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_UnaryOp(Invert, a, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // power
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var power_var expr_ty
		condition := func() bool {
			power_var = power_rule(p)
			if power_var == nil {
				return false
			} // power
			return true
		}
		if condition() {
			_res = power_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	_PyPegen_insert_memo(p, _mark, factor_type, _res)
	p.level--
	return _res
}

// power: await_primary '**' factor | await_primary
func power_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // await_primary '**' factor
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = await_primary_rule(p)
			if a == nil {
				return false
			} // await_primary
			_literal = _PyPegen_expect_token(p, 35)
			if _literal == nil {
				return false
			} // token='**'
			b = factor_rule(p)
			if b == nil {
				return false
			} // factor
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_BinOp(a, Pow, b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // await_primary
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var await_primary_var expr_ty
		condition := func() bool {
			await_primary_var = await_primary_rule(p)
			if await_primary_var == nil {
				return false
			} // await_primary
			return true
		}
		if condition() {
			_res = await_primary_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// await_primary: AWAIT primary | primary
func await_primary_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	if _PyPegen_is_memoized(p, await_primary_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // AWAIT primary
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		var await_var *Token
		condition := func() bool {
			await_var = _PyPegen_expect_token(p, AWAIT)
			if await_var == nil {
				return false
			} // token='AWAIT'
			a = primary_rule(p)
			if a == nil {
				return false
			} // primary
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = CHECK_VERSION(expr_ty, 5, "Await expressions are", _PyAST_Await(a, EXTRA))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // primary
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var primary_var expr_ty
		condition := func() bool {
			primary_var = primary_rule(p)
			if primary_var == nil {
				return false
			} // primary
			return true
		}
		if condition() {
			_res = primary_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	_PyPegen_insert_memo(p, _mark, await_primary_type, _res)
	p.level--
	return _res
}

// Left-recursive
// primary:
//     | primary '.' NAME
//     | primary genexp
//     | primary '(' arguments? ')'
//     | primary '[' slices ']'
//     | atom
func primary_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	var expr_ty _res
	if _PyPegen_is_memoized(p, primary_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	_resmark := p.mark
	for {
		tmpvar_8 := _PyPegen_update_memo(p, _mark, primary_type, _res)
		if tmpvar_8 {
			p.level--
			return _res
		}
		p.mark = _mark
		_raw := primary_raw(p)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		if _raw == nil || p.mark <= _resmark {
			break
		}
		_resmark = p.mark
		_res = _raw
	}
	p.mark = _resmark
	p.level--
	return _res
}
func primary_raw(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // primary '.' NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = primary_rule(p)
			if a == nil {
				return false
			} // primary
			_literal = _PyPegen_expect_token(p, 23)
			if _literal == nil {
				return false
			} // token='.'
			b = _PyPegen_name_token(p)
			if b == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Attribute(a, b.v.Name.id, Load, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // primary genexp
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = primary_rule(p)
			if a == nil {
				return false
			} // primary
			b = genexp_rule(p)
			if b == nil {
				return false
			} // genexp
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Call(a, CHECK(*asdl_expr_seq, _PyPegen_singleton_seq(p, b)), nil, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // primary '(' arguments? ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a expr_ty
		var b any
		condition := func() bool {
			a = primary_rule(p)
			if a == nil {
				return false
			} // primary
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			b = arguments_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// arguments?
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Call(a, ternary_operator(b, b.v.Call.args, nil), ternary_operator(b, b.v.Call.keywords, nil), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // primary '[' slices ']'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = primary_rule(p)
			if a == nil {
				return false
			} // primary
			_literal = _PyPegen_expect_token(p, 9)
			if _literal == nil {
				return false
			} // token='['
			b = slices_rule(p)
			if b == nil {
				return false
			} // slices
			_literal_1 = _PyPegen_expect_token(p, 10)
			if _literal_1 == nil {
				return false
			} // token=']'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Subscript(a, b, Load, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // atom
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var atom_var expr_ty
		condition := func() bool {
			atom_var = atom_rule(p)
			if atom_var == nil {
				return false
			} // atom
			return true
		}
		if condition() {
			_res = atom_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// slices: slice !',' | ','.(slice | starred_expression)+ ','?
func slices_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // slice !','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		condition := func() bool {
			a = slice_rule(p)
			if a == nil {
				return false
			} // slice
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 12)
			if _tmp == 0 {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // ','.(slice | starred_expression)+ ','?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a *asdl_expr_seq
		condition := func() bool {
			a = *asdl_expr_seq_gather_88_rule(p)
			if a == nil {
				return false
			} // ','.(slice | starred_expression)+
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Tuple(a, Load, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// slice: expression? ':' expression? [':' expression?] | named_expression
func slice_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // expression? ':' expression? [':' expression?]
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a any
		var b any
		var c any
		condition := func() bool {
			a = expression_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// expression?
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			b = expression_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// expression?
			c = _tmp_90_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// [':' expression?]
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Slice(a, b, c, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // named_expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		condition := func() bool {
			a = named_expression_rule(p)
			if a == nil {
				return false
			} // named_expression
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// atom:
//     | NAME
//     | 'True'
//     | 'False'
//     | 'None'
//     | &STRING strings
//     | NUMBER
//     | &'(' (tuple | group | genexp)
//     | &'[' (list | listcomp)
//     | &'{' (dict | set | dictcomp | setcomp)
//     | '...'
func atom_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var name_var expr_ty
		condition := func() bool {
			name_var = _PyPegen_name_token(p)
			if name_var == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_res = name_var
			goto done
		}
		p.mark = _mark
	}
	{ // 'True'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 600)
			if _keyword == nil {
				return false
			} // token='True'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Constant(builtin.PyTrue, nil, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'False'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 602)
			if _keyword == nil {
				return false
			} // token='False'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Constant(PyFalse, nil, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'None'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 601)
			if _keyword == nil {
				return false
			} // token='None'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Constant(builtin.PyNone, nil, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // &STRING strings
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var strings_var expr_ty
		condition := func() bool {
			_tmp := _PyPegen_lookahead(1, _PyPegen_string_token, p)
			if _tmp == 0 {
				return false
			}
			strings_var = strings_rule(p)
			if strings_var == nil {
				return false
			} // strings
			return true
		}
		if condition() {
			_res = strings_var
			goto done
		}
		p.mark = _mark
	}
	{ // NUMBER
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var number_var expr_ty
		condition := func() bool {
			number_var = _PyPegen_number_token(p)
			if number_var == nil {
				return false
			} // NUMBER
			return true
		}
		if condition() {
			_res = number_var
			goto done
		}
		p.mark = _mark
	}
	{ // &'(' (tuple | group | genexp)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_91_var any
		condition := func() bool {
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 7)
			if _tmp == 0 {
				return false
			} // token='('
			_tmp_91_var = _tmp_91_rule(p)
			if _tmp_91_var == nil {
				return false
			} // tuple | group | genexp
			return true
		}
		if condition() {
			_res = _tmp_91_var
			goto done
		}
		p.mark = _mark
	}
	{ // &'[' (list | listcomp)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_92_var any
		condition := func() bool {
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 9)
			if _tmp == 0 {
				return false
			} // token='['
			_tmp_92_var = _tmp_92_rule(p)
			if _tmp_92_var == nil {
				return false
			} // list | listcomp
			return true
		}
		if condition() {
			_res = _tmp_92_var
			goto done
		}
		p.mark = _mark
	}
	{ // &'{' (dict | set | dictcomp | setcomp)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_93_var any
		condition := func() bool {
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 25)
			if _tmp == 0 {
				return false
			} // token='{'
			_tmp_93_var = _tmp_93_rule(p)
			if _tmp_93_var == nil {
				return false
			} // dict | set | dictcomp | setcomp
			return true
		}
		if condition() {
			_res = _tmp_93_var
			goto done
		}
		p.mark = _mark
	}
	{ // '...'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 52)
			if _literal == nil {
				return false
			} // token='...'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Constant(Py_Ellipsis, nil, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// group: '(' (yield_expr | named_expression) ')' | invalid_group
func group_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	{ // '(' (yield_expr | named_expression) ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			a = _tmp_94_rule(p)
			if a == nil {
				return false
			} // yield_expr | named_expression
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	if p.call_invalid_rules { // invalid_group
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_group_var any
		condition := func() bool {
			invalid_group_var = invalid_group_rule(p)
			if invalid_group_var == nil {
				return false
			} // invalid_group
			return true
		}
		if condition() {
			_res = invalid_group_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// lambdef: 'lambda' lambda_params? ':' expression
func lambdef_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // 'lambda' lambda_params? ':' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var a any
		var b expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 586)
			if _keyword == nil {
				return false
			} // token='lambda'
			a = lambda_params_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// lambda_params?
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			b = expression_rule(p)
			if b == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Lambda(ternary_operator(a, a, CHECK(arguments_ty, _PyPegen_empty_arguments(p))), b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// lambda_params: invalid_lambda_parameters | lambda_parameters
func lambda_params_rule(p *Parser) arguments_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res arguments_ty
	_mark := p.mark
	if p.call_invalid_rules { // invalid_lambda_parameters
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_lambda_parameters_var any
		condition := func() bool {
			invalid_lambda_parameters_var = invalid_lambda_parameters_rule(p)
			if invalid_lambda_parameters_var == nil {
				return false
			} // invalid_lambda_parameters
			return true
		}
		if condition() {
			_res = invalid_lambda_parameters_var
			goto done
		}
		p.mark = _mark
	}
	{ // lambda_parameters
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_parameters_var arguments_ty
		condition := func() bool {
			lambda_parameters_var = lambda_parameters_rule(p)
			if lambda_parameters_var == nil {
				return false
			} // lambda_parameters
			return true
		}
		if condition() {
			_res = lambda_parameters_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// lambda_parameters:
//     | lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc?
//     | lambda_slash_with_default lambda_param_with_default* lambda_star_etc?
//     | lambda_param_no_default+ lambda_param_with_default* lambda_star_etc?
//     | lambda_param_with_default+ lambda_star_etc?
//     | lambda_star_etc
func lambda_parameters_rule(p *Parser) arguments_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res arguments_ty
	_mark := p.mark
	{ // lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_arg_seq
		var b *asdl_arg_seq
		var c *asdl_seq
		var d any
		condition := func() bool {
			a = lambda_slash_no_default_rule(p)
			if a == nil {
				return false
			} // lambda_slash_no_default
			b = *asdl_arg_seq_loop0_95_rule(p)
			if b == nil {
				return false
			} // lambda_param_no_default*
			c = _loop0_96_rule(p)
			if c == nil {
				return false
			} // lambda_param_with_default*
			d = lambda_star_etc_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// lambda_star_etc?
			return true
		}
		if condition() {
			_res = CHECK_VERSION(arguments_ty, 8, "Positional-only parameters are", _PyPegen_make_arguments(p, a, nil, b, c, d))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // lambda_slash_with_default lambda_param_with_default* lambda_star_etc?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *SlashWithDefault
		var b *asdl_seq
		var c any
		condition := func() bool {
			a = lambda_slash_with_default_rule(p)
			if a == nil {
				return false
			} // lambda_slash_with_default
			b = _loop0_97_rule(p)
			if b == nil {
				return false
			} // lambda_param_with_default*
			c = lambda_star_etc_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// lambda_star_etc?
			return true
		}
		if condition() {
			_res = CHECK_VERSION(arguments_ty, 8, "Positional-only parameters are", _PyPegen_make_arguments(p, nil, a, nil, b, c))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // lambda_param_no_default+ lambda_param_with_default* lambda_star_etc?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_arg_seq
		var b *asdl_seq
		var c any
		condition := func() bool {
			a = *asdl_arg_seq_loop1_98_rule(p)
			if a == nil {
				return false
			} // lambda_param_no_default+
			b = _loop0_99_rule(p)
			if b == nil {
				return false
			} // lambda_param_with_default*
			c = lambda_star_etc_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// lambda_star_etc?
			return true
		}
		if condition() {
			_res = _PyPegen_make_arguments(p, nil, nil, a, b, c)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // lambda_param_with_default+ lambda_star_etc?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_seq
		var b any
		condition := func() bool {
			a = _loop1_100_rule(p)
			if a == nil {
				return false
			} // lambda_param_with_default+
			b = lambda_star_etc_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// lambda_star_etc?
			return true
		}
		if condition() {
			_res = _PyPegen_make_arguments(p, nil, nil, nil, a, b)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // lambda_star_etc
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *StarEtc
		condition := func() bool {
			a = lambda_star_etc_rule(p)
			if a == nil {
				return false
			} // lambda_star_etc
			return true
		}
		if condition() {
			_res = _PyPegen_make_arguments(p, nil, nil, nil, nil, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// lambda_slash_no_default:
//     | lambda_param_no_default+ '/' ','
//     | lambda_param_no_default+ '/' &':'
func lambda_slash_no_default_rule(p *Parser) *asdl_arg_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_arg_seq
	_mark := p.mark
	{ // lambda_param_no_default+ '/' ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a *asdl_arg_seq
		condition := func() bool {
			a = *asdl_arg_seq_loop1_101_rule(p)
			if a == nil {
				return false
			} // lambda_param_no_default+
			_literal = _PyPegen_expect_token(p, 17)
			if _literal == nil {
				return false
			} // token='/'
			_literal_1 = _PyPegen_expect_token(p, 12)
			if _literal_1 == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // lambda_param_no_default+ '/' &':'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *asdl_arg_seq
		condition := func() bool {
			a = *asdl_arg_seq_loop1_102_rule(p)
			if a == nil {
				return false
			} // lambda_param_no_default+
			_literal = _PyPegen_expect_token(p, 17)
			if _literal == nil {
				return false
			} // token='/'
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 11)
			if _tmp == 0 {
				return false
			} // token=':'
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// lambda_slash_with_default:
//     | lambda_param_no_default* lambda_param_with_default+ '/' ','
//     | lambda_param_no_default* lambda_param_with_default+ '/' &':'
func lambda_slash_with_default_rule(p *Parser) *SlashWithDefault {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *SlashWithDefault
	_mark := p.mark
	{ // lambda_param_no_default* lambda_param_with_default+ '/' ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a *asdl_seq
		var b *asdl_seq
		condition := func() bool {
			a = _loop0_103_rule(p)
			if a == nil {
				return false
			} // lambda_param_no_default*
			b = _loop1_104_rule(p)
			if b == nil {
				return false
			} // lambda_param_with_default+
			_literal = _PyPegen_expect_token(p, 17)
			if _literal == nil {
				return false
			} // token='/'
			_literal_1 = _PyPegen_expect_token(p, 12)
			if _literal_1 == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = _PyPegen_slash_with_default(p, a, b)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // lambda_param_no_default* lambda_param_with_default+ '/' &':'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *asdl_seq
		var b *asdl_seq
		condition := func() bool {
			a = _loop0_105_rule(p)
			if a == nil {
				return false
			} // lambda_param_no_default*
			b = _loop1_106_rule(p)
			if b == nil {
				return false
			} // lambda_param_with_default+
			_literal = _PyPegen_expect_token(p, 17)
			if _literal == nil {
				return false
			} // token='/'
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 11)
			if _tmp == 0 {
				return false
			} // token=':'
			return true
		}
		if condition() {
			_res = _PyPegen_slash_with_default(p, a, b)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// lambda_star_etc:
//     | invalid_lambda_star_etc
//     | '*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds?
//     | '*' ',' lambda_param_maybe_default+ lambda_kwds?
//     | lambda_kwds
func lambda_star_etc_rule(p *Parser) *StarEtc {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *StarEtc
	_mark := p.mark
	if p.call_invalid_rules { // invalid_lambda_star_etc
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_lambda_star_etc_var any
		condition := func() bool {
			invalid_lambda_star_etc_var = invalid_lambda_star_etc_rule(p)
			if invalid_lambda_star_etc_var == nil {
				return false
			} // invalid_lambda_star_etc
			return true
		}
		if condition() {
			_res = invalid_lambda_star_etc_var
			goto done
		}
		p.mark = _mark
	}
	{ // '*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a arg_ty
		var b *asdl_seq
		var c any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			a = lambda_param_no_default_rule(p)
			if a == nil {
				return false
			} // lambda_param_no_default
			b = _loop0_107_rule(p)
			if b == nil {
				return false
			} // lambda_param_maybe_default*
			c = lambda_kwds_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// lambda_kwds?
			return true
		}
		if condition() {
			_res = _PyPegen_star_etc(p, a, b, c)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '*' ',' lambda_param_maybe_default+ lambda_kwds?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var b *asdl_seq
		var c any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			_literal_1 = _PyPegen_expect_token(p, 12)
			if _literal_1 == nil {
				return false
			} // token=','
			b = _loop1_108_rule(p)
			if b == nil {
				return false
			} // lambda_param_maybe_default+
			c = lambda_kwds_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// lambda_kwds?
			return true
		}
		if condition() {
			_res = _PyPegen_star_etc(p, nil, b, c)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // lambda_kwds
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a arg_ty
		condition := func() bool {
			a = lambda_kwds_rule(p)
			if a == nil {
				return false
			} // lambda_kwds
			return true
		}
		if condition() {
			_res = _PyPegen_star_etc(p, nil, nil, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// lambda_kwds: invalid_lambda_kwds | '**' lambda_param_no_default
func lambda_kwds_rule(p *Parser) arg_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res arg_ty
	_mark := p.mark
	if p.call_invalid_rules { // invalid_lambda_kwds
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_lambda_kwds_var any
		condition := func() bool {
			invalid_lambda_kwds_var = invalid_lambda_kwds_rule(p)
			if invalid_lambda_kwds_var == nil {
				return false
			} // invalid_lambda_kwds
			return true
		}
		if condition() {
			_res = invalid_lambda_kwds_var
			goto done
		}
		p.mark = _mark
	}
	{ // '**' lambda_param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a arg_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 35)
			if _literal == nil {
				return false
			} // token='**'
			a = lambda_param_no_default_rule(p)
			if a == nil {
				return false
			} // lambda_param_no_default
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// lambda_param_no_default: lambda_param ',' | lambda_param &':'
func lambda_param_no_default_rule(p *Parser) arg_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res arg_ty
	_mark := p.mark
	{ // lambda_param ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a arg_ty
		condition := func() bool {
			a = lambda_param_rule(p)
			if a == nil {
				return false
			} // lambda_param
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // lambda_param &':'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a arg_ty
		condition := func() bool {
			a = lambda_param_rule(p)
			if a == nil {
				return false
			} // lambda_param
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 11)
			if _tmp == 0 {
				return false
			} // token=':'
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// lambda_param_with_default: lambda_param default ',' | lambda_param default &':'
func lambda_param_with_default_rule(p *Parser) *NameDefaultPair {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *NameDefaultPair
	_mark := p.mark
	{ // lambda_param default ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a arg_ty
		var c expr_ty
		condition := func() bool {
			a = lambda_param_rule(p)
			if a == nil {
				return false
			} // lambda_param
			c = default_rule(p)
			if c == nil {
				return false
			} // default
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = _PyPegen_name_default_pair(p, a, c, nil)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // lambda_param default &':'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a arg_ty
		var c expr_ty
		condition := func() bool {
			a = lambda_param_rule(p)
			if a == nil {
				return false
			} // lambda_param
			c = default_rule(p)
			if c == nil {
				return false
			} // default
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 11)
			if _tmp == 0 {
				return false
			} // token=':'
			return true
		}
		if condition() {
			_res = _PyPegen_name_default_pair(p, a, c, nil)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// lambda_param_maybe_default: lambda_param default? ',' | lambda_param default? &':'
func lambda_param_maybe_default_rule(p *Parser) *NameDefaultPair {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *NameDefaultPair
	_mark := p.mark
	{ // lambda_param default? ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a arg_ty
		var c any
		condition := func() bool {
			a = lambda_param_rule(p)
			if a == nil {
				return false
			} // lambda_param
			c = default_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// default?
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = _PyPegen_name_default_pair(p, a, c, nil)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // lambda_param default? &':'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a arg_ty
		var c any
		condition := func() bool {
			a = lambda_param_rule(p)
			if a == nil {
				return false
			} // lambda_param
			c = default_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// default?
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 11)
			if _tmp == 0 {
				return false
			} // token=':'
			return true
		}
		if condition() {
			_res = _PyPegen_name_default_pair(p, a, c, nil)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// lambda_param: NAME
func lambda_param_rule(p *Parser) arg_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res arg_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		condition := func() bool {
			a = _PyPegen_name_token(p)
			if a == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_arg(a.v.Name.id, nil, nil, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// strings: STRING+
func strings_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	if _PyPegen_is_memoized(p, strings_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	{ // STRING+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_seq
		condition := func() bool {
			a = _loop1_109_rule(p)
			if a == nil {
				return false
			} // STRING+
			return true
		}
		if condition() {
			_res = _PyPegen_concatenate_strings(p, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	_PyPegen_insert_memo(p, _mark, strings_type, _res)
	p.level--
	return _res
}

// list: '[' star_named_expressions? ']'
func list_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // '[' star_named_expressions? ']'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 9)
			if _literal == nil {
				return false
			} // token='['
			a = star_named_expressions_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// star_named_expressions?
			_literal_1 = _PyPegen_expect_token(p, 10)
			if _literal_1 == nil {
				return false
			} // token=']'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_List(a, Load, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// tuple: '(' [star_named_expression ',' star_named_expressions?] ')'
func tuple_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // '(' [star_named_expression ',' star_named_expressions?] ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			a = _tmp_110_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// [star_named_expression ',' star_named_expressions?]
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Tuple(a, Load, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// set: '{' star_named_expressions '}'
func set_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // '{' star_named_expressions '}'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a *asdl_expr_seq
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 25)
			if _literal == nil {
				return false
			} // token='{'
			a = star_named_expressions_rule(p)
			if a == nil {
				return false
			} // star_named_expressions
			_literal_1 = _PyPegen_expect_token(p, 26)
			if _literal_1 == nil {
				return false
			} // token='}'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Set(a, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// dict: '{' double_starred_kvpairs? '}' | '{' invalid_double_starred_kvpairs '}'
func dict_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // '{' double_starred_kvpairs? '}'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 25)
			if _literal == nil {
				return false
			} // token='{'
			a = double_starred_kvpairs_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// double_starred_kvpairs?
			_literal_1 = _PyPegen_expect_token(p, 26)
			if _literal_1 == nil {
				return false
			} // token='}'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Dict(CHECK(*asdl_expr_seq, _PyPegen_get_keys(p, a)), CHECK(*asdl_expr_seq, _PyPegen_get_values(p, a)), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '{' invalid_double_starred_kvpairs '}'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var invalid_double_starred_kvpairs_var any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 25)
			if _literal == nil {
				return false
			} // token='{'
			invalid_double_starred_kvpairs_var = invalid_double_starred_kvpairs_rule(p)
			if invalid_double_starred_kvpairs_var == nil {
				return false
			} // invalid_double_starred_kvpairs
			_literal_1 = _PyPegen_expect_token(p, 26)
			if _literal_1 == nil {
				return false
			} // token='}'
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, _literal, invalid_double_starred_kvpairs_var, _literal_1)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// double_starred_kvpairs: ','.double_starred_kvpair+ ','?
func double_starred_kvpairs_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // ','.double_starred_kvpair+ ','?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a *asdl_seq
		condition := func() bool {
			a = _gather_111_rule(p)
			if a == nil {
				return false
			} // ','.double_starred_kvpair+
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// double_starred_kvpair: '**' bitwise_or | kvpair
func double_starred_kvpair_rule(p *Parser) *KeyValuePair {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *KeyValuePair
	_mark := p.mark
	{ // '**' bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 35)
			if _literal == nil {
				return false
			} // token='**'
			a = bitwise_or_rule(p)
			if a == nil {
				return false
			} // bitwise_or
			return true
		}
		if condition() {
			_res = _PyPegen_key_value_pair(p, nil, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // kvpair
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var kvpair_var *KeyValuePair
		condition := func() bool {
			kvpair_var = kvpair_rule(p)
			if kvpair_var == nil {
				return false
			} // kvpair
			return true
		}
		if condition() {
			_res = kvpair_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// kvpair: expression ':' expression
func kvpair_rule(p *Parser) *KeyValuePair {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *KeyValuePair
	_mark := p.mark
	{ // expression ':' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			b = expression_rule(p)
			if b == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = _PyPegen_key_value_pair(p, a, b)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// for_if_clauses: for_if_clause+
func for_if_clauses_rule(p *Parser) *asdl_comprehension_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_comprehension_seq
	_mark := p.mark
	{ // for_if_clause+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_comprehension_seq
		condition := func() bool {
			a = *asdl_comprehension_seq_loop1_113_rule(p)
			if a == nil {
				return false
			} // for_if_clause+
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// for_if_clause:
//     | ASYNC 'for' star_targets 'in' ~ disjunction (('if' disjunction))*
//     | 'for' star_targets 'in' ~ disjunction (('if' disjunction))*
//     | invalid_for_target
func for_if_clause_rule(p *Parser) comprehension_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res comprehension_ty
	_mark := p.mark
	{ // ASYNC 'for' star_targets 'in' ~ disjunction (('if' disjunction))*
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		_cut_var := 0
		var _keyword *Token
		var _keyword_1 *Token
		var a expr_ty
		var async_var *Token
		var b expr_ty
		var c *asdl_expr_seq
		condition := func() bool {
			async_var = _PyPegen_expect_token(p, ASYNC)
			if async_var == nil {
				return false
			} // token='ASYNC'
			_keyword = _PyPegen_expect_token(p, 647)
			if _keyword == nil {
				return false
			} // token='for'
			a = star_targets_rule(p)
			if a == nil {
				return false
			} // star_targets
			_keyword_1 = _PyPegen_expect_token(p, 648)
			if _keyword_1 == nil {
				return false
			} // token='in'
			_cut_var = 1
			if _cut_var == nil {
				return false
			}
			b = disjunction_rule(p)
			if b == nil {
				return false
			} // disjunction
			c = *asdl_expr_seq_loop0_114_rule(p)
			if c == nil {
				return false
			} // (('if' disjunction))*
			return true
		}
		if condition() {
			_res = CHECK_VERSION(comprehension_ty, 6, "Async comprehensions are", _PyAST_comprehension(a, b, c, 1, p.arena))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
		if _cut_var {
			p.level--
			return nil
		}
	}
	{ // 'for' star_targets 'in' ~ disjunction (('if' disjunction))*
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		_cut_var := 0
		var _keyword *Token
		var _keyword_1 *Token
		var a expr_ty
		var b expr_ty
		var c *asdl_expr_seq
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 647)
			if _keyword == nil {
				return false
			} // token='for'
			a = star_targets_rule(p)
			if a == nil {
				return false
			} // star_targets
			_keyword_1 = _PyPegen_expect_token(p, 648)
			if _keyword_1 == nil {
				return false
			} // token='in'
			_cut_var = 1
			if _cut_var == nil {
				return false
			}
			b = disjunction_rule(p)
			if b == nil {
				return false
			} // disjunction
			c = *asdl_expr_seq_loop0_115_rule(p)
			if c == nil {
				return false
			} // (('if' disjunction))*
			return true
		}
		if condition() {
			_res = _PyAST_comprehension(a, b, c, 0, p.arena)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
		if _cut_var {
			p.level--
			return nil
		}
	}
	if p.call_invalid_rules { // invalid_for_target
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_for_target_var any
		condition := func() bool {
			invalid_for_target_var = invalid_for_target_rule(p)
			if invalid_for_target_var == nil {
				return false
			} // invalid_for_target
			return true
		}
		if condition() {
			_res = invalid_for_target_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// listcomp: '[' named_expression for_if_clauses ']' | invalid_comprehension
func listcomp_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // '[' named_expression for_if_clauses ']'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a expr_ty
		var b *asdl_comprehension_seq
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 9)
			if _literal == nil {
				return false
			} // token='['
			a = named_expression_rule(p)
			if a == nil {
				return false
			} // named_expression
			b = for_if_clauses_rule(p)
			if b == nil {
				return false
			} // for_if_clauses
			_literal_1 = _PyPegen_expect_token(p, 10)
			if _literal_1 == nil {
				return false
			} // token=']'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_ListComp(a, b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	if p.call_invalid_rules { // invalid_comprehension
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_comprehension_var any
		condition := func() bool {
			invalid_comprehension_var = invalid_comprehension_rule(p)
			if invalid_comprehension_var == nil {
				return false
			} // invalid_comprehension
			return true
		}
		if condition() {
			_res = invalid_comprehension_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// setcomp: '{' named_expression for_if_clauses '}' | invalid_comprehension
func setcomp_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // '{' named_expression for_if_clauses '}'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a expr_ty
		var b *asdl_comprehension_seq
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 25)
			if _literal == nil {
				return false
			} // token='{'
			a = named_expression_rule(p)
			if a == nil {
				return false
			} // named_expression
			b = for_if_clauses_rule(p)
			if b == nil {
				return false
			} // for_if_clauses
			_literal_1 = _PyPegen_expect_token(p, 26)
			if _literal_1 == nil {
				return false
			} // token='}'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_SetComp(a, b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	if p.call_invalid_rules { // invalid_comprehension
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_comprehension_var any
		condition := func() bool {
			invalid_comprehension_var = invalid_comprehension_rule(p)
			if invalid_comprehension_var == nil {
				return false
			} // invalid_comprehension
			return true
		}
		if condition() {
			_res = invalid_comprehension_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// genexp:
//     | '(' (assignment_expression | expression !':=') for_if_clauses ')'
//     | invalid_comprehension
func genexp_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // '(' (assignment_expression | expression !':=') for_if_clauses ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a any
		var b *asdl_comprehension_seq
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			a = _tmp_116_rule(p)
			if a == nil {
				return false
			} // assignment_expression | expression !':='
			b = for_if_clauses_rule(p)
			if b == nil {
				return false
			} // for_if_clauses
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_GeneratorExp(a, b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	if p.call_invalid_rules { // invalid_comprehension
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_comprehension_var any
		condition := func() bool {
			invalid_comprehension_var = invalid_comprehension_rule(p)
			if invalid_comprehension_var == nil {
				return false
			} // invalid_comprehension
			return true
		}
		if condition() {
			_res = invalid_comprehension_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// dictcomp: '{' kvpair for_if_clauses '}' | invalid_dict_comprehension
func dictcomp_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // '{' kvpair for_if_clauses '}'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a *KeyValuePair
		var b *asdl_comprehension_seq
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 25)
			if _literal == nil {
				return false
			} // token='{'
			a = kvpair_rule(p)
			if a == nil {
				return false
			} // kvpair
			b = for_if_clauses_rule(p)
			if b == nil {
				return false
			} // for_if_clauses
			_literal_1 = _PyPegen_expect_token(p, 26)
			if _literal_1 == nil {
				return false
			} // token='}'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_DictComp(a.key, a.value, b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	if p.call_invalid_rules { // invalid_dict_comprehension
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_dict_comprehension_var any
		condition := func() bool {
			invalid_dict_comprehension_var = invalid_dict_comprehension_rule(p)
			if invalid_dict_comprehension_var == nil {
				return false
			} // invalid_dict_comprehension
			return true
		}
		if condition() {
			_res = invalid_dict_comprehension_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// arguments: args ','? &')' | invalid_arguments
func arguments_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	if _PyPegen_is_memoized(p, arguments_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	{ // args ','? &')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a expr_ty
		condition := func() bool {
			a = args_rule(p)
			if a == nil {
				return false
			} // args
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			_tmp := _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)
			if _tmp == 0 {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	if p.call_invalid_rules { // invalid_arguments
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_arguments_var any
		condition := func() bool {
			invalid_arguments_var = invalid_arguments_rule(p)
			if invalid_arguments_var == nil {
				return false
			} // invalid_arguments
			return true
		}
		if condition() {
			_res = invalid_arguments_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	_PyPegen_insert_memo(p, _mark, arguments_type, _res)
	p.level--
	return _res
}

// args:
//     | ','.(starred_expression | (assignment_expression | expression !':=') !'=')+ [',' kwargs]
//     | kwargs
func args_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // ','.(starred_expression | (assignment_expression | expression !':=') !'=')+ [',' kwargs]
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_expr_seq
		var b any
		condition := func() bool {
			a = *asdl_expr_seq_gather_117_rule(p)
			if a == nil {
				return false
			} // ','.(starred_expression | (assignment_expression | expression !':=') !'=')+
			b = _tmp_119_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// [',' kwargs]
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyPegen_collect_call_seqs(p, a, b, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // kwargs
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_seq
		condition := func() bool {
			a = kwargs_rule(p)
			if a == nil {
				return false
			} // kwargs
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Call(_PyPegen_dummy_name(p), CHECK_nil_ALLOWED(*asdl_expr_seq, _PyPegen_seq_extract_starred_exprs(p, a)), CHECK_nil_ALLOWED(*asdl_keyword_seq, _PyPegen_seq_delete_starred_exprs(p, a)), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// kwargs:
//     | ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+
//     | ','.kwarg_or_starred+
//     | ','.kwarg_or_double_starred+
func kwargs_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *asdl_seq
		var b *asdl_seq
		condition := func() bool {
			a = _gather_120_rule(p)
			if a == nil {
				return false
			} // ','.kwarg_or_starred+
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			b = _gather_122_rule(p)
			if b == nil {
				return false
			} // ','.kwarg_or_double_starred+
			return true
		}
		if condition() {
			_res = _PyPegen_join_sequences(p, a, b)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // ','.kwarg_or_starred+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _gather_124_var *asdl_seq
		condition := func() bool {
			_gather_124_var = _gather_124_rule(p)
			if _gather_124_var == nil {
				return false
			} // ','.kwarg_or_starred+
			return true
		}
		if condition() {
			_res = _gather_124_var
			goto done
		}
		p.mark = _mark
	}
	{ // ','.kwarg_or_double_starred+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _gather_126_var *asdl_seq
		condition := func() bool {
			_gather_126_var = _gather_126_rule(p)
			if _gather_126_var == nil {
				return false
			} // ','.kwarg_or_double_starred+
			return true
		}
		if condition() {
			_res = _gather_126_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// starred_expression: '*' expression
func starred_expression_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // '*' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Starred(a, Load, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// kwarg_or_starred: invalid_kwarg | NAME '=' expression | starred_expression
func kwarg_or_starred_rule(p *Parser) *KeywordOrStarred {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *KeywordOrStarred
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	if p.call_invalid_rules { // invalid_kwarg
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_kwarg_var any
		condition := func() bool {
			invalid_kwarg_var = invalid_kwarg_rule(p)
			if invalid_kwarg_var == nil {
				return false
			} // invalid_kwarg
			return true
		}
		if condition() {
			_res = invalid_kwarg_var
			goto done
		}
		p.mark = _mark
	}
	{ // NAME '=' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = _PyPegen_name_token(p)
			if a == nil {
				return false
			} // NAME
			_literal = _PyPegen_expect_token(p, 22)
			if _literal == nil {
				return false
			} // token='='
			b = expression_rule(p)
			if b == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyPegen_keyword_or_starred(p, CHECK(keyword_ty, _PyAST_keyword(a.v.Name.id, b, EXTRA)), 1)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // starred_expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		condition := func() bool {
			a = starred_expression_rule(p)
			if a == nil {
				return false
			} // starred_expression
			return true
		}
		if condition() {
			_res = _PyPegen_keyword_or_starred(p, a, 0)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// kwarg_or_double_starred: invalid_kwarg | NAME '=' expression | '**' expression
func kwarg_or_double_starred_rule(p *Parser) *KeywordOrStarred {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *KeywordOrStarred
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	if p.call_invalid_rules { // invalid_kwarg
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_kwarg_var any
		condition := func() bool {
			invalid_kwarg_var = invalid_kwarg_rule(p)
			if invalid_kwarg_var == nil {
				return false
			} // invalid_kwarg
			return true
		}
		if condition() {
			_res = invalid_kwarg_var
			goto done
		}
		p.mark = _mark
	}
	{ // NAME '=' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = _PyPegen_name_token(p)
			if a == nil {
				return false
			} // NAME
			_literal = _PyPegen_expect_token(p, 22)
			if _literal == nil {
				return false
			} // token='='
			b = expression_rule(p)
			if b == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyPegen_keyword_or_starred(p, CHECK(keyword_ty, _PyAST_keyword(a.v.Name.id, b, EXTRA)), 1)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '**' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 35)
			if _literal == nil {
				return false
			} // token='**'
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyPegen_keyword_or_starred(p, CHECK(keyword_ty, _PyAST_keyword(nil, a, EXTRA)), 1)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// star_targets: star_target !',' | star_target ((',' star_target))* ','?
func star_targets_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // star_target !','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		condition := func() bool {
			a = star_target_rule(p)
			if a == nil {
				return false
			} // star_target
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 12)
			if _tmp == 0 {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // star_target ((',' star_target))* ','?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a expr_ty
		var b *asdl_seq
		condition := func() bool {
			a = star_target_rule(p)
			if a == nil {
				return false
			} // star_target
			b = _loop0_128_rule(p)
			if b == nil {
				return false
			} // ((',' star_target))*
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Tuple(CHECK(*asdl_expr_seq, _PyPegen_seq_insert_in_front(p, a, b)), Store, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// star_targets_list_seq: ','.star_target+ ','?
func star_targets_list_seq_rule(p *Parser) *asdl_expr_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_expr_seq
	_mark := p.mark
	{ // ','.star_target+ ','?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a *asdl_expr_seq
		condition := func() bool {
			a = *asdl_expr_seq_gather_129_rule(p)
			if a == nil {
				return false
			} // ','.star_target+
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// star_targets_tuple_seq: star_target ((',' star_target))+ ','? | star_target ','
func star_targets_tuple_seq_rule(p *Parser) *asdl_expr_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_expr_seq
	_mark := p.mark
	{ // star_target ((',' star_target))+ ','?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a expr_ty
		var b *asdl_seq
		condition := func() bool {
			a = star_target_rule(p)
			if a == nil {
				return false
			} // star_target
			b = _loop1_131_rule(p)
			if b == nil {
				return false
			} // ((',' star_target))+
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, a, b)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // star_target ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			a = star_target_rule(p)
			if a == nil {
				return false
			} // star_target
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = _PyPegen_singleton_seq(p, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// star_target: '*' (!'*' star_target) | target_with_star_atom
func star_target_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	if _PyPegen_is_memoized(p, star_target_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // '*' (!'*' star_target)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			a = _tmp_132_rule(p)
			if a == nil {
				return false
			} // !'*' star_target
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Starred(CHECK(expr_ty, _PyPegen_set_expr_context(p, a, Store)), Store, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // target_with_star_atom
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var target_with_star_atom_var expr_ty
		condition := func() bool {
			target_with_star_atom_var = target_with_star_atom_rule(p)
			if target_with_star_atom_var == nil {
				return false
			} // target_with_star_atom
			return true
		}
		if condition() {
			_res = target_with_star_atom_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	_PyPegen_insert_memo(p, _mark, star_target_type, _res)
	p.level--
	return _res
}

// target_with_star_atom:
//     | t_primary '.' NAME !t_lookahead
//     | t_primary '[' slices ']' !t_lookahead
//     | star_atom
func target_with_star_atom_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	if _PyPegen_is_memoized(p, target_with_star_atom_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // t_primary '.' NAME !t_lookahead
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = t_primary_rule(p)
			if a == nil {
				return false
			} // t_primary
			_literal = _PyPegen_expect_token(p, 23)
			if _literal == nil {
				return false
			} // token='.'
			b = _PyPegen_name_token(p)
			if b == nil {
				return false
			} // NAME
			_tmp := _PyPegen_lookahead(0, t_lookahead_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Attribute(a, b.v.Name.id, Store, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // t_primary '[' slices ']' !t_lookahead
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = t_primary_rule(p)
			if a == nil {
				return false
			} // t_primary
			_literal = _PyPegen_expect_token(p, 9)
			if _literal == nil {
				return false
			} // token='['
			b = slices_rule(p)
			if b == nil {
				return false
			} // slices
			_literal_1 = _PyPegen_expect_token(p, 10)
			if _literal_1 == nil {
				return false
			} // token=']'
			_tmp := _PyPegen_lookahead(0, t_lookahead_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Subscript(a, b, Store, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // star_atom
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var star_atom_var expr_ty
		condition := func() bool {
			star_atom_var = star_atom_rule(p)
			if star_atom_var == nil {
				return false
			} // star_atom
			return true
		}
		if condition() {
			_res = star_atom_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	_PyPegen_insert_memo(p, _mark, target_with_star_atom_type, _res)
	p.level--
	return _res
}

// star_atom:
//     | NAME
//     | '(' target_with_star_atom ')'
//     | '(' star_targets_tuple_seq? ')'
//     | '[' star_targets_list_seq? ']'
func star_atom_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		condition := func() bool {
			a = _PyPegen_name_token(p)
			if a == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_res = _PyPegen_set_expr_context(p, a, Store)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '(' target_with_star_atom ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			a = target_with_star_atom_rule(p)
			if a == nil {
				return false
			} // target_with_star_atom
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = _PyPegen_set_expr_context(p, a, Store)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '(' star_targets_tuple_seq? ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			a = star_targets_tuple_seq_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// star_targets_tuple_seq?
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Tuple(a, Store, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '[' star_targets_list_seq? ']'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 9)
			if _literal == nil {
				return false
			} // token='['
			a = star_targets_list_seq_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// star_targets_list_seq?
			_literal_1 = _PyPegen_expect_token(p, 10)
			if _literal_1 == nil {
				return false
			} // token=']'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_List(a, Store, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// single_target: single_subscript_attribute_target | NAME | '(' single_target ')'
func single_target_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	{ // single_subscript_attribute_target
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var single_subscript_attribute_target_var expr_ty
		condition := func() bool {
			single_subscript_attribute_target_var = single_subscript_attribute_target_rule(p)
			if single_subscript_attribute_target_var == nil {
				return false
			} // single_subscript_attribute_target
			return true
		}
		if condition() {
			_res = single_subscript_attribute_target_var
			goto done
		}
		p.mark = _mark
	}
	{ // NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		condition := func() bool {
			a = _PyPegen_name_token(p)
			if a == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_res = _PyPegen_set_expr_context(p, a, Store)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '(' single_target ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			a = single_target_rule(p)
			if a == nil {
				return false
			} // single_target
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// single_subscript_attribute_target:
//     | t_primary '.' NAME !t_lookahead
//     | t_primary '[' slices ']' !t_lookahead
func single_subscript_attribute_target_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // t_primary '.' NAME !t_lookahead
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = t_primary_rule(p)
			if a == nil {
				return false
			} // t_primary
			_literal = _PyPegen_expect_token(p, 23)
			if _literal == nil {
				return false
			} // token='.'
			b = _PyPegen_name_token(p)
			if b == nil {
				return false
			} // NAME
			_tmp := _PyPegen_lookahead(0, t_lookahead_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Attribute(a, b.v.Name.id, Store, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // t_primary '[' slices ']' !t_lookahead
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = t_primary_rule(p)
			if a == nil {
				return false
			} // t_primary
			_literal = _PyPegen_expect_token(p, 9)
			if _literal == nil {
				return false
			} // token='['
			b = slices_rule(p)
			if b == nil {
				return false
			} // slices
			_literal_1 = _PyPegen_expect_token(p, 10)
			if _literal_1 == nil {
				return false
			} // token=']'
			_tmp := _PyPegen_lookahead(0, t_lookahead_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Subscript(a, b, Store, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// Left-recursive
// t_primary:
//     | t_primary '.' NAME &t_lookahead
//     | t_primary '[' slices ']' &t_lookahead
//     | t_primary genexp &t_lookahead
//     | t_primary '(' arguments? ')' &t_lookahead
//     | atom &t_lookahead
func t_primary_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	var expr_ty _res
	if _PyPegen_is_memoized(p, t_primary_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	_resmark := p.mark
	for {
		tmpvar_9 := _PyPegen_update_memo(p, _mark, t_primary_type, _res)
		if tmpvar_9 {
			p.level--
			return _res
		}
		p.mark = _mark
		_raw := t_primary_raw(p)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		if _raw == nil || p.mark <= _resmark {
			break
		}
		_resmark = p.mark
		_res = _raw
	}
	p.mark = _resmark
	p.level--
	return _res
}
func t_primary_raw(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // t_primary '.' NAME &t_lookahead
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = t_primary_rule(p)
			if a == nil {
				return false
			} // t_primary
			_literal = _PyPegen_expect_token(p, 23)
			if _literal == nil {
				return false
			} // token='.'
			b = _PyPegen_name_token(p)
			if b == nil {
				return false
			} // NAME
			_tmp := _PyPegen_lookahead(1, t_lookahead_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Attribute(a, b.v.Name.id, Load, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // t_primary '[' slices ']' &t_lookahead
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = t_primary_rule(p)
			if a == nil {
				return false
			} // t_primary
			_literal = _PyPegen_expect_token(p, 9)
			if _literal == nil {
				return false
			} // token='['
			b = slices_rule(p)
			if b == nil {
				return false
			} // slices
			_literal_1 = _PyPegen_expect_token(p, 10)
			if _literal_1 == nil {
				return false
			} // token=']'
			_tmp := _PyPegen_lookahead(1, t_lookahead_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Subscript(a, b, Load, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // t_primary genexp &t_lookahead
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = t_primary_rule(p)
			if a == nil {
				return false
			} // t_primary
			b = genexp_rule(p)
			if b == nil {
				return false
			} // genexp
			_tmp := _PyPegen_lookahead(1, t_lookahead_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Call(a, CHECK(*asdl_expr_seq, _PyPegen_singleton_seq(p, b)), nil, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // t_primary '(' arguments? ')' &t_lookahead
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a expr_ty
		var b any
		condition := func() bool {
			a = t_primary_rule(p)
			if a == nil {
				return false
			} // t_primary
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			b = arguments_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// arguments?
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			_tmp := _PyPegen_lookahead(1, t_lookahead_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Call(a, ternary_operator(b, b.v.Call.args, nil), ternary_operator(b, b.v.Call.keywords, nil), EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // atom &t_lookahead
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		condition := func() bool {
			a = atom_rule(p)
			if a == nil {
				return false
			} // atom
			_tmp := _PyPegen_lookahead(1, t_lookahead_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// t_lookahead: '(' | '[' | '.'
func t_lookahead_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '('
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // '['
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 9)
			if _literal == nil {
				return false
			} // token='['
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // '.'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 23)
			if _literal == nil {
				return false
			} // token='.'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// del_targets: ','.del_target+ ','?
func del_targets_rule(p *Parser) *asdl_expr_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_expr_seq
	_mark := p.mark
	{ // ','.del_target+ ','?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a *asdl_expr_seq
		condition := func() bool {
			a = *asdl_expr_seq_gather_133_rule(p)
			if a == nil {
				return false
			} // ','.del_target+
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// del_target:
//     | t_primary '.' NAME !t_lookahead
//     | t_primary '[' slices ']' !t_lookahead
//     | del_t_atom
func del_target_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	if _PyPegen_is_memoized(p, del_target_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // t_primary '.' NAME !t_lookahead
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = t_primary_rule(p)
			if a == nil {
				return false
			} // t_primary
			_literal = _PyPegen_expect_token(p, 23)
			if _literal == nil {
				return false
			} // token='.'
			b = _PyPegen_name_token(p)
			if b == nil {
				return false
			} // NAME
			_tmp := _PyPegen_lookahead(0, t_lookahead_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Attribute(a, b.v.Name.id, Del, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // t_primary '[' slices ']' !t_lookahead
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = t_primary_rule(p)
			if a == nil {
				return false
			} // t_primary
			_literal = _PyPegen_expect_token(p, 9)
			if _literal == nil {
				return false
			} // token='['
			b = slices_rule(p)
			if b == nil {
				return false
			} // slices
			_literal_1 = _PyPegen_expect_token(p, 10)
			if _literal_1 == nil {
				return false
			} // token=']'
			_tmp := _PyPegen_lookahead(0, t_lookahead_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Subscript(a, b, Del, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // del_t_atom
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var del_t_atom_var expr_ty
		condition := func() bool {
			del_t_atom_var = del_t_atom_rule(p)
			if del_t_atom_var == nil {
				return false
			} // del_t_atom
			return true
		}
		if condition() {
			_res = del_t_atom_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	_PyPegen_insert_memo(p, _mark, del_target_type, _res)
	p.level--
	return _res
}

// del_t_atom: NAME | '(' del_target ')' | '(' del_targets? ')' | '[' del_targets? ']'
func del_t_atom_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		condition := func() bool {
			a = _PyPegen_name_token(p)
			if a == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_res = _PyPegen_set_expr_context(p, a, Del)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '(' del_target ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			a = del_target_rule(p)
			if a == nil {
				return false
			} // del_target
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = _PyPegen_set_expr_context(p, a, Del)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '(' del_targets? ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			a = del_targets_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// del_targets?
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_Tuple(a, Del, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '[' del_targets? ']'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 9)
			if _literal == nil {
				return false
			} // token='['
			a = del_targets_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// del_targets?
			_literal_1 = _PyPegen_expect_token(p, 10)
			if _literal_1 == nil {
				return false
			} // token=']'
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_List(a, Del, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// type_expressions:
//     | ','.expression+ ',' '*' expression ',' '**' expression
//     | ','.expression+ ',' '*' expression
//     | ','.expression+ ',' '**' expression
//     | '*' expression ',' '**' expression
//     | '*' expression
//     | '**' expression
//     | ','.expression+
func type_expressions_rule(p *Parser) *asdl_expr_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_expr_seq
	_mark := p.mark
	{ // ','.expression+ ',' '*' expression ',' '**' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var _literal_2 *Token
		var _literal_3 *Token
		var a *asdl_seq
		var b expr_ty
		var c expr_ty
		condition := func() bool {
			a = _gather_135_rule(p)
			if a == nil {
				return false
			} // ','.expression+
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			_literal_1 = _PyPegen_expect_token(p, 16)
			if _literal_1 == nil {
				return false
			} // token='*'
			b = expression_rule(p)
			if b == nil {
				return false
			} // expression
			_literal_2 = _PyPegen_expect_token(p, 12)
			if _literal_2 == nil {
				return false
			} // token=','
			_literal_3 = _PyPegen_expect_token(p, 35)
			if _literal_3 == nil {
				return false
			} // token='**'
			c = expression_rule(p)
			if c == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = _PyPegen_seq_append_to_end(p, CHECK(*asdl_seq, _PyPegen_seq_append_to_end(p, a, b)), c)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // ','.expression+ ',' '*' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a *asdl_seq
		var b expr_ty
		condition := func() bool {
			a = _gather_137_rule(p)
			if a == nil {
				return false
			} // ','.expression+
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			_literal_1 = _PyPegen_expect_token(p, 16)
			if _literal_1 == nil {
				return false
			} // token='*'
			b = expression_rule(p)
			if b == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = _PyPegen_seq_append_to_end(p, a, b)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // ','.expression+ ',' '**' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a *asdl_seq
		var b expr_ty
		condition := func() bool {
			a = _gather_139_rule(p)
			if a == nil {
				return false
			} // ','.expression+
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			_literal_1 = _PyPegen_expect_token(p, 35)
			if _literal_1 == nil {
				return false
			} // token='**'
			b = expression_rule(p)
			if b == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = _PyPegen_seq_append_to_end(p, a, b)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '*' expression ',' '**' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var _literal_2 *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			_literal_1 = _PyPegen_expect_token(p, 12)
			if _literal_1 == nil {
				return false
			} // token=','
			_literal_2 = _PyPegen_expect_token(p, 35)
			if _literal_2 == nil {
				return false
			} // token='**'
			b = expression_rule(p)
			if b == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = _PyPegen_seq_append_to_end(p, CHECK(*asdl_seq, _PyPegen_singleton_seq(p, a)), b)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '*' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = _PyPegen_singleton_seq(p, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '**' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 35)
			if _literal == nil {
				return false
			} // token='**'
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = _PyPegen_singleton_seq(p, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // ','.expression+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *asdl_expr_seq
		condition := func() bool {
			a = *asdl_expr_seq_gather_141_rule(p)
			if a == nil {
				return false
			} // ','.expression+
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// func_type_comment:
//     | NEWLINE TYPE_COMMENT &(NEWLINE INDENT)
//     | invalid_double_type_comments
//     | TYPE_COMMENT
func func_type_comment_rule(p *Parser) *Token {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *Token
	_mark := p.mark
	{ // NEWLINE TYPE_COMMENT &(NEWLINE INDENT)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var newline_var *Token
		var t *Token
		condition := func() bool {
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			t = _PyPegen_expect_token(p, TYPE_COMMENT)
			if t == nil {
				return false
			} // token='TYPE_COMMENT'
			_tmp := _PyPegen_lookahead(1, _tmp_143_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_res = t
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	if p.call_invalid_rules { // invalid_double_type_comments
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var invalid_double_type_comments_var any
		condition := func() bool {
			invalid_double_type_comments_var = invalid_double_type_comments_rule(p)
			if invalid_double_type_comments_var == nil {
				return false
			} // invalid_double_type_comments
			return true
		}
		if condition() {
			_res = invalid_double_type_comments_var
			goto done
		}
		p.mark = _mark
	}
	{ // TYPE_COMMENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var type_comment_var *Token
		condition := func() bool {
			type_comment_var = _PyPegen_expect_token(p, TYPE_COMMENT)
			if type_comment_var == nil {
				return false
			} // token='TYPE_COMMENT'
			return true
		}
		if condition() {
			_res = type_comment_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_arguments:
//     | args ',' '*'
//     | expression for_if_clauses ',' [args | expression for_if_clauses]
//     | NAME '=' expression for_if_clauses
//     | args for_if_clauses
//     | args ',' expression for_if_clauses
//     | args ',' args
func invalid_arguments_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // args ',' '*'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a expr_ty
		condition := func() bool {
			a = args_rule(p)
			if a == nil {
				return false
			} // args
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			_literal_1 = _PyPegen_expect_token(p, 16)
			if _literal_1 == nil {
				return false
			} // token='*'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "iterable argument unpacking follows keyword argument unpacking")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // expression for_if_clauses ',' [args | expression for_if_clauses]
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a expr_ty
		var b *asdl_comprehension_seq
		condition := func() bool {
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			b = for_if_clauses_rule(p)
			if b == nil {
				return false
			} // for_if_clauses
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			_opt_var = _tmp_144_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// [args | expression for_if_clauses]
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, _PyPegen_get_last_comprehension_item(PyPegen_last_item(b, comprehension_ty)), "Generator expression must be parenthesized")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // NAME '=' expression for_if_clauses
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		var b *Token
		var expression_var expr_ty
		var for_if_clauses_var *asdl_comprehension_seq
		condition := func() bool {
			a = _PyPegen_name_token(p)
			if a == nil {
				return false
			} // NAME
			b = _PyPegen_expect_token(p, 22)
			if b == nil {
				return false
			} // token='='
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			for_if_clauses_var = for_if_clauses_rule(p)
			if for_if_clauses_var == nil {
				return false
			} // for_if_clauses
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b, "invalid syntax. Maybe you meant '==' or ':=' instead of '='?")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // args for_if_clauses
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		var b *asdl_comprehension_seq
		condition := func() bool {
			a = args_rule(p)
			if a == nil {
				return false
			} // args
			b = for_if_clauses_rule(p)
			if b == nil {
				return false
			} // for_if_clauses
			return true
		}
		if condition() {
			_res = _PyPegen_nonparen_genexp_in_call(p, a, b)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // args ',' expression for_if_clauses
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var args_var expr_ty
		var b *asdl_comprehension_seq
		condition := func() bool {
			args_var = args_rule(p)
			if args_var == nil {
				return false
			} // args
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			b = for_if_clauses_rule(p)
			if b == nil {
				return false
			} // for_if_clauses
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, _PyPegen_get_last_comprehension_item(PyPegen_last_item(b, comprehension_ty)), "Generator expression must be parenthesized")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // args ',' args
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var args_var expr_ty
		condition := func() bool {
			a = args_rule(p)
			if a == nil {
				return false
			} // args
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			args_var = args_rule(p)
			if args_var == nil {
				return false
			} // args
			return true
		}
		if condition() {
			_res = _PyPegen_arguments_parsing_error(p, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_kwarg:
//     | ('True' | 'False' | 'None') '='
//     | NAME '=' expression for_if_clauses
//     | !(NAME '=') expression '='
func invalid_kwarg_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ('True' | 'False' | 'None') '='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *Token
		var b *Token
		condition := func() bool {
			a = *Token_tmp_145_rule(p)
			if a == nil {
				return false
			} // 'True' | 'False' | 'None'
			b = _PyPegen_expect_token(p, 22)
			if b == nil {
				return false
			} // token='='
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b, "cannot assign to %s", PyBytes_AS_STRING(a.bytes))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // NAME '=' expression for_if_clauses
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		var b *Token
		var expression_var expr_ty
		var for_if_clauses_var *asdl_comprehension_seq
		condition := func() bool {
			a = _PyPegen_name_token(p)
			if a == nil {
				return false
			} // NAME
			b = _PyPegen_expect_token(p, 22)
			if b == nil {
				return false
			} // token='='
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			for_if_clauses_var = for_if_clauses_rule(p)
			if for_if_clauses_var == nil {
				return false
			} // for_if_clauses
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b, "invalid syntax. Maybe you meant '==' or ':=' instead of '='?")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // !(NAME '=') expression '='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		var b *Token
		condition := func() bool {
			_tmp := _PyPegen_lookahead(0, _tmp_146_rule, p)
			if _tmp == 0 {
				return false
			}
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			b = _PyPegen_expect_token(p, 22)
			if b == nil {
				return false
			} // token='='
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b, "expression cannot contain assignment, perhaps you meant \"==\"?")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// expression_without_invalid:
//     | disjunction 'if' disjunction 'else' expression
//     | disjunction
//     | lambdef
func expression_without_invalid_rule(p *Parser) expr_ty {
	_prev_call_invalid := p.call_invalid_rules
	p.call_invalid_rules = 0
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.call_invalid_rules = _prev_call_invalid
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	if p.mark == p.fill && _PyPegen_fill_token(p) < 0 {
		p.error_indicator = 1
		p.call_invalid_rules = _prev_call_invalid
		p.level--
		return nil
	}
	_start_lineno := p.tokens[_mark].lineno
	UNUSED(_start_lineno) // Only used by EXTRA macro
	_start_col_offset := p.tokens[_mark].col_offset
	UNUSED(_start_col_offset) // Only used by EXTRA macro
	{                         // disjunction 'if' disjunction 'else' expression
		if p.error_indicator > 0 {
			p.call_invalid_rules = _prev_call_invalid
			p.level--
			return nil
		}
		var _keyword *Token
		var _keyword_1 *Token
		var a expr_ty
		var b expr_ty
		var c expr_ty
		condition := func() bool {
			a = disjunction_rule(p)
			if a == nil {
				return false
			} // disjunction
			_keyword = _PyPegen_expect_token(p, 639)
			if _keyword == nil {
				return false
			} // token='if'
			b = disjunction_rule(p)
			if b == nil {
				return false
			} // disjunction
			_keyword_1 = _PyPegen_expect_token(p, 642)
			if _keyword_1 == nil {
				return false
			} // token='else'
			c = expression_rule(p)
			if c == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_token := _PyPegen_get_last_nonnwhitespace_token(p)
			if _token == nil {
				p.call_invalid_rules = _prev_call_invalid
				p.level--
				return nil
			}
			_end_lineno := _token.end_lineno
			UNUSED(_end_lineno) // Only used by EXTRA macro
			_end_col_offset := _token.end_col_offset
			UNUSED(_end_col_offset) // Only used by EXTRA macro
			_res = _PyAST_IfExp(b, a, c, EXTRA)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.call_invalid_rules = _prev_call_invalid
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // disjunction
		if p.error_indicator > 0 {
			p.call_invalid_rules = _prev_call_invalid
			p.level--
			return nil
		}
		var disjunction_var expr_ty
		condition := func() bool {
			disjunction_var = disjunction_rule(p)
			if disjunction_var == nil {
				return false
			} // disjunction
			return true
		}
		if condition() {
			_res = disjunction_var
			goto done
		}
		p.mark = _mark
	}
	{ // lambdef
		if p.error_indicator > 0 {
			p.call_invalid_rules = _prev_call_invalid
			p.level--
			return nil
		}
		var lambdef_var expr_ty
		condition := func() bool {
			lambdef_var = lambdef_rule(p)
			if lambdef_var == nil {
				return false
			} // lambdef
			return true
		}
		if condition() {
			_res = lambdef_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.call_invalid_rules = _prev_call_invalid
	p.level--
	return _res
}

// invalid_legacy_expression: NAME !'(' star_expressions
func invalid_legacy_expression_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // NAME !'(' star_expressions
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = _PyPegen_name_token(p)
			if a == nil {
				return false
			} // NAME
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 7)
			if _tmp == 0 {
				return false
			} // token='('
			b = star_expressions_rule(p)
			if b == nil {
				return false
			} // star_expressions
			return true
		}
		if condition() {
			_res = ternary_operator(_PyPegen_check_legacy_stmt(p, a), RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b, "Missing parentheses in call to '%U'. Did you mean %U(...)?", a.v.Name.id, a.v.Name.id), nil)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_expression:
//     | !(NAME STRING | SOFT_KEYWORD) disjunction expression_without_invalid
//     | disjunction 'if' disjunction !('else' | ':')
func invalid_expression_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // !(NAME STRING | SOFT_KEYWORD) disjunction expression_without_invalid
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			_tmp := _PyPegen_lookahead(0, _tmp_147_rule, p)
			if _tmp == 0 {
				return false
			}
			a = disjunction_rule(p)
			if a == nil {
				return false
			} // disjunction
			b = expression_without_invalid_rule(p)
			if b == nil {
				return false
			} // expression_without_invalid
			return true
		}
		if condition() {
			_res = ternary_operator(_PyPegen_check_legacy_stmt(p, a), nil, ternary_operator(p.tokens[p.mark-1].level == 0, nil, RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b, "invalid syntax. Perhaps you forgot a comma?")))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // disjunction 'if' disjunction !('else' | ':')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = disjunction_rule(p)
			if a == nil {
				return false
			} // disjunction
			_keyword = _PyPegen_expect_token(p, 639)
			if _keyword == nil {
				return false
			} // token='if'
			b = disjunction_rule(p)
			if b == nil {
				return false
			} // disjunction
			_tmp := _PyPegen_lookahead(0, _tmp_148_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b, "expected 'else' after 'if' expression")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_named_expression:
//     | expression ':=' expression
//     | NAME '=' bitwise_or !('=' | ':=')
//     | !(list | tuple | genexp | 'True' | 'None' | 'False') bitwise_or '=' bitwise_or !('=' | ':=')
func invalid_named_expression_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	if _PyPegen_is_memoized(p, invalid_named_expression_type, &_res) {
		p.level--
		return _res
	}
	_mark := p.mark
	{ // expression ':=' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var expression_var expr_ty
		condition := func() bool {
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			_literal = _PyPegen_expect_token(p, 53)
			if _literal == nil {
				return false
			} // token=':='
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "cannot use assignment expressions with %s", _PyPegen_get_expr_name(a))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // NAME '=' bitwise_or !('=' | ':=')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var b expr_ty
		condition := func() bool {
			a = _PyPegen_name_token(p)
			if a == nil {
				return false
			} // NAME
			_literal = _PyPegen_expect_token(p, 22)
			if _literal == nil {
				return false
			} // token='='
			b = bitwise_or_rule(p)
			if b == nil {
				return false
			} // bitwise_or
			_tmp := _PyPegen_lookahead(0, _tmp_149_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b, "invalid syntax. Maybe you meant '==' or ':=' instead of '='?")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // !(list | tuple | genexp | 'True' | 'None' | 'False') bitwise_or '=' bitwise_or !('=' | ':=')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		var b *Token
		var bitwise_or_var expr_ty
		condition := func() bool {
			_tmp := _PyPegen_lookahead(0, _tmp_150_rule, p)
			if _tmp == 0 {
				return false
			}
			a = bitwise_or_rule(p)
			if a == nil {
				return false
			} // bitwise_or
			b = _PyPegen_expect_token(p, 22)
			if b == nil {
				return false
			} // token='='
			bitwise_or_var = bitwise_or_rule(p)
			if bitwise_or_var == nil {
				return false
			} // bitwise_or
			_tmp := _PyPegen_lookahead(0, _tmp_151_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "cannot assign to %s here. Maybe you meant '==' instead of '='?", _PyPegen_get_expr_name(a))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	_PyPegen_insert_memo(p, _mark, invalid_named_expression_type, _res)
	p.level--
	return _res
}

// invalid_assignment:
//     | invalid_ann_assign_target ':' expression
//     | star_named_expression ',' star_named_expressions* ':' expression
//     | expression ':' expression
//     | ((star_targets '='))* star_expressions '='
//     | ((star_targets '='))* yield_expr '='
//     | star_expressions augassign (yield_expr | star_expressions)
func invalid_assignment_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // invalid_ann_assign_target ':' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var expression_var expr_ty
		condition := func() bool {
			a = invalid_ann_assign_target_rule(p)
			if a == nil {
				return false
			} // invalid_ann_assign_target
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "only single target (not %s) can be annotated", _PyPegen_get_expr_name(a))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // star_named_expression ',' star_named_expressions* ':' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var _loop0_152_var *asdl_seq
		var a expr_ty
		var expression_var expr_ty
		condition := func() bool {
			a = star_named_expression_rule(p)
			if a == nil {
				return false
			} // star_named_expression
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			_loop0_152_var = _loop0_152_rule(p)
			if _loop0_152_var == nil {
				return false
			} // star_named_expressions*
			_literal_1 = _PyPegen_expect_token(p, 11)
			if _literal_1 == nil {
				return false
			} // token=':'
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "only single target (not tuple) can be annotated")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // expression ':' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var expression_var expr_ty
		condition := func() bool {
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "illegal target for annotation")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // ((star_targets '='))* star_expressions '='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _loop0_153_var *asdl_seq
		var a expr_ty
		condition := func() bool {
			_loop0_153_var = _loop0_153_rule(p)
			if _loop0_153_var == nil {
				return false
			} // ((star_targets '='))*
			a = star_expressions_rule(p)
			if a == nil {
				return false
			} // star_expressions
			_literal = _PyPegen_expect_token(p, 22)
			if _literal == nil {
				return false
			} // token='='
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_INVALID_TARGET(STAR_TARGETS, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // ((star_targets '='))* yield_expr '='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _loop0_154_var *asdl_seq
		var a expr_ty
		condition := func() bool {
			_loop0_154_var = _loop0_154_rule(p)
			if _loop0_154_var == nil {
				return false
			} // ((star_targets '='))*
			a = yield_expr_rule(p)
			if a == nil {
				return false
			} // yield_expr
			_literal = _PyPegen_expect_token(p, 22)
			if _literal == nil {
				return false
			} // token='='
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "assignment to yield expression not possible")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // star_expressions augassign (yield_expr | star_expressions)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_155_var any
		var a expr_ty
		var augassign_var *AugOperator
		condition := func() bool {
			a = star_expressions_rule(p)
			if a == nil {
				return false
			} // star_expressions
			augassign_var = augassign_rule(p)
			if augassign_var == nil {
				return false
			} // augassign
			_tmp_155_var = _tmp_155_rule(p)
			if _tmp_155_var == nil {
				return false
			} // yield_expr | star_expressions
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "'%s' is an illegal expression for augmented assignment", _PyPegen_get_expr_name(a))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_ann_assign_target: list | tuple | '(' invalid_ann_assign_target ')'
func invalid_ann_assign_target_rule(p *Parser) expr_ty {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res expr_ty
	_mark := p.mark
	{ // list
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var list_var expr_ty
		condition := func() bool {
			list_var = list_rule(p)
			if list_var == nil {
				return false
			} // list
			return true
		}
		if condition() {
			_res = list_var
			goto done
		}
		p.mark = _mark
	}
	{ // tuple
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var tuple_var expr_ty
		condition := func() bool {
			tuple_var = tuple_rule(p)
			if tuple_var == nil {
				return false
			} // tuple
			return true
		}
		if condition() {
			_res = tuple_var
			goto done
		}
		p.mark = _mark
	}
	{ // '(' invalid_ann_assign_target ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			a = invalid_ann_assign_target_rule(p)
			if a == nil {
				return false
			} // invalid_ann_assign_target
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_del_stmt: 'del' star_expressions
func invalid_del_stmt_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'del' star_expressions
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var a expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 603)
			if _keyword == nil {
				return false
			} // token='del'
			a = star_expressions_rule(p)
			if a == nil {
				return false
			} // star_expressions
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_INVALID_TARGET(DEL_TARGETS, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_block: NEWLINE !INDENT
func invalid_block_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // NEWLINE !INDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var newline_var *Token
		condition := func() bool {
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)
			if _tmp == 0 {
				return false
			} // token=INDENT
			return true
		}
		if condition() {
			_res = RAISE_INDENTATION_ERROR("expected an indented block")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_comprehension:
//     | ('[' | '(' | '{') starred_expression for_if_clauses
//     | ('[' | '{') star_named_expression ',' star_named_expressions for_if_clauses
//     | ('[' | '{') star_named_expression ',' for_if_clauses
func invalid_comprehension_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ('[' | '(' | '{') starred_expression for_if_clauses
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_156_var any
		var a expr_ty
		var for_if_clauses_var *asdl_comprehension_seq
		condition := func() bool {
			_tmp_156_var = _tmp_156_rule(p)
			if _tmp_156_var == nil {
				return false
			} // '[' | '(' | '{'
			a = starred_expression_rule(p)
			if a == nil {
				return false
			} // starred_expression
			for_if_clauses_var = for_if_clauses_rule(p)
			if for_if_clauses_var == nil {
				return false
			} // for_if_clauses
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "iterable unpacking cannot be used in comprehension")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // ('[' | '{') star_named_expression ',' star_named_expressions for_if_clauses
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _tmp_157_var any
		var a expr_ty
		var b *asdl_expr_seq
		var for_if_clauses_var *asdl_comprehension_seq
		condition := func() bool {
			_tmp_157_var = _tmp_157_rule(p)
			if _tmp_157_var == nil {
				return false
			} // '[' | '{'
			a = star_named_expression_rule(p)
			if a == nil {
				return false
			} // star_named_expression
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			b = star_named_expressions_rule(p)
			if b == nil {
				return false
			} // star_named_expressions
			for_if_clauses_var = for_if_clauses_rule(p)
			if for_if_clauses_var == nil {
				return false
			} // for_if_clauses
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, PyPegen_last_item(b, expr_ty), "did you forget parentheses around the comprehension target?")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // ('[' | '{') star_named_expression ',' for_if_clauses
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_158_var any
		var a expr_ty
		var b *Token
		var for_if_clauses_var *asdl_comprehension_seq
		condition := func() bool {
			_tmp_158_var = _tmp_158_rule(p)
			if _tmp_158_var == nil {
				return false
			} // '[' | '{'
			a = star_named_expression_rule(p)
			if a == nil {
				return false
			} // star_named_expression
			b = _PyPegen_expect_token(p, 12)
			if b == nil {
				return false
			} // token=','
			for_if_clauses_var = for_if_clauses_rule(p)
			if for_if_clauses_var == nil {
				return false
			} // for_if_clauses
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b, "did you forget parentheses around the comprehension target?")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_dict_comprehension: '{' '**' bitwise_or for_if_clauses '}'
func invalid_dict_comprehension_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '{' '**' bitwise_or for_if_clauses '}'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a *Token
		var bitwise_or_var expr_ty
		var for_if_clauses_var *asdl_comprehension_seq
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 25)
			if _literal == nil {
				return false
			} // token='{'
			a = _PyPegen_expect_token(p, 35)
			if a == nil {
				return false
			} // token='**'
			bitwise_or_var = bitwise_or_rule(p)
			if bitwise_or_var == nil {
				return false
			} // bitwise_or
			for_if_clauses_var = for_if_clauses_rule(p)
			if for_if_clauses_var == nil {
				return false
			} // for_if_clauses
			_literal_1 = _PyPegen_expect_token(p, 26)
			if _literal_1 == nil {
				return false
			} // token='}'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "dict unpacking cannot be used in dict comprehension")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_parameters:
//     | param_no_default* invalid_parameters_helper param_no_default
//     | param_no_default* '(' param_no_default+ ','? ')'
//     | "/" ','
//     | (slash_no_default | slash_with_default) param_maybe_default* '/'
//     | [(slash_no_default | slash_with_default)] param_maybe_default* '*' (',' | param_no_default) param_maybe_default* '/'
//     | param_maybe_default+ '/' '*'
func invalid_parameters_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // param_no_default* invalid_parameters_helper param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _loop0_159_var *asdl_seq
		var a arg_ty
		var invalid_parameters_helper_var any
		condition := func() bool {
			_loop0_159_var = _loop0_159_rule(p)
			if _loop0_159_var == nil {
				return false
			} // param_no_default*
			invalid_parameters_helper_var = invalid_parameters_helper_rule(p)
			if invalid_parameters_helper_var == nil {
				return false
			} // invalid_parameters_helper
			a = param_no_default_rule(p)
			if a == nil {
				return false
			} // param_no_default
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "non-default argument follows default argument")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // param_no_default* '(' param_no_default+ ','? ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _loop0_160_var *asdl_seq
		var _loop1_161_var *asdl_seq
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a *Token
		var b *Token
		condition := func() bool {
			_loop0_160_var = _loop0_160_rule(p)
			if _loop0_160_var == nil {
				return false
			} // param_no_default*
			a = _PyPegen_expect_token(p, 7)
			if a == nil {
				return false
			} // token='('
			_loop1_161_var = _loop1_161_rule(p)
			if _loop1_161_var == nil {
				return false
			} // param_no_default+
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			b = _PyPegen_expect_token(p, 8)
			if b == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b, "Function parameters cannot be parenthesized")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // "/" ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *Token
		condition := func() bool {
			a = _PyPegen_expect_token(p, 17)
			if a == nil {
				return false
			} // token='/'
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "at least one argument must precede /")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // (slash_no_default | slash_with_default) param_maybe_default* '/'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _loop0_163_var *asdl_seq
		var _tmp_162_var any
		var a *Token
		condition := func() bool {
			_tmp_162_var = _tmp_162_rule(p)
			if _tmp_162_var == nil {
				return false
			} // slash_no_default | slash_with_default
			_loop0_163_var = _loop0_163_rule(p)
			if _loop0_163_var == nil {
				return false
			} // param_maybe_default*
			a = _PyPegen_expect_token(p, 17)
			if a == nil {
				return false
			} // token='/'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "/ may appear only once")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // [(slash_no_default | slash_with_default)] param_maybe_default* '*' (',' | param_no_default) param_maybe_default* '/'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _loop0_165_var *asdl_seq
		var _loop0_167_var *asdl_seq
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var _tmp_166_var any
		var a *Token
		condition := func() bool {
			_opt_var = _tmp_164_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// [(slash_no_default | slash_with_default)]
			_loop0_165_var = _loop0_165_rule(p)
			if _loop0_165_var == nil {
				return false
			} // param_maybe_default*
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			_tmp_166_var = _tmp_166_rule(p)
			if _tmp_166_var == nil {
				return false
			} // ',' | param_no_default
			_loop0_167_var = _loop0_167_rule(p)
			if _loop0_167_var == nil {
				return false
			} // param_maybe_default*
			a = _PyPegen_expect_token(p, 17)
			if a == nil {
				return false
			} // token='/'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "/ must be ahead of *")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // param_maybe_default+ '/' '*'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _loop1_168_var *asdl_seq
		var a *Token
		condition := func() bool {
			_loop1_168_var = _loop1_168_rule(p)
			if _loop1_168_var == nil {
				return false
			} // param_maybe_default+
			_literal = _PyPegen_expect_token(p, 17)
			if _literal == nil {
				return false
			} // token='/'
			a = _PyPegen_expect_token(p, 16)
			if a == nil {
				return false
			} // token='*'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "expected comma between / and *")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_default: '=' &(')' | ',')
func invalid_default_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '=' &(')' | ',')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *Token
		condition := func() bool {
			a = _PyPegen_expect_token(p, 22)
			if a == nil {
				return false
			} // token='='
			_tmp := _PyPegen_lookahead(1, _tmp_169_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "expected default value expression")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_star_etc:
//     | '*' (')' | ',' (')' | '**'))
//     | '*' ',' TYPE_COMMENT
//     | '*' param '='
//     | '*' (param_no_default | ',') param_maybe_default* '*' (param_no_default | ',')
func invalid_star_etc_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '*' (')' | ',' (')' | '**'))
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_170_var any
		var a *Token
		condition := func() bool {
			a = _PyPegen_expect_token(p, 16)
			if a == nil {
				return false
			} // token='*'
			_tmp_170_var = _tmp_170_rule(p)
			if _tmp_170_var == nil {
				return false
			} // ')' | ',' (')' | '**')
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "named arguments must follow bare *")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '*' ',' TYPE_COMMENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var type_comment_var *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			_literal_1 = _PyPegen_expect_token(p, 12)
			if _literal_1 == nil {
				return false
			} // token=','
			type_comment_var = _PyPegen_expect_token(p, TYPE_COMMENT)
			if type_comment_var == nil {
				return false
			} // token='TYPE_COMMENT'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR("bare * has associated type comment")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '*' param '='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *Token
		var param_var arg_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			param_var = param_rule(p)
			if param_var == nil {
				return false
			} // param
			a = _PyPegen_expect_token(p, 22)
			if a == nil {
				return false
			} // token='='
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "var-positional argument cannot have default value")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '*' (param_no_default | ',') param_maybe_default* '*' (param_no_default | ',')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _loop0_172_var *asdl_seq
		var _tmp_171_var any
		var _tmp_173_var any
		var a *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			_tmp_171_var = _tmp_171_rule(p)
			if _tmp_171_var == nil {
				return false
			} // param_no_default | ','
			_loop0_172_var = _loop0_172_rule(p)
			if _loop0_172_var == nil {
				return false
			} // param_maybe_default*
			a = _PyPegen_expect_token(p, 16)
			if a == nil {
				return false
			} // token='*'
			_tmp_173_var = _tmp_173_rule(p)
			if _tmp_173_var == nil {
				return false
			} // param_no_default | ','
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "* argument may appear only once")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_kwds: '**' param '=' | '**' param ',' param | '**' param ',' ('*' | '**' | '/')
func invalid_kwds_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '**' param '='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *Token
		var param_var arg_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 35)
			if _literal == nil {
				return false
			} // token='**'
			param_var = param_rule(p)
			if param_var == nil {
				return false
			} // param
			a = _PyPegen_expect_token(p, 22)
			if a == nil {
				return false
			} // token='='
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "var-keyword argument cannot have default value")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '**' param ',' param
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a arg_ty
		var param_var arg_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 35)
			if _literal == nil {
				return false
			} // token='**'
			param_var = param_rule(p)
			if param_var == nil {
				return false
			} // param
			_literal_1 = _PyPegen_expect_token(p, 12)
			if _literal_1 == nil {
				return false
			} // token=','
			a = param_rule(p)
			if a == nil {
				return false
			} // param
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "arguments cannot follow var-keyword argument")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '**' param ',' ('*' | '**' | '/')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a *Token
		var param_var arg_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 35)
			if _literal == nil {
				return false
			} // token='**'
			param_var = param_rule(p)
			if param_var == nil {
				return false
			} // param
			_literal_1 = _PyPegen_expect_token(p, 12)
			if _literal_1 == nil {
				return false
			} // token=','
			a = *Token_tmp_174_rule(p)
			if a == nil {
				return false
			} // '*' | '**' | '/'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "arguments cannot follow var-keyword argument")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_parameters_helper: slash_with_default | param_with_default+
func invalid_parameters_helper_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // slash_with_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *SlashWithDefault
		condition := func() bool {
			a = slash_with_default_rule(p)
			if a == nil {
				return false
			} // slash_with_default
			return true
		}
		if condition() {
			_res = _PyPegen_singleton_seq(p, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // param_with_default+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _loop1_175_var *asdl_seq
		condition := func() bool {
			_loop1_175_var = _loop1_175_rule(p)
			if _loop1_175_var == nil {
				return false
			} // param_with_default+
			return true
		}
		if condition() {
			_res = _loop1_175_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_lambda_parameters:
//     | lambda_param_no_default* invalid_lambda_parameters_helper lambda_param_no_default
//     | lambda_param_no_default* '(' ','.lambda_param+ ','? ')'
//     | "/" ','
//     | (lambda_slash_no_default | lambda_slash_with_default) lambda_param_maybe_default* '/'
//     | [(lambda_slash_no_default | lambda_slash_with_default)] lambda_param_maybe_default* '*' (',' | lambda_param_no_default) lambda_param_maybe_default* '/'
//     | lambda_param_maybe_default+ '/' '*'
func invalid_lambda_parameters_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // lambda_param_no_default* invalid_lambda_parameters_helper lambda_param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _loop0_176_var *asdl_seq
		var a arg_ty
		var invalid_lambda_parameters_helper_var any
		condition := func() bool {
			_loop0_176_var = _loop0_176_rule(p)
			if _loop0_176_var == nil {
				return false
			} // lambda_param_no_default*
			invalid_lambda_parameters_helper_var = invalid_lambda_parameters_helper_rule(p)
			if invalid_lambda_parameters_helper_var == nil {
				return false
			} // invalid_lambda_parameters_helper
			a = lambda_param_no_default_rule(p)
			if a == nil {
				return false
			} // lambda_param_no_default
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "non-default argument follows default argument")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // lambda_param_no_default* '(' ','.lambda_param+ ','? ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _gather_178_var *asdl_seq
		var _loop0_177_var *asdl_seq
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a *Token
		var b *Token
		condition := func() bool {
			_loop0_177_var = _loop0_177_rule(p)
			if _loop0_177_var == nil {
				return false
			} // lambda_param_no_default*
			a = _PyPegen_expect_token(p, 7)
			if a == nil {
				return false
			} // token='('
			_gather_178_var = _gather_178_rule(p)
			if _gather_178_var == nil {
				return false
			} // ','.lambda_param+
			_opt_var = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			b = _PyPegen_expect_token(p, 8)
			if b == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b, "Lambda expression parameters cannot be parenthesized")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // "/" ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *Token
		condition := func() bool {
			a = _PyPegen_expect_token(p, 17)
			if a == nil {
				return false
			} // token='/'
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "at least one argument must precede /")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // (lambda_slash_no_default | lambda_slash_with_default) lambda_param_maybe_default* '/'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _loop0_181_var *asdl_seq
		var _tmp_180_var any
		var a *Token
		condition := func() bool {
			_tmp_180_var = _tmp_180_rule(p)
			if _tmp_180_var == nil {
				return false
			} // lambda_slash_no_default | lambda_slash_with_default
			_loop0_181_var = _loop0_181_rule(p)
			if _loop0_181_var == nil {
				return false
			} // lambda_param_maybe_default*
			a = _PyPegen_expect_token(p, 17)
			if a == nil {
				return false
			} // token='/'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "/ may appear only once")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // [(lambda_slash_no_default | lambda_slash_with_default)] lambda_param_maybe_default* '*' (',' | lambda_param_no_default) lambda_param_maybe_default* '/'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _loop0_183_var *asdl_seq
		var _loop0_185_var *asdl_seq
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var _tmp_184_var any
		var a *Token
		condition := func() bool {
			_opt_var = _tmp_182_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// [(lambda_slash_no_default | lambda_slash_with_default)]
			_loop0_183_var = _loop0_183_rule(p)
			if _loop0_183_var == nil {
				return false
			} // lambda_param_maybe_default*
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			_tmp_184_var = _tmp_184_rule(p)
			if _tmp_184_var == nil {
				return false
			} // ',' | lambda_param_no_default
			_loop0_185_var = _loop0_185_rule(p)
			if _loop0_185_var == nil {
				return false
			} // lambda_param_maybe_default*
			a = _PyPegen_expect_token(p, 17)
			if a == nil {
				return false
			} // token='/'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "/ must be ahead of *")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // lambda_param_maybe_default+ '/' '*'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _loop1_186_var *asdl_seq
		var a *Token
		condition := func() bool {
			_loop1_186_var = _loop1_186_rule(p)
			if _loop1_186_var == nil {
				return false
			} // lambda_param_maybe_default+
			_literal = _PyPegen_expect_token(p, 17)
			if _literal == nil {
				return false
			} // token='/'
			a = _PyPegen_expect_token(p, 16)
			if a == nil {
				return false
			} // token='*'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "expected comma between / and *")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_lambda_parameters_helper:
//     | lambda_slash_with_default
//     | lambda_param_with_default+
func invalid_lambda_parameters_helper_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // lambda_slash_with_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *SlashWithDefault
		condition := func() bool {
			a = lambda_slash_with_default_rule(p)
			if a == nil {
				return false
			} // lambda_slash_with_default
			return true
		}
		if condition() {
			_res = _PyPegen_singleton_seq(p, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // lambda_param_with_default+
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _loop1_187_var *asdl_seq
		condition := func() bool {
			_loop1_187_var = _loop1_187_rule(p)
			if _loop1_187_var == nil {
				return false
			} // lambda_param_with_default+
			return true
		}
		if condition() {
			_res = _loop1_187_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_lambda_star_etc:
//     | '*' (':' | ',' (':' | '**'))
//     | '*' lambda_param '='
//     | '*' (lambda_param_no_default | ',') lambda_param_maybe_default* '*' (lambda_param_no_default | ',')
func invalid_lambda_star_etc_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '*' (':' | ',' (':' | '**'))
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _tmp_188_var any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			_tmp_188_var = _tmp_188_rule(p)
			if _tmp_188_var == nil {
				return false
			} // ':' | ',' (':' | '**')
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR("named arguments must follow bare *")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '*' lambda_param '='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *Token
		var lambda_param_var arg_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			lambda_param_var = lambda_param_rule(p)
			if lambda_param_var == nil {
				return false
			} // lambda_param
			a = _PyPegen_expect_token(p, 22)
			if a == nil {
				return false
			} // token='='
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "var-positional argument cannot have default value")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '*' (lambda_param_no_default | ',') lambda_param_maybe_default* '*' (lambda_param_no_default | ',')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _loop0_190_var *asdl_seq
		var _tmp_189_var any
		var _tmp_191_var any
		var a *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			_tmp_189_var = _tmp_189_rule(p)
			if _tmp_189_var == nil {
				return false
			} // lambda_param_no_default | ','
			_loop0_190_var = _loop0_190_rule(p)
			if _loop0_190_var == nil {
				return false
			} // lambda_param_maybe_default*
			a = _PyPegen_expect_token(p, 16)
			if a == nil {
				return false
			} // token='*'
			_tmp_191_var = _tmp_191_rule(p)
			if _tmp_191_var == nil {
				return false
			} // lambda_param_no_default | ','
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "* argument may appear only once")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_lambda_kwds:
//     | '**' lambda_param '='
//     | '**' lambda_param ',' lambda_param
//     | '**' lambda_param ',' ('*' | '**' | '/')
func invalid_lambda_kwds_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '**' lambda_param '='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *Token
		var lambda_param_var arg_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 35)
			if _literal == nil {
				return false
			} // token='**'
			lambda_param_var = lambda_param_rule(p)
			if lambda_param_var == nil {
				return false
			} // lambda_param
			a = _PyPegen_expect_token(p, 22)
			if a == nil {
				return false
			} // token='='
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "var-keyword argument cannot have default value")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '**' lambda_param ',' lambda_param
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a arg_ty
		var lambda_param_var arg_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 35)
			if _literal == nil {
				return false
			} // token='**'
			lambda_param_var = lambda_param_rule(p)
			if lambda_param_var == nil {
				return false
			} // lambda_param
			_literal_1 = _PyPegen_expect_token(p, 12)
			if _literal_1 == nil {
				return false
			} // token=','
			a = lambda_param_rule(p)
			if a == nil {
				return false
			} // lambda_param
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "arguments cannot follow var-keyword argument")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '**' lambda_param ',' ('*' | '**' | '/')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a *Token
		var lambda_param_var arg_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 35)
			if _literal == nil {
				return false
			} // token='**'
			lambda_param_var = lambda_param_rule(p)
			if lambda_param_var == nil {
				return false
			} // lambda_param
			_literal_1 = _PyPegen_expect_token(p, 12)
			if _literal_1 == nil {
				return false
			} // token=','
			a = *Token_tmp_192_rule(p)
			if a == nil {
				return false
			} // '*' | '**' | '/'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "arguments cannot follow var-keyword argument")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_double_type_comments: TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT
func invalid_double_type_comments_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var indent_var *Token
		var newline_var *Token
		var newline_var_1 *Token
		var type_comment_var *Token
		var type_comment_var_1 *Token
		condition := func() bool {
			type_comment_var = _PyPegen_expect_token(p, TYPE_COMMENT)
			if type_comment_var == nil {
				return false
			} // token='TYPE_COMMENT'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			type_comment_var_1 = _PyPegen_expect_token(p, TYPE_COMMENT)
			if type_comment_var_1 == nil {
				return false
			} // token='TYPE_COMMENT'
			newline_var_1 = _PyPegen_expect_token(p, NEWLINE)
			if newline_var_1 == nil {
				return false
			} // token='NEWLINE'
			indent_var = _PyPegen_expect_token(p, INDENT)
			if indent_var == nil {
				return false
			} // token='INDENT'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR("Cannot have two type comments on def")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_with_item: expression 'as' expression &(',' | ')' | ':')
func invalid_with_item_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // expression 'as' expression &(',' | ')' | ':')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var a expr_ty
		var expression_var expr_ty
		condition := func() bool {
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			_keyword = _PyPegen_expect_token(p, 637)
			if _keyword == nil {
				return false
			} // token='as'
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			_tmp := _PyPegen_lookahead(1, _tmp_193_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_INVALID_TARGET(STAR_TARGETS, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_for_target: ASYNC? 'for' star_expressions
func invalid_for_target_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ASYNC? 'for' star_expressions
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a expr_ty
		condition := func() bool {
			_opt_var = _PyPegen_expect_token(p, ASYNC)
			if p.error_indicator != 0 {
				return false
			}
			// ASYNC?
			_keyword = _PyPegen_expect_token(p, 647)
			if _keyword == nil {
				return false
			} // token='for'
			a = star_expressions_rule(p)
			if a == nil {
				return false
			} // star_expressions
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_INVALID_TARGET(FOR_TARGETS, a)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_group: '(' starred_expression ')' | '(' '**' expression ')'
func invalid_group_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '(' starred_expression ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			a = starred_expression_rule(p)
			if a == nil {
				return false
			} // starred_expression
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "cannot use starred expression here")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // '(' '**' expression ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var a *Token
		var expression_var expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			a = _PyPegen_expect_token(p, 35)
			if a == nil {
				return false
			} // token='**'
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "cannot use double starred expression here")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_import_from_targets: import_from_as_names ',' NEWLINE
func invalid_import_from_targets_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // import_from_as_names ',' NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var import_from_as_names_var *asdl_alias_seq
		var newline_var *Token
		condition := func() bool {
			import_from_as_names_var = import_from_as_names_rule(p)
			if import_from_as_names_var == nil {
				return false
			} // import_from_as_names
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR("trailing comma not allowed without surrounding parentheses")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_with_stmt:
//     | ASYNC? 'with' ','.(expression ['as' star_target])+ NEWLINE
//     | ASYNC? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' NEWLINE
func invalid_with_stmt_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ASYNC? 'with' ','.(expression ['as' star_target])+ NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _gather_194_var *asdl_seq
		var _keyword *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var newline_var *Token
		condition := func() bool {
			_opt_var = _PyPegen_expect_token(p, ASYNC)
			if p.error_indicator != 0 {
				return false
			}
			// ASYNC?
			_keyword = _PyPegen_expect_token(p, 612)
			if _keyword == nil {
				return false
			} // token='with'
			_gather_194_var = _gather_194_rule(p)
			if _gather_194_var == nil {
				return false
			} // ','.(expression ['as' star_target])+
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR("expected ':'")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // ASYNC? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _gather_196_var *asdl_seq
		var _keyword *Token
		var _literal *Token
		var _literal_1 *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var _opt_var_1 any
		UNUSED(_opt_var_1) // Silence compiler warnings
		var newline_var *Token
		condition := func() bool {
			_opt_var = _PyPegen_expect_token(p, ASYNC)
			if p.error_indicator != 0 {
				return false
			}
			// ASYNC?
			_keyword = _PyPegen_expect_token(p, 612)
			if _keyword == nil {
				return false
			} // token='with'
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			_gather_196_var = _gather_196_rule(p)
			if _gather_196_var == nil {
				return false
			} // ','.(expressions ['as' star_target])+
			_opt_var_1 = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR("expected ':'")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_with_stmt_indent:
//     | ASYNC? 'with' ','.(expression ['as' star_target])+ ':' NEWLINE !INDENT
//     | ASYNC? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' ':' NEWLINE !INDENT
func invalid_with_stmt_indent_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ASYNC? 'with' ','.(expression ['as' star_target])+ ':' NEWLINE !INDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _gather_198_var *asdl_seq
		var _literal *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a *Token
		var newline_var *Token
		condition := func() bool {
			_opt_var = _PyPegen_expect_token(p, ASYNC)
			if p.error_indicator != 0 {
				return false
			}
			// ASYNC?
			a = _PyPegen_expect_token(p, 612)
			if a == nil {
				return false
			} // token='with'
			_gather_198_var = _gather_198_rule(p)
			if _gather_198_var == nil {
				return false
			} // ','.(expression ['as' star_target])+
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)
			if _tmp == 0 {
				return false
			} // token=INDENT
			return true
		}
		if condition() {
			_res = RAISE_INDENTATION_ERROR("expected an indented block after 'with' statement on line %d", a.lineno)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // ASYNC? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' ':' NEWLINE !INDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _gather_200_var *asdl_seq
		var _literal *Token
		var _literal_1 *Token
		var _literal_2 *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var _opt_var_1 any
		UNUSED(_opt_var_1) // Silence compiler warnings
		var a *Token
		var newline_var *Token
		condition := func() bool {
			_opt_var = _PyPegen_expect_token(p, ASYNC)
			if p.error_indicator != 0 {
				return false
			}
			// ASYNC?
			a = _PyPegen_expect_token(p, 612)
			if a == nil {
				return false
			} // token='with'
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			_gather_200_var = _gather_200_rule(p)
			if _gather_200_var == nil {
				return false
			} // ','.(expressions ['as' star_target])+
			_opt_var_1 = _PyPegen_expect_token(p, 12)
			if p.error_indicator != 0 {
				return false
			}
			// ','?
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			_literal_2 = _PyPegen_expect_token(p, 11)
			if _literal_2 == nil {
				return false
			} // token=':'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)
			if _tmp == 0 {
				return false
			} // token=INDENT
			return true
		}
		if condition() {
			_res = RAISE_INDENTATION_ERROR("expected an indented block after 'with' statement on line %d", a.lineno)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_try_stmt:
//     | 'try' ':' NEWLINE !INDENT
//     | 'try' ':' block !('except' | 'finally')
//     | 'try' ':' block* except_block+ 'except' '*' expression ['as' NAME] ':'
//     | 'try' ':' block* except_star_block+ 'except' [expression ['as' NAME]] ':'
func invalid_try_stmt_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'try' ':' NEWLINE !INDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *Token
		var newline_var *Token
		condition := func() bool {
			a = _PyPegen_expect_token(p, 621)
			if a == nil {
				return false
			} // token='try'
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)
			if _tmp == 0 {
				return false
			} // token=INDENT
			return true
		}
		if condition() {
			_res = RAISE_INDENTATION_ERROR("expected an indented block after 'try' statement on line %d", a.lineno)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'try' ':' block !('except' | 'finally')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var block_var *asdl_stmt_seq
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 621)
			if _keyword == nil {
				return false
			} // token='try'
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			block_var = block_rule(p)
			if block_var == nil {
				return false
			} // block
			_tmp := _PyPegen_lookahead(0, _tmp_202_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR("expected 'except' or 'finally' block")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'try' ':' block* except_block+ 'except' '*' expression ['as' NAME] ':'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var _literal_1 *Token
		var _loop0_203_var *asdl_seq
		var _loop1_204_var *asdl_seq
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a *Token
		var b *Token
		var expression_var expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 621)
			if _keyword == nil {
				return false
			} // token='try'
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			_loop0_203_var = _loop0_203_rule(p)
			if _loop0_203_var == nil {
				return false
			} // block*
			_loop1_204_var = _loop1_204_rule(p)
			if _loop1_204_var == nil {
				return false
			} // except_block+
			a = _PyPegen_expect_token(p, 634)
			if a == nil {
				return false
			} // token='except'
			b = _PyPegen_expect_token(p, 16)
			if b == nil {
				return false
			} // token='*'
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			_opt_var = _tmp_205_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['as' NAME]
			_literal_1 = _PyPegen_expect_token(p, 11)
			if _literal_1 == nil {
				return false
			} // token=':'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b, "cannot have both 'except' and 'except*' on the same 'try'")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'try' ':' block* except_star_block+ 'except' [expression ['as' NAME]] ':'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var _literal_1 *Token
		var _loop0_206_var *asdl_seq
		var _loop1_207_var *asdl_seq
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 621)
			if _keyword == nil {
				return false
			} // token='try'
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			_loop0_206_var = _loop0_206_rule(p)
			if _loop0_206_var == nil {
				return false
			} // block*
			_loop1_207_var = _loop1_207_rule(p)
			if _loop1_207_var == nil {
				return false
			} // except_star_block+
			a = _PyPegen_expect_token(p, 634)
			if a == nil {
				return false
			} // token='except'
			_opt_var = _tmp_208_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// [expression ['as' NAME]]
			_literal_1 = _PyPegen_expect_token(p, 11)
			if _literal_1 == nil {
				return false
			} // token=':'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "cannot have both 'except' and 'except*' on the same 'try'")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_except_stmt:
//     | 'except' '*'? expression ',' expressions ['as' NAME] ':'
//     | 'except' '*'? expression ['as' NAME] NEWLINE
//     | 'except' NEWLINE
//     | 'except' '*' (NEWLINE | ':')
func invalid_except_stmt_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'except' '*'? expression ',' expressions ['as' NAME] ':'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var _literal_1 *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var _opt_var_1 any
		UNUSED(_opt_var_1) // Silence compiler warnings
		var a expr_ty
		var expressions_var expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 634)
			if _keyword == nil {
				return false
			} // token='except'
			_opt_var = _PyPegen_expect_token(p, 16)
			if p.error_indicator != 0 {
				return false
			}
			// '*'?
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			expressions_var = expressions_rule(p)
			if expressions_var == nil {
				return false
			} // expressions
			_opt_var_1 = _tmp_209_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['as' NAME]
			_literal_1 = _PyPegen_expect_token(p, 11)
			if _literal_1 == nil {
				return false
			} // token=':'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_STARTING_FROM(a, "multiple exception types must be parenthesized")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'except' '*'? expression ['as' NAME] NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var _opt_var_1 any
		UNUSED(_opt_var_1) // Silence compiler warnings
		var a *Token
		var expression_var expr_ty
		var newline_var *Token
		condition := func() bool {
			a = _PyPegen_expect_token(p, 634)
			if a == nil {
				return false
			} // token='except'
			_opt_var = _PyPegen_expect_token(p, 16)
			if p.error_indicator != 0 {
				return false
			}
			// '*'?
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			_opt_var_1 = _tmp_210_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['as' NAME]
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR("expected ':'")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'except' NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *Token
		var newline_var *Token
		condition := func() bool {
			a = _PyPegen_expect_token(p, 634)
			if a == nil {
				return false
			} // token='except'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR("expected ':'")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'except' '*' (NEWLINE | ':')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _tmp_211_var any
		var a *Token
		condition := func() bool {
			a = _PyPegen_expect_token(p, 634)
			if a == nil {
				return false
			} // token='except'
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			_tmp_211_var = _tmp_211_rule(p)
			if _tmp_211_var == nil {
				return false
			} // NEWLINE | ':'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR("expected one or more exception types")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_finally_stmt: 'finally' ':' NEWLINE !INDENT
func invalid_finally_stmt_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'finally' ':' NEWLINE !INDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *Token
		var newline_var *Token
		condition := func() bool {
			a = _PyPegen_expect_token(p, 630)
			if a == nil {
				return false
			} // token='finally'
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)
			if _tmp == 0 {
				return false
			} // token=INDENT
			return true
		}
		if condition() {
			_res = RAISE_INDENTATION_ERROR("expected an indented block after 'finally' statement on line %d", a.lineno)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_except_stmt_indent:
//     | 'except' expression ['as' NAME] ':' NEWLINE !INDENT
//     | 'except' ':' NEWLINE !INDENT
func invalid_except_stmt_indent_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'except' expression ['as' NAME] ':' NEWLINE !INDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a *Token
		var expression_var expr_ty
		var newline_var *Token
		condition := func() bool {
			a = _PyPegen_expect_token(p, 634)
			if a == nil {
				return false
			} // token='except'
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			_opt_var = _tmp_212_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['as' NAME]
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)
			if _tmp == 0 {
				return false
			} // token=INDENT
			return true
		}
		if condition() {
			_res = RAISE_INDENTATION_ERROR("expected an indented block after 'except' statement on line %d", a.lineno)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'except' ':' NEWLINE !INDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *Token
		var newline_var *Token
		condition := func() bool {
			a = _PyPegen_expect_token(p, 634)
			if a == nil {
				return false
			} // token='except'
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)
			if _tmp == 0 {
				return false
			} // token=INDENT
			return true
		}
		if condition() {
			_res = RAISE_INDENTATION_ERROR("expected an indented block after 'except' statement on line %d", a.lineno)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_except_star_stmt_indent:
//     | 'except' '*' expression ['as' NAME] ':' NEWLINE !INDENT
func invalid_except_star_stmt_indent_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'except' '*' expression ['as' NAME] ':' NEWLINE !INDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a *Token
		var expression_var expr_ty
		var newline_var *Token
		condition := func() bool {
			a = _PyPegen_expect_token(p, 634)
			if a == nil {
				return false
			} // token='except'
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			_opt_var = _tmp_213_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['as' NAME]
			_literal_1 = _PyPegen_expect_token(p, 11)
			if _literal_1 == nil {
				return false
			} // token=':'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)
			if _tmp == 0 {
				return false
			} // token=INDENT
			return true
		}
		if condition() {
			_res = RAISE_INDENTATION_ERROR("expected an indented block after 'except*' statement on line %d", a.lineno)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_match_stmt:
//     | "match" subject_expr NEWLINE
//     | "match" subject_expr ':' NEWLINE !INDENT
func invalid_match_stmt_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // "match" subject_expr NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword expr_ty
		var newline_var *Token
		var subject_expr_var expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_soft_keyword(p, "match")
			if _keyword == nil {
				return false
			} // soft_keyword='"match"'
			subject_expr_var = subject_expr_rule(p)
			if subject_expr_var == nil {
				return false
			} // subject_expr
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		if condition() {
			_res = CHECK_VERSION(any, 10, "Pattern matching is", RAISE_SYNTAX_ERROR("expected ':'"))
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // "match" subject_expr ':' NEWLINE !INDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a expr_ty
		var newline_var *Token
		var subject expr_ty
		condition := func() bool {
			a = _PyPegen_expect_soft_keyword(p, "match")
			if a == nil {
				return false
			} // soft_keyword='"match"'
			subject = subject_expr_rule(p)
			if subject == nil {
				return false
			} // subject_expr
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)
			if _tmp == 0 {
				return false
			} // token=INDENT
			return true
		}
		if condition() {
			_res = RAISE_INDENTATION_ERROR("expected an indented block after 'match' statement on line %d", a.lineno)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_case_block:
//     | "case" patterns guard? NEWLINE
//     | "case" patterns guard? ':' NEWLINE !INDENT
func invalid_case_block_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // "case" patterns guard? NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword expr_ty
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var newline_var *Token
		var patterns_var pattern_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_soft_keyword(p, "case")
			if _keyword == nil {
				return false
			} // soft_keyword='"case"'
			patterns_var = patterns_rule(p)
			if patterns_var == nil {
				return false
			} // patterns
			_opt_var = guard_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// guard?
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR("expected ':'")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // "case" patterns guard? ':' NEWLINE !INDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a expr_ty
		var newline_var *Token
		var patterns_var pattern_ty
		condition := func() bool {
			a = _PyPegen_expect_soft_keyword(p, "case")
			if a == nil {
				return false
			} // soft_keyword='"case"'
			patterns_var = patterns_rule(p)
			if patterns_var == nil {
				return false
			} // patterns
			_opt_var = guard_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// guard?
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)
			if _tmp == 0 {
				return false
			} // token=INDENT
			return true
		}
		if condition() {
			_res = RAISE_INDENTATION_ERROR("expected an indented block after 'case' statement on line %d", a.lineno)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_as_pattern: or_pattern 'as' "_" | or_pattern 'as' !NAME expression
func invalid_as_pattern_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // or_pattern 'as' "_"
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var a expr_ty
		var or_pattern_var pattern_ty
		condition := func() bool {
			or_pattern_var = or_pattern_rule(p)
			if or_pattern_var == nil {
				return false
			} // or_pattern
			_keyword = _PyPegen_expect_token(p, 637)
			if _keyword == nil {
				return false
			} // token='as'
			a = _PyPegen_expect_soft_keyword(p, "_")
			if a == nil {
				return false
			} // soft_keyword='"_"'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "cannot use '_' as a target")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // or_pattern 'as' !NAME expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var a expr_ty
		var or_pattern_var pattern_ty
		condition := func() bool {
			or_pattern_var = or_pattern_rule(p)
			if or_pattern_var == nil {
				return false
			} // or_pattern
			_keyword = _PyPegen_expect_token(p, 637)
			if _keyword == nil {
				return false
			} // token='as'
			_tmp := _PyPegen_lookahead_with_name(0, _PyPegen_name_token, p)
			if _tmp == 0 {
				return false
			}
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "invalid pattern target")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_class_pattern: name_or_attr '(' invalid_class_argument_pattern
func invalid_class_pattern_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // name_or_attr '(' invalid_class_argument_pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *asdl_pattern_seq
		var name_or_attr_var expr_ty
		condition := func() bool {
			name_or_attr_var = name_or_attr_rule(p)
			if name_or_attr_var == nil {
				return false
			} // name_or_attr
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			a = invalid_class_argument_pattern_rule(p)
			if a == nil {
				return false
			} // invalid_class_argument_pattern
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_RANGE(PyPegen_first_item(a, pattern_ty), PyPegen_last_item(a, pattern_ty), "positional patterns follow keyword patterns")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_class_argument_pattern:
//     | [positional_patterns ','] keyword_patterns ',' positional_patterns
func invalid_class_argument_pattern_rule(p *Parser) *asdl_pattern_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_pattern_seq
	_mark := p.mark
	{ // [positional_patterns ','] keyword_patterns ',' positional_patterns
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a *asdl_pattern_seq
		var keyword_patterns_var *asdl_seq
		condition := func() bool {
			_opt_var = _tmp_214_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// [positional_patterns ',']
			keyword_patterns_var = keyword_patterns_rule(p)
			if keyword_patterns_var == nil {
				return false
			} // keyword_patterns
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			a = positional_patterns_rule(p)
			if a == nil {
				return false
			} // positional_patterns
			return true
		}
		if condition() {
			_res = a
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_if_stmt:
//     | 'if' named_expression NEWLINE
//     | 'if' named_expression ':' NEWLINE !INDENT
func invalid_if_stmt_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'if' named_expression NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var named_expression_var expr_ty
		var newline_var *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 639)
			if _keyword == nil {
				return false
			} // token='if'
			named_expression_var = named_expression_rule(p)
			if named_expression_var == nil {
				return false
			} // named_expression
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR("expected ':'")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'if' named_expression ':' NEWLINE !INDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *Token
		var a_1 expr_ty
		var newline_var *Token
		condition := func() bool {
			a = _PyPegen_expect_token(p, 639)
			if a == nil {
				return false
			} // token='if'
			a_1 = named_expression_rule(p)
			if a_1 == nil {
				return false
			} // named_expression
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)
			if _tmp == 0 {
				return false
			} // token=INDENT
			return true
		}
		if condition() {
			_res = RAISE_INDENTATION_ERROR("expected an indented block after 'if' statement on line %d", a.lineno)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_elif_stmt:
//     | 'elif' named_expression NEWLINE
//     | 'elif' named_expression ':' NEWLINE !INDENT
func invalid_elif_stmt_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'elif' named_expression NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var named_expression_var expr_ty
		var newline_var *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 641)
			if _keyword == nil {
				return false
			} // token='elif'
			named_expression_var = named_expression_rule(p)
			if named_expression_var == nil {
				return false
			} // named_expression
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR("expected ':'")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'elif' named_expression ':' NEWLINE !INDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *Token
		var named_expression_var expr_ty
		var newline_var *Token
		condition := func() bool {
			a = _PyPegen_expect_token(p, 641)
			if a == nil {
				return false
			} // token='elif'
			named_expression_var = named_expression_rule(p)
			if named_expression_var == nil {
				return false
			} // named_expression
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)
			if _tmp == 0 {
				return false
			} // token=INDENT
			return true
		}
		if condition() {
			_res = RAISE_INDENTATION_ERROR("expected an indented block after 'elif' statement on line %d", a.lineno)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_else_stmt: 'else' ':' NEWLINE !INDENT
func invalid_else_stmt_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'else' ':' NEWLINE !INDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *Token
		var newline_var *Token
		condition := func() bool {
			a = _PyPegen_expect_token(p, 642)
			if a == nil {
				return false
			} // token='else'
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)
			if _tmp == 0 {
				return false
			} // token=INDENT
			return true
		}
		if condition() {
			_res = RAISE_INDENTATION_ERROR("expected an indented block after 'else' statement on line %d", a.lineno)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_while_stmt:
//     | 'while' named_expression NEWLINE
//     | 'while' named_expression ':' NEWLINE !INDENT
func invalid_while_stmt_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'while' named_expression NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var named_expression_var expr_ty
		var newline_var *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 644)
			if _keyword == nil {
				return false
			} // token='while'
			named_expression_var = named_expression_rule(p)
			if named_expression_var == nil {
				return false
			} // named_expression
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR("expected ':'")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'while' named_expression ':' NEWLINE !INDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *Token
		var named_expression_var expr_ty
		var newline_var *Token
		condition := func() bool {
			a = _PyPegen_expect_token(p, 644)
			if a == nil {
				return false
			} // token='while'
			named_expression_var = named_expression_rule(p)
			if named_expression_var == nil {
				return false
			} // named_expression
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)
			if _tmp == 0 {
				return false
			} // token=INDENT
			return true
		}
		if condition() {
			_res = RAISE_INDENTATION_ERROR("expected an indented block after 'while' statement on line %d", a.lineno)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_for_stmt:
//     | ASYNC? 'for' star_targets 'in' star_expressions NEWLINE
//     | ASYNC? 'for' star_targets 'in' star_expressions ':' NEWLINE !INDENT
func invalid_for_stmt_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ASYNC? 'for' star_targets 'in' star_expressions NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _keyword_1 *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var newline_var *Token
		var star_expressions_var expr_ty
		var star_targets_var expr_ty
		condition := func() bool {
			_opt_var = _PyPegen_expect_token(p, ASYNC)
			if p.error_indicator != 0 {
				return false
			}
			// ASYNC?
			_keyword = _PyPegen_expect_token(p, 647)
			if _keyword == nil {
				return false
			} // token='for'
			star_targets_var = star_targets_rule(p)
			if star_targets_var == nil {
				return false
			} // star_targets
			_keyword_1 = _PyPegen_expect_token(p, 648)
			if _keyword_1 == nil {
				return false
			} // token='in'
			star_expressions_var = star_expressions_rule(p)
			if star_expressions_var == nil {
				return false
			} // star_expressions
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR("expected ':'")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // ASYNC? 'for' star_targets 'in' star_expressions ':' NEWLINE !INDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _literal *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a *Token
		var newline_var *Token
		var star_expressions_var expr_ty
		var star_targets_var expr_ty
		condition := func() bool {
			_opt_var = _PyPegen_expect_token(p, ASYNC)
			if p.error_indicator != 0 {
				return false
			}
			// ASYNC?
			a = _PyPegen_expect_token(p, 647)
			if a == nil {
				return false
			} // token='for'
			star_targets_var = star_targets_rule(p)
			if star_targets_var == nil {
				return false
			} // star_targets
			_keyword = _PyPegen_expect_token(p, 648)
			if _keyword == nil {
				return false
			} // token='in'
			star_expressions_var = star_expressions_rule(p)
			if star_expressions_var == nil {
				return false
			} // star_expressions
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)
			if _tmp == 0 {
				return false
			} // token=INDENT
			return true
		}
		if condition() {
			_res = RAISE_INDENTATION_ERROR("expected an indented block after 'for' statement on line %d", a.lineno)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_def_raw:
//     | ASYNC? 'def' NAME '(' params? ')' ['->' expression] ':' NEWLINE !INDENT
func invalid_def_raw_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ASYNC? 'def' NAME '(' params? ')' ['->' expression] ':' NEWLINE !INDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var _literal_2 *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var _opt_var_1 any
		UNUSED(_opt_var_1) // Silence compiler warnings
		var _opt_var_2 any
		UNUSED(_opt_var_2) // Silence compiler warnings
		var a *Token
		var name_var expr_ty
		var newline_var *Token
		condition := func() bool {
			_opt_var = _PyPegen_expect_token(p, ASYNC)
			if p.error_indicator != 0 {
				return false
			}
			// ASYNC?
			a = _PyPegen_expect_token(p, 649)
			if a == nil {
				return false
			} // token='def'
			name_var = _PyPegen_name_token(p)
			if name_var == nil {
				return false
			} // NAME
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			_opt_var_1 = params_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// params?
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			_opt_var_2 = _tmp_215_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['->' expression]
			_literal_2 = _PyPegen_expect_token(p, 11)
			if _literal_2 == nil {
				return false
			} // token=':'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)
			if _tmp == 0 {
				return false
			} // token=INDENT
			return true
		}
		if condition() {
			_res = RAISE_INDENTATION_ERROR("expected an indented block after function definition on line %d", a.lineno)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_class_def_raw:
//     | 'class' NAME ['(' arguments? ')'] NEWLINE
//     | 'class' NAME ['(' arguments? ')'] ':' NEWLINE !INDENT
func invalid_class_def_raw_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'class' NAME ['(' arguments? ')'] NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var name_var expr_ty
		var newline_var *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 651)
			if _keyword == nil {
				return false
			} // token='class'
			name_var = _PyPegen_name_token(p)
			if name_var == nil {
				return false
			} // NAME
			_opt_var = _tmp_216_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['(' arguments? ')']
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR("expected ':'")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // 'class' NAME ['(' arguments? ')'] ':' NEWLINE !INDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var a *Token
		var name_var expr_ty
		var newline_var *Token
		condition := func() bool {
			a = _PyPegen_expect_token(p, 651)
			if a == nil {
				return false
			} // token='class'
			name_var = _PyPegen_name_token(p)
			if name_var == nil {
				return false
			} // NAME
			_opt_var = _tmp_217_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['(' arguments? ')']
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)
			if _tmp == 0 {
				return false
			} // token=INDENT
			return true
		}
		if condition() {
			_res = RAISE_INDENTATION_ERROR("expected an indented block after class definition on line %d", a.lineno)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_double_starred_kvpairs:
//     | ','.double_starred_kvpair+ ',' invalid_kvpair
//     | expression ':' '*' bitwise_or
//     | expression ':' &('}' | ',')
func invalid_double_starred_kvpairs_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ','.double_starred_kvpair+ ',' invalid_kvpair
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _gather_218_var *asdl_seq
		var _literal *Token
		var invalid_kvpair_var any
		condition := func() bool {
			_gather_218_var = _gather_218_rule(p)
			if _gather_218_var == nil {
				return false
			} // ','.double_starred_kvpair+
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			invalid_kvpair_var = invalid_kvpair_rule(p)
			if invalid_kvpair_var == nil {
				return false
			} // invalid_kvpair
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, _gather_218_var, _literal, invalid_kvpair_var)
			goto done
		}
		p.mark = _mark
	}
	{ // expression ':' '*' bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *Token
		var bitwise_or_var expr_ty
		var expression_var expr_ty
		condition := func() bool {
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			a = _PyPegen_expect_token(p, 16)
			if a == nil {
				return false
			} // token='*'
			bitwise_or_var = bitwise_or_rule(p)
			if bitwise_or_var == nil {
				return false
			} // bitwise_or
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_STARTING_FROM(a, "cannot use a starred expression in a dictionary value")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // expression ':' &('}' | ',')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *Token
		var expression_var expr_ty
		condition := func() bool {
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			a = _PyPegen_expect_token(p, 11)
			if a == nil {
				return false
			} // token=':'
			_tmp := _PyPegen_lookahead(1, _tmp_220_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "expression expected after dictionary key and ':'")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// invalid_kvpair:
//     | expression !(':')
//     | expression ':' '*' bitwise_or
//     | expression ':' &('}' | ',')
func invalid_kvpair_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // expression !(':')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a expr_ty
		condition := func() bool {
			a = expression_rule(p)
			if a == nil {
				return false
			} // expression
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 11)
			if _tmp == 0 {
				return false
			} // token=(':')
			return true
		}
		if condition() {
			_res = RAISE_ERROR_KNOWN_LOCATION(p, PyExc_SyntaxError, a.lineno, a.end_col_offset-1, a.end_lineno, -1, "':' expected after dictionary key")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // expression ':' '*' bitwise_or
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var a *Token
		var bitwise_or_var expr_ty
		var expression_var expr_ty
		condition := func() bool {
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			a = _PyPegen_expect_token(p, 16)
			if a == nil {
				return false
			} // token='*'
			bitwise_or_var = bitwise_or_rule(p)
			if bitwise_or_var == nil {
				return false
			} // bitwise_or
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_STARTING_FROM(a, "cannot use a starred expression in a dictionary value")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // expression ':' &('}' | ',')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var a *Token
		var expression_var expr_ty
		condition := func() bool {
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			a = _PyPegen_expect_token(p, 11)
			if a == nil {
				return false
			} // token=':'
			_tmp := _PyPegen_lookahead(1, _tmp_221_rule, p)
			if _tmp == 0 {
				return false
			}
			return true
		}
		if condition() {
			_res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "expression expected after dictionary key and ':'")
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_1: NEWLINE
func _loop0_1_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var newline_var *Token
		condition := func() bool {
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		for condition() {
			_res = newline_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_1_type, _seq)
	p.level--
	return _seq
}

// _loop0_2: NEWLINE
func _loop0_2_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var newline_var *Token
		condition := func() bool {
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		for condition() {
			_res = newline_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_2_type, _seq)
	p.level--
	return _seq
}

// _loop1_3: statement
func _loop1_3_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // statement
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var statement_var *asdl_stmt_seq
		condition := func() bool {
			statement_var = statement_rule(p)
			if statement_var == nil {
				return false
			} // statement
			return true
		}
		for condition() {
			_res = statement_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_3_type, _seq)
	p.level--
	return _seq
}

// _loop0_5: ';' simple_stmt
func _loop0_5_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ';' simple_stmt
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem stmt_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 13)
			if _literal == nil {
				return false
			} // token=';'
			elem = simple_stmt_rule(p)
			if elem == nil {
				return false
			} // simple_stmt
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_5_type, _seq)
	p.level--
	return _seq
}

// _gather_4: simple_stmt _loop0_5
func _gather_4_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // simple_stmt _loop0_5
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem stmt_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = simple_stmt_rule(p)
			if elem == nil {
				return false
			} // simple_stmt
			seq = _loop0_5_rule(p)
			if seq == nil {
				return false
			} // _loop0_5
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_6: 'import' | 'from'
func _tmp_6_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'import'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 531)
			if _keyword == nil {
				return false
			} // token='import'
			return true
		}
		if condition() {
			_res = _keyword
			goto done
		}
		p.mark = _mark
	}
	{ // 'from'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 572)
			if _keyword == nil {
				return false
			} // token='from'
			return true
		}
		if condition() {
			_res = _keyword
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_7: 'def' | '@' | ASYNC
func _tmp_7_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'def'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 649)
			if _keyword == nil {
				return false
			} // token='def'
			return true
		}
		if condition() {
			_res = _keyword
			goto done
		}
		p.mark = _mark
	}
	{ // '@'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 49)
			if _literal == nil {
				return false
			} // token='@'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // ASYNC
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var async_var *Token
		condition := func() bool {
			async_var = _PyPegen_expect_token(p, ASYNC)
			if async_var == nil {
				return false
			} // token='ASYNC'
			return true
		}
		if condition() {
			_res = async_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_8: 'class' | '@'
func _tmp_8_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'class'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 651)
			if _keyword == nil {
				return false
			} // token='class'
			return true
		}
		if condition() {
			_res = _keyword
			goto done
		}
		p.mark = _mark
	}
	{ // '@'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 49)
			if _literal == nil {
				return false
			} // token='@'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_9: 'with' | ASYNC
func _tmp_9_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'with'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 612)
			if _keyword == nil {
				return false
			} // token='with'
			return true
		}
		if condition() {
			_res = _keyword
			goto done
		}
		p.mark = _mark
	}
	{ // ASYNC
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var async_var *Token
		condition := func() bool {
			async_var = _PyPegen_expect_token(p, ASYNC)
			if async_var == nil {
				return false
			} // token='ASYNC'
			return true
		}
		if condition() {
			_res = async_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_10: 'for' | ASYNC
func _tmp_10_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'for'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 647)
			if _keyword == nil {
				return false
			} // token='for'
			return true
		}
		if condition() {
			_res = _keyword
			goto done
		}
		p.mark = _mark
	}
	{ // ASYNC
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var async_var *Token
		condition := func() bool {
			async_var = _PyPegen_expect_token(p, ASYNC)
			if async_var == nil {
				return false
			} // token='ASYNC'
			return true
		}
		if condition() {
			_res = async_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_11: '=' annotated_rhs
func _tmp_11_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '=' annotated_rhs
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var d expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 22)
			if _literal == nil {
				return false
			} // token='='
			d = annotated_rhs_rule(p)
			if d == nil {
				return false
			} // annotated_rhs
			return true
		}
		if condition() {
			_res = d
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_12: '(' single_target ')' | single_subscript_attribute_target
func _tmp_12_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '(' single_target ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var b expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			b = single_target_rule(p)
			if b == nil {
				return false
			} // single_target
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = b
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	{ // single_subscript_attribute_target
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var single_subscript_attribute_target_var expr_ty
		condition := func() bool {
			single_subscript_attribute_target_var = single_subscript_attribute_target_rule(p)
			if single_subscript_attribute_target_var == nil {
				return false
			} // single_subscript_attribute_target
			return true
		}
		if condition() {
			_res = single_subscript_attribute_target_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_13: '=' annotated_rhs
func _tmp_13_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '=' annotated_rhs
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var d expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 22)
			if _literal == nil {
				return false
			} // token='='
			d = annotated_rhs_rule(p)
			if d == nil {
				return false
			} // annotated_rhs
			return true
		}
		if condition() {
			_res = d
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop1_14: (star_targets '=')
func _loop1_14_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // (star_targets '=')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_222_var any
		condition := func() bool {
			_tmp_222_var = _tmp_222_rule(p)
			if _tmp_222_var == nil {
				return false
			} // star_targets '='
			return true
		}
		for condition() {
			_res = _tmp_222_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_14_type, _seq)
	p.level--
	return _seq
}

// _tmp_15: yield_expr | star_expressions
func _tmp_15_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // yield_expr
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var yield_expr_var expr_ty
		condition := func() bool {
			yield_expr_var = yield_expr_rule(p)
			if yield_expr_var == nil {
				return false
			} // yield_expr
			return true
		}
		if condition() {
			_res = yield_expr_var
			goto done
		}
		p.mark = _mark
	}
	{ // star_expressions
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var star_expressions_var expr_ty
		condition := func() bool {
			star_expressions_var = star_expressions_rule(p)
			if star_expressions_var == nil {
				return false
			} // star_expressions
			return true
		}
		if condition() {
			_res = star_expressions_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_16: yield_expr | star_expressions
func _tmp_16_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // yield_expr
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var yield_expr_var expr_ty
		condition := func() bool {
			yield_expr_var = yield_expr_rule(p)
			if yield_expr_var == nil {
				return false
			} // yield_expr
			return true
		}
		if condition() {
			_res = yield_expr_var
			goto done
		}
		p.mark = _mark
	}
	{ // star_expressions
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var star_expressions_var expr_ty
		condition := func() bool {
			star_expressions_var = star_expressions_rule(p)
			if star_expressions_var == nil {
				return false
			} // star_expressions
			return true
		}
		if condition() {
			_res = star_expressions_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_17: 'from' expression
func _tmp_17_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'from' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var z expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 572)
			if _keyword == nil {
				return false
			} // token='from'
			z = expression_rule(p)
			if z == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = z
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_19: ',' NAME
func _loop0_19_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = _PyPegen_name_token(p)
			if elem == nil {
				return false
			} // NAME
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_19_type, _seq)
	p.level--
	return _seq
}

// _gather_18: NAME _loop0_19
func _gather_18_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // NAME _loop0_19
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem expr_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = _PyPegen_name_token(p)
			if elem == nil {
				return false
			} // NAME
			seq = _loop0_19_rule(p)
			if seq == nil {
				return false
			} // _loop0_19
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_21: ',' NAME
func _loop0_21_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = _PyPegen_name_token(p)
			if elem == nil {
				return false
			} // NAME
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_21_type, _seq)
	p.level--
	return _seq
}

// _gather_20: NAME _loop0_21
func _gather_20_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // NAME _loop0_21
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem expr_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = _PyPegen_name_token(p)
			if elem == nil {
				return false
			} // NAME
			seq = _loop0_21_rule(p)
			if seq == nil {
				return false
			} // _loop0_21
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_22: ';' | NEWLINE
func _tmp_22_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ';'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 13)
			if _literal == nil {
				return false
			} // token=';'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var newline_var *Token
		condition := func() bool {
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		if condition() {
			_res = newline_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_23: ',' expression
func _tmp_23_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ',' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var z expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			z = expression_rule(p)
			if z == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = z
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_24: ('.' | '...')
func _loop0_24_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ('.' | '...')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_223_var any
		condition := func() bool {
			_tmp_223_var = _tmp_223_rule(p)
			if _tmp_223_var == nil {
				return false
			} // '.' | '...'
			return true
		}
		for condition() {
			_res = _tmp_223_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_24_type, _seq)
	p.level--
	return _seq
}

// _loop1_25: ('.' | '...')
func _loop1_25_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ('.' | '...')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_224_var any
		condition := func() bool {
			_tmp_224_var = _tmp_224_rule(p)
			if _tmp_224_var == nil {
				return false
			} // '.' | '...'
			return true
		}
		for condition() {
			_res = _tmp_224_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_25_type, _seq)
	p.level--
	return _seq
}

// _loop0_27: ',' import_from_as_name
func _loop0_27_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' import_from_as_name
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem alias_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = import_from_as_name_rule(p)
			if elem == nil {
				return false
			} // import_from_as_name
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_27_type, _seq)
	p.level--
	return _seq
}

// _gather_26: import_from_as_name _loop0_27
func _gather_26_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // import_from_as_name _loop0_27
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem alias_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = import_from_as_name_rule(p)
			if elem == nil {
				return false
			} // import_from_as_name
			seq = _loop0_27_rule(p)
			if seq == nil {
				return false
			} // _loop0_27
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_28: 'as' NAME
func _tmp_28_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'as' NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var z expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 637)
			if _keyword == nil {
				return false
			} // token='as'
			z = _PyPegen_name_token(p)
			if z == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_res = z
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_30: ',' dotted_as_name
func _loop0_30_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' dotted_as_name
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem alias_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = dotted_as_name_rule(p)
			if elem == nil {
				return false
			} // dotted_as_name
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_30_type, _seq)
	p.level--
	return _seq
}

// _gather_29: dotted_as_name _loop0_30
func _gather_29_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // dotted_as_name _loop0_30
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem alias_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = dotted_as_name_rule(p)
			if elem == nil {
				return false
			} // dotted_as_name
			seq = _loop0_30_rule(p)
			if seq == nil {
				return false
			} // _loop0_30
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_31: 'as' NAME
func _tmp_31_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'as' NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var z expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 637)
			if _keyword == nil {
				return false
			} // token='as'
			z = _PyPegen_name_token(p)
			if z == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_res = z
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop1_32: ('@' named_expression NEWLINE)
func _loop1_32_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ('@' named_expression NEWLINE)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_225_var any
		condition := func() bool {
			_tmp_225_var = _tmp_225_rule(p)
			if _tmp_225_var == nil {
				return false
			} // '@' named_expression NEWLINE
			return true
		}
		for condition() {
			_res = _tmp_225_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_32_type, _seq)
	p.level--
	return _seq
}

// _tmp_33: '(' arguments? ')'
func _tmp_33_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '(' arguments? ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var z any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			z = arguments_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// arguments?
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = z
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_34: '->' expression
func _tmp_34_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '->' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var z expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 51)
			if _literal == nil {
				return false
			} // token='->'
			z = expression_rule(p)
			if z == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = z
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_35: '->' expression
func _tmp_35_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '->' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var z expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 51)
			if _literal == nil {
				return false
			} // token='->'
			z = expression_rule(p)
			if z == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = z
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_36: param_no_default
func _loop0_36_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_no_default_var arg_ty
		condition := func() bool {
			param_no_default_var = param_no_default_rule(p)
			if param_no_default_var == nil {
				return false
			} // param_no_default
			return true
		}
		for condition() {
			_res = param_no_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_36_type, _seq)
	p.level--
	return _seq
}

// _loop0_37: param_with_default
func _loop0_37_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_with_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_with_default_var *NameDefaultPair
		condition := func() bool {
			param_with_default_var = param_with_default_rule(p)
			if param_with_default_var == nil {
				return false
			} // param_with_default
			return true
		}
		for condition() {
			_res = param_with_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_37_type, _seq)
	p.level--
	return _seq
}

// _loop0_38: param_with_default
func _loop0_38_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_with_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_with_default_var *NameDefaultPair
		condition := func() bool {
			param_with_default_var = param_with_default_rule(p)
			if param_with_default_var == nil {
				return false
			} // param_with_default
			return true
		}
		for condition() {
			_res = param_with_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_38_type, _seq)
	p.level--
	return _seq
}

// _loop1_39: param_no_default
func _loop1_39_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_no_default_var arg_ty
		condition := func() bool {
			param_no_default_var = param_no_default_rule(p)
			if param_no_default_var == nil {
				return false
			} // param_no_default
			return true
		}
		for condition() {
			_res = param_no_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_39_type, _seq)
	p.level--
	return _seq
}

// _loop0_40: param_with_default
func _loop0_40_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_with_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_with_default_var *NameDefaultPair
		condition := func() bool {
			param_with_default_var = param_with_default_rule(p)
			if param_with_default_var == nil {
				return false
			} // param_with_default
			return true
		}
		for condition() {
			_res = param_with_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_40_type, _seq)
	p.level--
	return _seq
}

// _loop1_41: param_with_default
func _loop1_41_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_with_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_with_default_var *NameDefaultPair
		condition := func() bool {
			param_with_default_var = param_with_default_rule(p)
			if param_with_default_var == nil {
				return false
			} // param_with_default
			return true
		}
		for condition() {
			_res = param_with_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_41_type, _seq)
	p.level--
	return _seq
}

// _loop1_42: param_no_default
func _loop1_42_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_no_default_var arg_ty
		condition := func() bool {
			param_no_default_var = param_no_default_rule(p)
			if param_no_default_var == nil {
				return false
			} // param_no_default
			return true
		}
		for condition() {
			_res = param_no_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_42_type, _seq)
	p.level--
	return _seq
}

// _loop1_43: param_no_default
func _loop1_43_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_no_default_var arg_ty
		condition := func() bool {
			param_no_default_var = param_no_default_rule(p)
			if param_no_default_var == nil {
				return false
			} // param_no_default
			return true
		}
		for condition() {
			_res = param_no_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_43_type, _seq)
	p.level--
	return _seq
}

// _loop0_44: param_no_default
func _loop0_44_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_no_default_var arg_ty
		condition := func() bool {
			param_no_default_var = param_no_default_rule(p)
			if param_no_default_var == nil {
				return false
			} // param_no_default
			return true
		}
		for condition() {
			_res = param_no_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_44_type, _seq)
	p.level--
	return _seq
}

// _loop1_45: param_with_default
func _loop1_45_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_with_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_with_default_var *NameDefaultPair
		condition := func() bool {
			param_with_default_var = param_with_default_rule(p)
			if param_with_default_var == nil {
				return false
			} // param_with_default
			return true
		}
		for condition() {
			_res = param_with_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_45_type, _seq)
	p.level--
	return _seq
}

// _loop0_46: param_no_default
func _loop0_46_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_no_default_var arg_ty
		condition := func() bool {
			param_no_default_var = param_no_default_rule(p)
			if param_no_default_var == nil {
				return false
			} // param_no_default
			return true
		}
		for condition() {
			_res = param_no_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_46_type, _seq)
	p.level--
	return _seq
}

// _loop1_47: param_with_default
func _loop1_47_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_with_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_with_default_var *NameDefaultPair
		condition := func() bool {
			param_with_default_var = param_with_default_rule(p)
			if param_with_default_var == nil {
				return false
			} // param_with_default
			return true
		}
		for condition() {
			_res = param_with_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_47_type, _seq)
	p.level--
	return _seq
}

// _loop0_48: param_maybe_default
func _loop0_48_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_maybe_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_maybe_default_var *NameDefaultPair
		condition := func() bool {
			param_maybe_default_var = param_maybe_default_rule(p)
			if param_maybe_default_var == nil {
				return false
			} // param_maybe_default
			return true
		}
		for condition() {
			_res = param_maybe_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_48_type, _seq)
	p.level--
	return _seq
}

// _loop0_49: param_maybe_default
func _loop0_49_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_maybe_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_maybe_default_var *NameDefaultPair
		condition := func() bool {
			param_maybe_default_var = param_maybe_default_rule(p)
			if param_maybe_default_var == nil {
				return false
			} // param_maybe_default
			return true
		}
		for condition() {
			_res = param_maybe_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_49_type, _seq)
	p.level--
	return _seq
}

// _loop1_50: param_maybe_default
func _loop1_50_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_maybe_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_maybe_default_var *NameDefaultPair
		condition := func() bool {
			param_maybe_default_var = param_maybe_default_rule(p)
			if param_maybe_default_var == nil {
				return false
			} // param_maybe_default
			return true
		}
		for condition() {
			_res = param_maybe_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_50_type, _seq)
	p.level--
	return _seq
}

// _loop0_52: ',' with_item
func _loop0_52_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' with_item
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem withitem_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = with_item_rule(p)
			if elem == nil {
				return false
			} // with_item
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_52_type, _seq)
	p.level--
	return _seq
}

// _gather_51: with_item _loop0_52
func _gather_51_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // with_item _loop0_52
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem withitem_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = with_item_rule(p)
			if elem == nil {
				return false
			} // with_item
			seq = _loop0_52_rule(p)
			if seq == nil {
				return false
			} // _loop0_52
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_54: ',' with_item
func _loop0_54_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' with_item
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem withitem_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = with_item_rule(p)
			if elem == nil {
				return false
			} // with_item
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_54_type, _seq)
	p.level--
	return _seq
}

// _gather_53: with_item _loop0_54
func _gather_53_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // with_item _loop0_54
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem withitem_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = with_item_rule(p)
			if elem == nil {
				return false
			} // with_item
			seq = _loop0_54_rule(p)
			if seq == nil {
				return false
			} // _loop0_54
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_56: ',' with_item
func _loop0_56_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' with_item
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem withitem_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = with_item_rule(p)
			if elem == nil {
				return false
			} // with_item
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_56_type, _seq)
	p.level--
	return _seq
}

// _gather_55: with_item _loop0_56
func _gather_55_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // with_item _loop0_56
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem withitem_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = with_item_rule(p)
			if elem == nil {
				return false
			} // with_item
			seq = _loop0_56_rule(p)
			if seq == nil {
				return false
			} // _loop0_56
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_58: ',' with_item
func _loop0_58_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' with_item
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem withitem_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = with_item_rule(p)
			if elem == nil {
				return false
			} // with_item
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_58_type, _seq)
	p.level--
	return _seq
}

// _gather_57: with_item _loop0_58
func _gather_57_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // with_item _loop0_58
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem withitem_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = with_item_rule(p)
			if elem == nil {
				return false
			} // with_item
			seq = _loop0_58_rule(p)
			if seq == nil {
				return false
			} // _loop0_58
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_59: ',' | ')' | ':'
func _tmp_59_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 8)
			if _literal == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // ':'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop1_60: except_block
func _loop1_60_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // except_block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var except_block_var excepthandler_ty
		condition := func() bool {
			except_block_var = except_block_rule(p)
			if except_block_var == nil {
				return false
			} // except_block
			return true
		}
		for condition() {
			_res = except_block_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_60_type, _seq)
	p.level--
	return _seq
}

// _loop1_61: except_star_block
func _loop1_61_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // except_star_block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var except_star_block_var excepthandler_ty
		condition := func() bool {
			except_star_block_var = except_star_block_rule(p)
			if except_star_block_var == nil {
				return false
			} // except_star_block
			return true
		}
		for condition() {
			_res = except_star_block_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_61_type, _seq)
	p.level--
	return _seq
}

// _tmp_62: 'as' NAME
func _tmp_62_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'as' NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var z expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 637)
			if _keyword == nil {
				return false
			} // token='as'
			z = _PyPegen_name_token(p)
			if z == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_res = z
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_63: 'as' NAME
func _tmp_63_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'as' NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var z expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 637)
			if _keyword == nil {
				return false
			} // token='as'
			z = _PyPegen_name_token(p)
			if z == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_res = z
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop1_64: case_block
func _loop1_64_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // case_block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var case_block_var match_case_ty
		condition := func() bool {
			case_block_var = case_block_rule(p)
			if case_block_var == nil {
				return false
			} // case_block
			return true
		}
		for condition() {
			_res = case_block_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_64_type, _seq)
	p.level--
	return _seq
}

// _loop0_66: '|' closed_pattern
func _loop0_66_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // '|' closed_pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem pattern_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 18)
			if _literal == nil {
				return false
			} // token='|'
			elem = closed_pattern_rule(p)
			if elem == nil {
				return false
			} // closed_pattern
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_66_type, _seq)
	p.level--
	return _seq
}

// _gather_65: closed_pattern _loop0_66
func _gather_65_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // closed_pattern _loop0_66
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem pattern_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = closed_pattern_rule(p)
			if elem == nil {
				return false
			} // closed_pattern
			seq = _loop0_66_rule(p)
			if seq == nil {
				return false
			} // _loop0_66
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_67: '+' | '-'
func _tmp_67_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '+'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 14)
			if _literal == nil {
				return false
			} // token='+'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // '-'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 15)
			if _literal == nil {
				return false
			} // token='-'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_68: '+' | '-'
func _tmp_68_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '+'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 14)
			if _literal == nil {
				return false
			} // token='+'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // '-'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 15)
			if _literal == nil {
				return false
			} // token='-'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_69: '.' | '(' | '='
func _tmp_69_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '.'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 23)
			if _literal == nil {
				return false
			} // token='.'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // '('
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // '='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 22)
			if _literal == nil {
				return false
			} // token='='
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_70: '.' | '(' | '='
func _tmp_70_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '.'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 23)
			if _literal == nil {
				return false
			} // token='.'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // '('
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // '='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 22)
			if _literal == nil {
				return false
			} // token='='
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_72: ',' maybe_star_pattern
func _loop0_72_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' maybe_star_pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem pattern_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = maybe_star_pattern_rule(p)
			if elem == nil {
				return false
			} // maybe_star_pattern
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_72_type, _seq)
	p.level--
	return _seq
}

// _gather_71: maybe_star_pattern _loop0_72
func _gather_71_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // maybe_star_pattern _loop0_72
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem pattern_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = maybe_star_pattern_rule(p)
			if elem == nil {
				return false
			} // maybe_star_pattern
			seq = _loop0_72_rule(p)
			if seq == nil {
				return false
			} // _loop0_72
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_74: ',' key_value_pattern
func _loop0_74_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' key_value_pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem *KeyPatternPair
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = key_value_pattern_rule(p)
			if elem == nil {
				return false
			} // key_value_pattern
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_74_type, _seq)
	p.level--
	return _seq
}

// _gather_73: key_value_pattern _loop0_74
func _gather_73_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // key_value_pattern _loop0_74
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem *KeyPatternPair
		var seq *asdl_seq
		condition := func() bool {
			elem = key_value_pattern_rule(p)
			if elem == nil {
				return false
			} // key_value_pattern
			seq = _loop0_74_rule(p)
			if seq == nil {
				return false
			} // _loop0_74
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_75: literal_expr | attr
func _tmp_75_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // literal_expr
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var literal_expr_var expr_ty
		condition := func() bool {
			literal_expr_var = literal_expr_rule(p)
			if literal_expr_var == nil {
				return false
			} // literal_expr
			return true
		}
		if condition() {
			_res = literal_expr_var
			goto done
		}
		p.mark = _mark
	}
	{ // attr
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var attr_var expr_ty
		condition := func() bool {
			attr_var = attr_rule(p)
			if attr_var == nil {
				return false
			} // attr
			return true
		}
		if condition() {
			_res = attr_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_77: ',' pattern
func _loop0_77_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem pattern_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = pattern_rule(p)
			if elem == nil {
				return false
			} // pattern
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_77_type, _seq)
	p.level--
	return _seq
}

// _gather_76: pattern _loop0_77
func _gather_76_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // pattern _loop0_77
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem pattern_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = pattern_rule(p)
			if elem == nil {
				return false
			} // pattern
			seq = _loop0_77_rule(p)
			if seq == nil {
				return false
			} // _loop0_77
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_79: ',' keyword_pattern
func _loop0_79_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' keyword_pattern
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem *KeyPatternPair
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = keyword_pattern_rule(p)
			if elem == nil {
				return false
			} // keyword_pattern
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_79_type, _seq)
	p.level--
	return _seq
}

// _gather_78: keyword_pattern _loop0_79
func _gather_78_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // keyword_pattern _loop0_79
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem *KeyPatternPair
		var seq *asdl_seq
		condition := func() bool {
			elem = keyword_pattern_rule(p)
			if elem == nil {
				return false
			} // keyword_pattern
			seq = _loop0_79_rule(p)
			if seq == nil {
				return false
			} // _loop0_79
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop1_80: (',' expression)
func _loop1_80_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // (',' expression)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_226_var any
		condition := func() bool {
			_tmp_226_var = _tmp_226_rule(p)
			if _tmp_226_var == nil {
				return false
			} // ',' expression
			return true
		}
		for condition() {
			_res = _tmp_226_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_80_type, _seq)
	p.level--
	return _seq
}

// _loop1_81: (',' star_expression)
func _loop1_81_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // (',' star_expression)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_227_var any
		condition := func() bool {
			_tmp_227_var = _tmp_227_rule(p)
			if _tmp_227_var == nil {
				return false
			} // ',' star_expression
			return true
		}
		for condition() {
			_res = _tmp_227_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_81_type, _seq)
	p.level--
	return _seq
}

// _loop0_83: ',' star_named_expression
func _loop0_83_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' star_named_expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = star_named_expression_rule(p)
			if elem == nil {
				return false
			} // star_named_expression
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_83_type, _seq)
	p.level--
	return _seq
}

// _gather_82: star_named_expression _loop0_83
func _gather_82_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // star_named_expression _loop0_83
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem expr_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = star_named_expression_rule(p)
			if elem == nil {
				return false
			} // star_named_expression
			seq = _loop0_83_rule(p)
			if seq == nil {
				return false
			} // _loop0_83
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop1_84: ('or' conjunction)
func _loop1_84_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ('or' conjunction)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_228_var any
		condition := func() bool {
			_tmp_228_var = _tmp_228_rule(p)
			if _tmp_228_var == nil {
				return false
			} // 'or' conjunction
			return true
		}
		for condition() {
			_res = _tmp_228_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_84_type, _seq)
	p.level--
	return _seq
}

// _loop1_85: ('and' inversion)
func _loop1_85_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ('and' inversion)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_229_var any
		condition := func() bool {
			_tmp_229_var = _tmp_229_rule(p)
			if _tmp_229_var == nil {
				return false
			} // 'and' inversion
			return true
		}
		for condition() {
			_res = _tmp_229_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_85_type, _seq)
	p.level--
	return _seq
}

// _loop1_86: compare_op_bitwise_or_pair
func _loop1_86_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // compare_op_bitwise_or_pair
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var compare_op_bitwise_or_pair_var *CmpopExprPair
		condition := func() bool {
			compare_op_bitwise_or_pair_var = compare_op_bitwise_or_pair_rule(p)
			if compare_op_bitwise_or_pair_var == nil {
				return false
			} // compare_op_bitwise_or_pair
			return true
		}
		for condition() {
			_res = compare_op_bitwise_or_pair_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_86_type, _seq)
	p.level--
	return _seq
}

// _tmp_87: '!='
func _tmp_87_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '!='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var tok *Token
		condition := func() bool {
			tok = _PyPegen_expect_token(p, 28)
			if tok == nil {
				return false
			} // token='!='
			return true
		}
		if condition() {
			_res = ternary_operator(_PyPegen_check_barry_as_flufl(p, tok), nil, tok)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_89: ',' (slice | starred_expression)
func _loop0_89_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' (slice | starred_expression)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = _tmp_230_rule(p)
			if elem == nil {
				return false
			} // slice | starred_expression
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_89_type, _seq)
	p.level--
	return _seq
}

// _gather_88: (slice | starred_expression) _loop0_89
func _gather_88_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // (slice | starred_expression) _loop0_89
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem any
		var seq *asdl_seq
		condition := func() bool {
			elem = _tmp_230_rule(p)
			if elem == nil {
				return false
			} // slice | starred_expression
			seq = _loop0_89_rule(p)
			if seq == nil {
				return false
			} // _loop0_89
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_90: ':' expression?
func _tmp_90_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ':' expression?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var d any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			d = expression_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// expression?
			return true
		}
		if condition() {
			_res = d
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_91: tuple | group | genexp
func _tmp_91_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // tuple
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var tuple_var expr_ty
		condition := func() bool {
			tuple_var = tuple_rule(p)
			if tuple_var == nil {
				return false
			} // tuple
			return true
		}
		if condition() {
			_res = tuple_var
			goto done
		}
		p.mark = _mark
	}
	{ // group
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var group_var expr_ty
		condition := func() bool {
			group_var = group_rule(p)
			if group_var == nil {
				return false
			} // group
			return true
		}
		if condition() {
			_res = group_var
			goto done
		}
		p.mark = _mark
	}
	{ // genexp
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var genexp_var expr_ty
		condition := func() bool {
			genexp_var = genexp_rule(p)
			if genexp_var == nil {
				return false
			} // genexp
			return true
		}
		if condition() {
			_res = genexp_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_92: list | listcomp
func _tmp_92_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // list
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var list_var expr_ty
		condition := func() bool {
			list_var = list_rule(p)
			if list_var == nil {
				return false
			} // list
			return true
		}
		if condition() {
			_res = list_var
			goto done
		}
		p.mark = _mark
	}
	{ // listcomp
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var listcomp_var expr_ty
		condition := func() bool {
			listcomp_var = listcomp_rule(p)
			if listcomp_var == nil {
				return false
			} // listcomp
			return true
		}
		if condition() {
			_res = listcomp_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_93: dict | set | dictcomp | setcomp
func _tmp_93_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // dict
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var dict_var expr_ty
		condition := func() bool {
			dict_var = dict_rule(p)
			if dict_var == nil {
				return false
			} // dict
			return true
		}
		if condition() {
			_res = dict_var
			goto done
		}
		p.mark = _mark
	}
	{ // set
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var set_var expr_ty
		condition := func() bool {
			set_var = set_rule(p)
			if set_var == nil {
				return false
			} // set
			return true
		}
		if condition() {
			_res = set_var
			goto done
		}
		p.mark = _mark
	}
	{ // dictcomp
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var dictcomp_var expr_ty
		condition := func() bool {
			dictcomp_var = dictcomp_rule(p)
			if dictcomp_var == nil {
				return false
			} // dictcomp
			return true
		}
		if condition() {
			_res = dictcomp_var
			goto done
		}
		p.mark = _mark
	}
	{ // setcomp
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var setcomp_var expr_ty
		condition := func() bool {
			setcomp_var = setcomp_rule(p)
			if setcomp_var == nil {
				return false
			} // setcomp
			return true
		}
		if condition() {
			_res = setcomp_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_94: yield_expr | named_expression
func _tmp_94_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // yield_expr
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var yield_expr_var expr_ty
		condition := func() bool {
			yield_expr_var = yield_expr_rule(p)
			if yield_expr_var == nil {
				return false
			} // yield_expr
			return true
		}
		if condition() {
			_res = yield_expr_var
			goto done
		}
		p.mark = _mark
	}
	{ // named_expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var named_expression_var expr_ty
		condition := func() bool {
			named_expression_var = named_expression_rule(p)
			if named_expression_var == nil {
				return false
			} // named_expression
			return true
		}
		if condition() {
			_res = named_expression_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_95: lambda_param_no_default
func _loop0_95_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_no_default_var arg_ty
		condition := func() bool {
			lambda_param_no_default_var = lambda_param_no_default_rule(p)
			if lambda_param_no_default_var == nil {
				return false
			} // lambda_param_no_default
			return true
		}
		for condition() {
			_res = lambda_param_no_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_95_type, _seq)
	p.level--
	return _seq
}

// _loop0_96: lambda_param_with_default
func _loop0_96_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_with_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_with_default_var *NameDefaultPair
		condition := func() bool {
			lambda_param_with_default_var = lambda_param_with_default_rule(p)
			if lambda_param_with_default_var == nil {
				return false
			} // lambda_param_with_default
			return true
		}
		for condition() {
			_res = lambda_param_with_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_96_type, _seq)
	p.level--
	return _seq
}

// _loop0_97: lambda_param_with_default
func _loop0_97_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_with_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_with_default_var *NameDefaultPair
		condition := func() bool {
			lambda_param_with_default_var = lambda_param_with_default_rule(p)
			if lambda_param_with_default_var == nil {
				return false
			} // lambda_param_with_default
			return true
		}
		for condition() {
			_res = lambda_param_with_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_97_type, _seq)
	p.level--
	return _seq
}

// _loop1_98: lambda_param_no_default
func _loop1_98_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_no_default_var arg_ty
		condition := func() bool {
			lambda_param_no_default_var = lambda_param_no_default_rule(p)
			if lambda_param_no_default_var == nil {
				return false
			} // lambda_param_no_default
			return true
		}
		for condition() {
			_res = lambda_param_no_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_98_type, _seq)
	p.level--
	return _seq
}

// _loop0_99: lambda_param_with_default
func _loop0_99_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_with_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_with_default_var *NameDefaultPair
		condition := func() bool {
			lambda_param_with_default_var = lambda_param_with_default_rule(p)
			if lambda_param_with_default_var == nil {
				return false
			} // lambda_param_with_default
			return true
		}
		for condition() {
			_res = lambda_param_with_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_99_type, _seq)
	p.level--
	return _seq
}

// _loop1_100: lambda_param_with_default
func _loop1_100_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_with_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_with_default_var *NameDefaultPair
		condition := func() bool {
			lambda_param_with_default_var = lambda_param_with_default_rule(p)
			if lambda_param_with_default_var == nil {
				return false
			} // lambda_param_with_default
			return true
		}
		for condition() {
			_res = lambda_param_with_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_100_type, _seq)
	p.level--
	return _seq
}

// _loop1_101: lambda_param_no_default
func _loop1_101_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_no_default_var arg_ty
		condition := func() bool {
			lambda_param_no_default_var = lambda_param_no_default_rule(p)
			if lambda_param_no_default_var == nil {
				return false
			} // lambda_param_no_default
			return true
		}
		for condition() {
			_res = lambda_param_no_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_101_type, _seq)
	p.level--
	return _seq
}

// _loop1_102: lambda_param_no_default
func _loop1_102_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_no_default_var arg_ty
		condition := func() bool {
			lambda_param_no_default_var = lambda_param_no_default_rule(p)
			if lambda_param_no_default_var == nil {
				return false
			} // lambda_param_no_default
			return true
		}
		for condition() {
			_res = lambda_param_no_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_102_type, _seq)
	p.level--
	return _seq
}

// _loop0_103: lambda_param_no_default
func _loop0_103_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_no_default_var arg_ty
		condition := func() bool {
			lambda_param_no_default_var = lambda_param_no_default_rule(p)
			if lambda_param_no_default_var == nil {
				return false
			} // lambda_param_no_default
			return true
		}
		for condition() {
			_res = lambda_param_no_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_103_type, _seq)
	p.level--
	return _seq
}

// _loop1_104: lambda_param_with_default
func _loop1_104_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_with_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_with_default_var *NameDefaultPair
		condition := func() bool {
			lambda_param_with_default_var = lambda_param_with_default_rule(p)
			if lambda_param_with_default_var == nil {
				return false
			} // lambda_param_with_default
			return true
		}
		for condition() {
			_res = lambda_param_with_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_104_type, _seq)
	p.level--
	return _seq
}

// _loop0_105: lambda_param_no_default
func _loop0_105_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_no_default_var arg_ty
		condition := func() bool {
			lambda_param_no_default_var = lambda_param_no_default_rule(p)
			if lambda_param_no_default_var == nil {
				return false
			} // lambda_param_no_default
			return true
		}
		for condition() {
			_res = lambda_param_no_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_105_type, _seq)
	p.level--
	return _seq
}

// _loop1_106: lambda_param_with_default
func _loop1_106_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_with_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_with_default_var *NameDefaultPair
		condition := func() bool {
			lambda_param_with_default_var = lambda_param_with_default_rule(p)
			if lambda_param_with_default_var == nil {
				return false
			} // lambda_param_with_default
			return true
		}
		for condition() {
			_res = lambda_param_with_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_106_type, _seq)
	p.level--
	return _seq
}

// _loop0_107: lambda_param_maybe_default
func _loop0_107_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_maybe_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_maybe_default_var *NameDefaultPair
		condition := func() bool {
			lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p)
			if lambda_param_maybe_default_var == nil {
				return false
			} // lambda_param_maybe_default
			return true
		}
		for condition() {
			_res = lambda_param_maybe_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_107_type, _seq)
	p.level--
	return _seq
}

// _loop1_108: lambda_param_maybe_default
func _loop1_108_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_maybe_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_maybe_default_var *NameDefaultPair
		condition := func() bool {
			lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p)
			if lambda_param_maybe_default_var == nil {
				return false
			} // lambda_param_maybe_default
			return true
		}
		for condition() {
			_res = lambda_param_maybe_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_108_type, _seq)
	p.level--
	return _seq
}

// _loop1_109: STRING
func _loop1_109_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // STRING
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var string_var expr_ty
		condition := func() bool {
			string_var = _PyPegen_string_token(p)
			if string_var == nil {
				return false
			} // STRING
			return true
		}
		for condition() {
			_res = string_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_109_type, _seq)
	p.level--
	return _seq
}

// _tmp_110: star_named_expression ',' star_named_expressions?
func _tmp_110_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // star_named_expression ',' star_named_expressions?
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var y expr_ty
		var z any
		condition := func() bool {
			y = star_named_expression_rule(p)
			if y == nil {
				return false
			} // star_named_expression
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			z = star_named_expressions_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// star_named_expressions?
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, y, z)
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_112: ',' double_starred_kvpair
func _loop0_112_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' double_starred_kvpair
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem *KeyValuePair
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = double_starred_kvpair_rule(p)
			if elem == nil {
				return false
			} // double_starred_kvpair
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_112_type, _seq)
	p.level--
	return _seq
}

// _gather_111: double_starred_kvpair _loop0_112
func _gather_111_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // double_starred_kvpair _loop0_112
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem *KeyValuePair
		var seq *asdl_seq
		condition := func() bool {
			elem = double_starred_kvpair_rule(p)
			if elem == nil {
				return false
			} // double_starred_kvpair
			seq = _loop0_112_rule(p)
			if seq == nil {
				return false
			} // _loop0_112
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop1_113: for_if_clause
func _loop1_113_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // for_if_clause
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var for_if_clause_var comprehension_ty
		condition := func() bool {
			for_if_clause_var = for_if_clause_rule(p)
			if for_if_clause_var == nil {
				return false
			} // for_if_clause
			return true
		}
		for condition() {
			_res = for_if_clause_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_113_type, _seq)
	p.level--
	return _seq
}

// _loop0_114: ('if' disjunction)
func _loop0_114_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ('if' disjunction)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_231_var any
		condition := func() bool {
			_tmp_231_var = _tmp_231_rule(p)
			if _tmp_231_var == nil {
				return false
			} // 'if' disjunction
			return true
		}
		for condition() {
			_res = _tmp_231_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_114_type, _seq)
	p.level--
	return _seq
}

// _loop0_115: ('if' disjunction)
func _loop0_115_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ('if' disjunction)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_232_var any
		condition := func() bool {
			_tmp_232_var = _tmp_232_rule(p)
			if _tmp_232_var == nil {
				return false
			} // 'if' disjunction
			return true
		}
		for condition() {
			_res = _tmp_232_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_115_type, _seq)
	p.level--
	return _seq
}

// _tmp_116: assignment_expression | expression !':='
func _tmp_116_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // assignment_expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var assignment_expression_var expr_ty
		condition := func() bool {
			assignment_expression_var = assignment_expression_rule(p)
			if assignment_expression_var == nil {
				return false
			} // assignment_expression
			return true
		}
		if condition() {
			_res = assignment_expression_var
			goto done
		}
		p.mark = _mark
	}
	{ // expression !':='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var expression_var expr_ty
		condition := func() bool {
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 53)
			if _tmp == 0 {
				return false
			} // token=':='
			return true
		}
		if condition() {
			_res = expression_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_118: ',' (starred_expression | (assignment_expression | expression !':=') !'=')
func _loop0_118_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' (starred_expression | (assignment_expression | expression !':=') !'=')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = _tmp_233_rule(p)
			if elem == nil {
				return false
			} // starred_expression | (assignment_expression | expression !':=') !'='
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_118_type, _seq)
	p.level--
	return _seq
}

// _gather_117:
//     | (starred_expression | (assignment_expression | expression !':=') !'=') _loop0_118
func _gather_117_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // (starred_expression | (assignment_expression | expression !':=') !'=') _loop0_118
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem any
		var seq *asdl_seq
		condition := func() bool {
			elem = _tmp_233_rule(p)
			if elem == nil {
				return false
			} // starred_expression | (assignment_expression | expression !':=') !'='
			seq = _loop0_118_rule(p)
			if seq == nil {
				return false
			} // _loop0_118
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_119: ',' kwargs
func _tmp_119_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ',' kwargs
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var k *asdl_seq
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			k = kwargs_rule(p)
			if k == nil {
				return false
			} // kwargs
			return true
		}
		if condition() {
			_res = k
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_121: ',' kwarg_or_starred
func _loop0_121_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' kwarg_or_starred
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem *KeywordOrStarred
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = kwarg_or_starred_rule(p)
			if elem == nil {
				return false
			} // kwarg_or_starred
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_121_type, _seq)
	p.level--
	return _seq
}

// _gather_120: kwarg_or_starred _loop0_121
func _gather_120_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // kwarg_or_starred _loop0_121
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem *KeywordOrStarred
		var seq *asdl_seq
		condition := func() bool {
			elem = kwarg_or_starred_rule(p)
			if elem == nil {
				return false
			} // kwarg_or_starred
			seq = _loop0_121_rule(p)
			if seq == nil {
				return false
			} // _loop0_121
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_123: ',' kwarg_or_double_starred
func _loop0_123_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' kwarg_or_double_starred
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem *KeywordOrStarred
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = kwarg_or_double_starred_rule(p)
			if elem == nil {
				return false
			} // kwarg_or_double_starred
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_123_type, _seq)
	p.level--
	return _seq
}

// _gather_122: kwarg_or_double_starred _loop0_123
func _gather_122_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // kwarg_or_double_starred _loop0_123
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem *KeywordOrStarred
		var seq *asdl_seq
		condition := func() bool {
			elem = kwarg_or_double_starred_rule(p)
			if elem == nil {
				return false
			} // kwarg_or_double_starred
			seq = _loop0_123_rule(p)
			if seq == nil {
				return false
			} // _loop0_123
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_125: ',' kwarg_or_starred
func _loop0_125_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' kwarg_or_starred
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem *KeywordOrStarred
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = kwarg_or_starred_rule(p)
			if elem == nil {
				return false
			} // kwarg_or_starred
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_125_type, _seq)
	p.level--
	return _seq
}

// _gather_124: kwarg_or_starred _loop0_125
func _gather_124_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // kwarg_or_starred _loop0_125
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem *KeywordOrStarred
		var seq *asdl_seq
		condition := func() bool {
			elem = kwarg_or_starred_rule(p)
			if elem == nil {
				return false
			} // kwarg_or_starred
			seq = _loop0_125_rule(p)
			if seq == nil {
				return false
			} // _loop0_125
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_127: ',' kwarg_or_double_starred
func _loop0_127_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' kwarg_or_double_starred
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem *KeywordOrStarred
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = kwarg_or_double_starred_rule(p)
			if elem == nil {
				return false
			} // kwarg_or_double_starred
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_127_type, _seq)
	p.level--
	return _seq
}

// _gather_126: kwarg_or_double_starred _loop0_127
func _gather_126_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // kwarg_or_double_starred _loop0_127
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem *KeywordOrStarred
		var seq *asdl_seq
		condition := func() bool {
			elem = kwarg_or_double_starred_rule(p)
			if elem == nil {
				return false
			} // kwarg_or_double_starred
			seq = _loop0_127_rule(p)
			if seq == nil {
				return false
			} // _loop0_127
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_128: (',' star_target)
func _loop0_128_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // (',' star_target)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_234_var any
		condition := func() bool {
			_tmp_234_var = _tmp_234_rule(p)
			if _tmp_234_var == nil {
				return false
			} // ',' star_target
			return true
		}
		for condition() {
			_res = _tmp_234_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_128_type, _seq)
	p.level--
	return _seq
}

// _loop0_130: ',' star_target
func _loop0_130_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' star_target
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = star_target_rule(p)
			if elem == nil {
				return false
			} // star_target
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_130_type, _seq)
	p.level--
	return _seq
}

// _gather_129: star_target _loop0_130
func _gather_129_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // star_target _loop0_130
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem expr_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = star_target_rule(p)
			if elem == nil {
				return false
			} // star_target
			seq = _loop0_130_rule(p)
			if seq == nil {
				return false
			} // _loop0_130
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop1_131: (',' star_target)
func _loop1_131_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // (',' star_target)
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_235_var any
		condition := func() bool {
			_tmp_235_var = _tmp_235_rule(p)
			if _tmp_235_var == nil {
				return false
			} // ',' star_target
			return true
		}
		for condition() {
			_res = _tmp_235_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_131_type, _seq)
	p.level--
	return _seq
}

// _tmp_132: !'*' star_target
func _tmp_132_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // !'*' star_target
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var star_target_var expr_ty
		condition := func() bool {
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 16)
			if _tmp == 0 {
				return false
			} // token='*'
			star_target_var = star_target_rule(p)
			if star_target_var == nil {
				return false
			} // star_target
			return true
		}
		if condition() {
			_res = star_target_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_134: ',' del_target
func _loop0_134_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' del_target
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = del_target_rule(p)
			if elem == nil {
				return false
			} // del_target
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_134_type, _seq)
	p.level--
	return _seq
}

// _gather_133: del_target _loop0_134
func _gather_133_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // del_target _loop0_134
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem expr_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = del_target_rule(p)
			if elem == nil {
				return false
			} // del_target
			seq = _loop0_134_rule(p)
			if seq == nil {
				return false
			} // _loop0_134
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_136: ',' expression
func _loop0_136_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = expression_rule(p)
			if elem == nil {
				return false
			} // expression
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_136_type, _seq)
	p.level--
	return _seq
}

// _gather_135: expression _loop0_136
func _gather_135_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // expression _loop0_136
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem expr_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = expression_rule(p)
			if elem == nil {
				return false
			} // expression
			seq = _loop0_136_rule(p)
			if seq == nil {
				return false
			} // _loop0_136
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_138: ',' expression
func _loop0_138_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = expression_rule(p)
			if elem == nil {
				return false
			} // expression
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_138_type, _seq)
	p.level--
	return _seq
}

// _gather_137: expression _loop0_138
func _gather_137_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // expression _loop0_138
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem expr_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = expression_rule(p)
			if elem == nil {
				return false
			} // expression
			seq = _loop0_138_rule(p)
			if seq == nil {
				return false
			} // _loop0_138
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_140: ',' expression
func _loop0_140_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = expression_rule(p)
			if elem == nil {
				return false
			} // expression
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_140_type, _seq)
	p.level--
	return _seq
}

// _gather_139: expression _loop0_140
func _gather_139_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // expression _loop0_140
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem expr_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = expression_rule(p)
			if elem == nil {
				return false
			} // expression
			seq = _loop0_140_rule(p)
			if seq == nil {
				return false
			} // _loop0_140
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_142: ',' expression
func _loop0_142_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = expression_rule(p)
			if elem == nil {
				return false
			} // expression
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_142_type, _seq)
	p.level--
	return _seq
}

// _gather_141: expression _loop0_142
func _gather_141_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // expression _loop0_142
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem expr_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = expression_rule(p)
			if elem == nil {
				return false
			} // expression
			seq = _loop0_142_rule(p)
			if seq == nil {
				return false
			} // _loop0_142
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_143: NEWLINE INDENT
func _tmp_143_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // NEWLINE INDENT
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var indent_var *Token
		var newline_var *Token
		condition := func() bool {
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			indent_var = _PyPegen_expect_token(p, INDENT)
			if indent_var == nil {
				return false
			} // token='INDENT'
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, newline_var, indent_var)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_144: args | expression for_if_clauses
func _tmp_144_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // args
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var args_var expr_ty
		condition := func() bool {
			args_var = args_rule(p)
			if args_var == nil {
				return false
			} // args
			return true
		}
		if condition() {
			_res = args_var
			goto done
		}
		p.mark = _mark
	}
	{ // expression for_if_clauses
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var expression_var expr_ty
		var for_if_clauses_var *asdl_comprehension_seq
		condition := func() bool {
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			for_if_clauses_var = for_if_clauses_rule(p)
			if for_if_clauses_var == nil {
				return false
			} // for_if_clauses
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, expression_var, for_if_clauses_var)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_145: 'True' | 'False' | 'None'
func _tmp_145_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'True'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 600)
			if _keyword == nil {
				return false
			} // token='True'
			return true
		}
		if condition() {
			_res = _keyword
			goto done
		}
		p.mark = _mark
	}
	{ // 'False'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 602)
			if _keyword == nil {
				return false
			} // token='False'
			return true
		}
		if condition() {
			_res = _keyword
			goto done
		}
		p.mark = _mark
	}
	{ // 'None'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 601)
			if _keyword == nil {
				return false
			} // token='None'
			return true
		}
		if condition() {
			_res = _keyword
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_146: NAME '='
func _tmp_146_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // NAME '='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var name_var expr_ty
		condition := func() bool {
			name_var = _PyPegen_name_token(p)
			if name_var == nil {
				return false
			} // NAME
			_literal = _PyPegen_expect_token(p, 22)
			if _literal == nil {
				return false
			} // token='='
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, name_var, _literal)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_147: NAME STRING | SOFT_KEYWORD
func _tmp_147_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // NAME STRING
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var name_var expr_ty
		var string_var expr_ty
		condition := func() bool {
			name_var = _PyPegen_name_token(p)
			if name_var == nil {
				return false
			} // NAME
			string_var = _PyPegen_string_token(p)
			if string_var == nil {
				return false
			} // STRING
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, name_var, string_var)
			goto done
		}
		p.mark = _mark
	}
	{ // SOFT_KEYWORD
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var soft_keyword_var expr_ty
		condition := func() bool {
			soft_keyword_var = _PyPegen_soft_keyword_token(p)
			if soft_keyword_var == nil {
				return false
			} // SOFT_KEYWORD
			return true
		}
		if condition() {
			_res = soft_keyword_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_148: 'else' | ':'
func _tmp_148_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'else'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 642)
			if _keyword == nil {
				return false
			} // token='else'
			return true
		}
		if condition() {
			_res = _keyword
			goto done
		}
		p.mark = _mark
	}
	{ // ':'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_149: '=' | ':='
func _tmp_149_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 22)
			if _literal == nil {
				return false
			} // token='='
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // ':='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 53)
			if _literal == nil {
				return false
			} // token=':='
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_150: list | tuple | genexp | 'True' | 'None' | 'False'
func _tmp_150_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // list
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var list_var expr_ty
		condition := func() bool {
			list_var = list_rule(p)
			if list_var == nil {
				return false
			} // list
			return true
		}
		if condition() {
			_res = list_var
			goto done
		}
		p.mark = _mark
	}
	{ // tuple
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var tuple_var expr_ty
		condition := func() bool {
			tuple_var = tuple_rule(p)
			if tuple_var == nil {
				return false
			} // tuple
			return true
		}
		if condition() {
			_res = tuple_var
			goto done
		}
		p.mark = _mark
	}
	{ // genexp
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var genexp_var expr_ty
		condition := func() bool {
			genexp_var = genexp_rule(p)
			if genexp_var == nil {
				return false
			} // genexp
			return true
		}
		if condition() {
			_res = genexp_var
			goto done
		}
		p.mark = _mark
	}
	{ // 'True'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 600)
			if _keyword == nil {
				return false
			} // token='True'
			return true
		}
		if condition() {
			_res = _keyword
			goto done
		}
		p.mark = _mark
	}
	{ // 'None'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 601)
			if _keyword == nil {
				return false
			} // token='None'
			return true
		}
		if condition() {
			_res = _keyword
			goto done
		}
		p.mark = _mark
	}
	{ // 'False'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 602)
			if _keyword == nil {
				return false
			} // token='False'
			return true
		}
		if condition() {
			_res = _keyword
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_151: '=' | ':='
func _tmp_151_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 22)
			if _literal == nil {
				return false
			} // token='='
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // ':='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 53)
			if _literal == nil {
				return false
			} // token=':='
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_152: star_named_expressions
func _loop0_152_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // star_named_expressions
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var star_named_expressions_var *asdl_expr_seq
		condition := func() bool {
			star_named_expressions_var = star_named_expressions_rule(p)
			if star_named_expressions_var == nil {
				return false
			} // star_named_expressions
			return true
		}
		for condition() {
			_res = star_named_expressions_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_152_type, _seq)
	p.level--
	return _seq
}

// _loop0_153: (star_targets '=')
func _loop0_153_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // (star_targets '=')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_236_var any
		condition := func() bool {
			_tmp_236_var = _tmp_236_rule(p)
			if _tmp_236_var == nil {
				return false
			} // star_targets '='
			return true
		}
		for condition() {
			_res = _tmp_236_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_153_type, _seq)
	p.level--
	return _seq
}

// _loop0_154: (star_targets '=')
func _loop0_154_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // (star_targets '=')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_237_var any
		condition := func() bool {
			_tmp_237_var = _tmp_237_rule(p)
			if _tmp_237_var == nil {
				return false
			} // star_targets '='
			return true
		}
		for condition() {
			_res = _tmp_237_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_154_type, _seq)
	p.level--
	return _seq
}

// _tmp_155: yield_expr | star_expressions
func _tmp_155_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // yield_expr
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var yield_expr_var expr_ty
		condition := func() bool {
			yield_expr_var = yield_expr_rule(p)
			if yield_expr_var == nil {
				return false
			} // yield_expr
			return true
		}
		if condition() {
			_res = yield_expr_var
			goto done
		}
		p.mark = _mark
	}
	{ // star_expressions
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var star_expressions_var expr_ty
		condition := func() bool {
			star_expressions_var = star_expressions_rule(p)
			if star_expressions_var == nil {
				return false
			} // star_expressions
			return true
		}
		if condition() {
			_res = star_expressions_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_156: '[' | '(' | '{'
func _tmp_156_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '['
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 9)
			if _literal == nil {
				return false
			} // token='['
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // '('
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // '{'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 25)
			if _literal == nil {
				return false
			} // token='{'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_157: '[' | '{'
func _tmp_157_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '['
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 9)
			if _literal == nil {
				return false
			} // token='['
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // '{'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 25)
			if _literal == nil {
				return false
			} // token='{'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_158: '[' | '{'
func _tmp_158_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '['
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 9)
			if _literal == nil {
				return false
			} // token='['
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // '{'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 25)
			if _literal == nil {
				return false
			} // token='{'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_159: param_no_default
func _loop0_159_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_no_default_var arg_ty
		condition := func() bool {
			param_no_default_var = param_no_default_rule(p)
			if param_no_default_var == nil {
				return false
			} // param_no_default
			return true
		}
		for condition() {
			_res = param_no_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_159_type, _seq)
	p.level--
	return _seq
}

// _loop0_160: param_no_default
func _loop0_160_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_no_default_var arg_ty
		condition := func() bool {
			param_no_default_var = param_no_default_rule(p)
			if param_no_default_var == nil {
				return false
			} // param_no_default
			return true
		}
		for condition() {
			_res = param_no_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_160_type, _seq)
	p.level--
	return _seq
}

// _loop1_161: param_no_default
func _loop1_161_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_no_default_var arg_ty
		condition := func() bool {
			param_no_default_var = param_no_default_rule(p)
			if param_no_default_var == nil {
				return false
			} // param_no_default
			return true
		}
		for condition() {
			_res = param_no_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_161_type, _seq)
	p.level--
	return _seq
}

// _tmp_162: slash_no_default | slash_with_default
func _tmp_162_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // slash_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var slash_no_default_var *asdl_arg_seq
		condition := func() bool {
			slash_no_default_var = slash_no_default_rule(p)
			if slash_no_default_var == nil {
				return false
			} // slash_no_default
			return true
		}
		if condition() {
			_res = slash_no_default_var
			goto done
		}
		p.mark = _mark
	}
	{ // slash_with_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var slash_with_default_var *SlashWithDefault
		condition := func() bool {
			slash_with_default_var = slash_with_default_rule(p)
			if slash_with_default_var == nil {
				return false
			} // slash_with_default
			return true
		}
		if condition() {
			_res = slash_with_default_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_163: param_maybe_default
func _loop0_163_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_maybe_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_maybe_default_var *NameDefaultPair
		condition := func() bool {
			param_maybe_default_var = param_maybe_default_rule(p)
			if param_maybe_default_var == nil {
				return false
			} // param_maybe_default
			return true
		}
		for condition() {
			_res = param_maybe_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_163_type, _seq)
	p.level--
	return _seq
}

// _tmp_164: slash_no_default | slash_with_default
func _tmp_164_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // slash_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var slash_no_default_var *asdl_arg_seq
		condition := func() bool {
			slash_no_default_var = slash_no_default_rule(p)
			if slash_no_default_var == nil {
				return false
			} // slash_no_default
			return true
		}
		if condition() {
			_res = slash_no_default_var
			goto done
		}
		p.mark = _mark
	}
	{ // slash_with_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var slash_with_default_var *SlashWithDefault
		condition := func() bool {
			slash_with_default_var = slash_with_default_rule(p)
			if slash_with_default_var == nil {
				return false
			} // slash_with_default
			return true
		}
		if condition() {
			_res = slash_with_default_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_165: param_maybe_default
func _loop0_165_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_maybe_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_maybe_default_var *NameDefaultPair
		condition := func() bool {
			param_maybe_default_var = param_maybe_default_rule(p)
			if param_maybe_default_var == nil {
				return false
			} // param_maybe_default
			return true
		}
		for condition() {
			_res = param_maybe_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_165_type, _seq)
	p.level--
	return _seq
}

// _tmp_166: ',' | param_no_default
func _tmp_166_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_no_default_var arg_ty
		condition := func() bool {
			param_no_default_var = param_no_default_rule(p)
			if param_no_default_var == nil {
				return false
			} // param_no_default
			return true
		}
		if condition() {
			_res = param_no_default_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_167: param_maybe_default
func _loop0_167_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_maybe_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_maybe_default_var *NameDefaultPair
		condition := func() bool {
			param_maybe_default_var = param_maybe_default_rule(p)
			if param_maybe_default_var == nil {
				return false
			} // param_maybe_default
			return true
		}
		for condition() {
			_res = param_maybe_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_167_type, _seq)
	p.level--
	return _seq
}

// _loop1_168: param_maybe_default
func _loop1_168_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_maybe_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_maybe_default_var *NameDefaultPair
		condition := func() bool {
			param_maybe_default_var = param_maybe_default_rule(p)
			if param_maybe_default_var == nil {
				return false
			} // param_maybe_default
			return true
		}
		for condition() {
			_res = param_maybe_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_168_type, _seq)
	p.level--
	return _seq
}

// _tmp_169: ')' | ','
func _tmp_169_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 8)
			if _literal == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_170: ')' | ',' (')' | '**')
func _tmp_170_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 8)
			if _literal == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // ',' (')' | '**')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _tmp_238_var any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			_tmp_238_var = _tmp_238_rule(p)
			if _tmp_238_var == nil {
				return false
			} // ')' | '**'
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, _literal, _tmp_238_var)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_171: param_no_default | ','
func _tmp_171_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_no_default_var arg_ty
		condition := func() bool {
			param_no_default_var = param_no_default_rule(p)
			if param_no_default_var == nil {
				return false
			} // param_no_default
			return true
		}
		if condition() {
			_res = param_no_default_var
			goto done
		}
		p.mark = _mark
	}
	{ // ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_172: param_maybe_default
func _loop0_172_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_maybe_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_maybe_default_var *NameDefaultPair
		condition := func() bool {
			param_maybe_default_var = param_maybe_default_rule(p)
			if param_maybe_default_var == nil {
				return false
			} // param_maybe_default
			return true
		}
		for condition() {
			_res = param_maybe_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_172_type, _seq)
	p.level--
	return _seq
}

// _tmp_173: param_no_default | ','
func _tmp_173_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_no_default_var arg_ty
		condition := func() bool {
			param_no_default_var = param_no_default_rule(p)
			if param_no_default_var == nil {
				return false
			} // param_no_default
			return true
		}
		if condition() {
			_res = param_no_default_var
			goto done
		}
		p.mark = _mark
	}
	{ // ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_174: '*' | '**' | '/'
func _tmp_174_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '*'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // '**'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 35)
			if _literal == nil {
				return false
			} // token='**'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // '/'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 17)
			if _literal == nil {
				return false
			} // token='/'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop1_175: param_with_default
func _loop1_175_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // param_with_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var param_with_default_var *NameDefaultPair
		condition := func() bool {
			param_with_default_var = param_with_default_rule(p)
			if param_with_default_var == nil {
				return false
			} // param_with_default
			return true
		}
		for condition() {
			_res = param_with_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_175_type, _seq)
	p.level--
	return _seq
}

// _loop0_176: lambda_param_no_default
func _loop0_176_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_no_default_var arg_ty
		condition := func() bool {
			lambda_param_no_default_var = lambda_param_no_default_rule(p)
			if lambda_param_no_default_var == nil {
				return false
			} // lambda_param_no_default
			return true
		}
		for condition() {
			_res = lambda_param_no_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_176_type, _seq)
	p.level--
	return _seq
}

// _loop0_177: lambda_param_no_default
func _loop0_177_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_no_default_var arg_ty
		condition := func() bool {
			lambda_param_no_default_var = lambda_param_no_default_rule(p)
			if lambda_param_no_default_var == nil {
				return false
			} // lambda_param_no_default
			return true
		}
		for condition() {
			_res = lambda_param_no_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_177_type, _seq)
	p.level--
	return _seq
}

// _loop0_179: ',' lambda_param
func _loop0_179_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' lambda_param
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem arg_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = lambda_param_rule(p)
			if elem == nil {
				return false
			} // lambda_param
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_179_type, _seq)
	p.level--
	return _seq
}

// _gather_178: lambda_param _loop0_179
func _gather_178_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // lambda_param _loop0_179
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem arg_ty
		var seq *asdl_seq
		condition := func() bool {
			elem = lambda_param_rule(p)
			if elem == nil {
				return false
			} // lambda_param
			seq = _loop0_179_rule(p)
			if seq == nil {
				return false
			} // _loop0_179
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_180: lambda_slash_no_default | lambda_slash_with_default
func _tmp_180_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // lambda_slash_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_slash_no_default_var *asdl_arg_seq
		condition := func() bool {
			lambda_slash_no_default_var = lambda_slash_no_default_rule(p)
			if lambda_slash_no_default_var == nil {
				return false
			} // lambda_slash_no_default
			return true
		}
		if condition() {
			_res = lambda_slash_no_default_var
			goto done
		}
		p.mark = _mark
	}
	{ // lambda_slash_with_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_slash_with_default_var *SlashWithDefault
		condition := func() bool {
			lambda_slash_with_default_var = lambda_slash_with_default_rule(p)
			if lambda_slash_with_default_var == nil {
				return false
			} // lambda_slash_with_default
			return true
		}
		if condition() {
			_res = lambda_slash_with_default_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_181: lambda_param_maybe_default
func _loop0_181_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_maybe_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_maybe_default_var *NameDefaultPair
		condition := func() bool {
			lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p)
			if lambda_param_maybe_default_var == nil {
				return false
			} // lambda_param_maybe_default
			return true
		}
		for condition() {
			_res = lambda_param_maybe_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_181_type, _seq)
	p.level--
	return _seq
}

// _tmp_182: lambda_slash_no_default | lambda_slash_with_default
func _tmp_182_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // lambda_slash_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_slash_no_default_var *asdl_arg_seq
		condition := func() bool {
			lambda_slash_no_default_var = lambda_slash_no_default_rule(p)
			if lambda_slash_no_default_var == nil {
				return false
			} // lambda_slash_no_default
			return true
		}
		if condition() {
			_res = lambda_slash_no_default_var
			goto done
		}
		p.mark = _mark
	}
	{ // lambda_slash_with_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_slash_with_default_var *SlashWithDefault
		condition := func() bool {
			lambda_slash_with_default_var = lambda_slash_with_default_rule(p)
			if lambda_slash_with_default_var == nil {
				return false
			} // lambda_slash_with_default
			return true
		}
		if condition() {
			_res = lambda_slash_with_default_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_183: lambda_param_maybe_default
func _loop0_183_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_maybe_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_maybe_default_var *NameDefaultPair
		condition := func() bool {
			lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p)
			if lambda_param_maybe_default_var == nil {
				return false
			} // lambda_param_maybe_default
			return true
		}
		for condition() {
			_res = lambda_param_maybe_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_183_type, _seq)
	p.level--
	return _seq
}

// _tmp_184: ',' | lambda_param_no_default
func _tmp_184_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // lambda_param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_no_default_var arg_ty
		condition := func() bool {
			lambda_param_no_default_var = lambda_param_no_default_rule(p)
			if lambda_param_no_default_var == nil {
				return false
			} // lambda_param_no_default
			return true
		}
		if condition() {
			_res = lambda_param_no_default_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_185: lambda_param_maybe_default
func _loop0_185_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_maybe_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_maybe_default_var *NameDefaultPair
		condition := func() bool {
			lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p)
			if lambda_param_maybe_default_var == nil {
				return false
			} // lambda_param_maybe_default
			return true
		}
		for condition() {
			_res = lambda_param_maybe_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_185_type, _seq)
	p.level--
	return _seq
}

// _loop1_186: lambda_param_maybe_default
func _loop1_186_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_maybe_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_maybe_default_var *NameDefaultPair
		condition := func() bool {
			lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p)
			if lambda_param_maybe_default_var == nil {
				return false
			} // lambda_param_maybe_default
			return true
		}
		for condition() {
			_res = lambda_param_maybe_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_186_type, _seq)
	p.level--
	return _seq
}

// _loop1_187: lambda_param_with_default
func _loop1_187_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_with_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_with_default_var *NameDefaultPair
		condition := func() bool {
			lambda_param_with_default_var = lambda_param_with_default_rule(p)
			if lambda_param_with_default_var == nil {
				return false
			} // lambda_param_with_default
			return true
		}
		for condition() {
			_res = lambda_param_with_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_187_type, _seq)
	p.level--
	return _seq
}

// _tmp_188: ':' | ',' (':' | '**')
func _tmp_188_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ':'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // ',' (':' | '**')
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _tmp_239_var any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			_tmp_239_var = _tmp_239_rule(p)
			if _tmp_239_var == nil {
				return false
			} // ':' | '**'
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, _literal, _tmp_239_var)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_189: lambda_param_no_default | ','
func _tmp_189_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // lambda_param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_no_default_var arg_ty
		condition := func() bool {
			lambda_param_no_default_var = lambda_param_no_default_rule(p)
			if lambda_param_no_default_var == nil {
				return false
			} // lambda_param_no_default
			return true
		}
		if condition() {
			_res = lambda_param_no_default_var
			goto done
		}
		p.mark = _mark
	}
	{ // ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_190: lambda_param_maybe_default
func _loop0_190_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // lambda_param_maybe_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_maybe_default_var *NameDefaultPair
		condition := func() bool {
			lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p)
			if lambda_param_maybe_default_var == nil {
				return false
			} // lambda_param_maybe_default
			return true
		}
		for condition() {
			_res = lambda_param_maybe_default_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_190_type, _seq)
	p.level--
	return _seq
}

// _tmp_191: lambda_param_no_default | ','
func _tmp_191_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // lambda_param_no_default
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var lambda_param_no_default_var arg_ty
		condition := func() bool {
			lambda_param_no_default_var = lambda_param_no_default_rule(p)
			if lambda_param_no_default_var == nil {
				return false
			} // lambda_param_no_default
			return true
		}
		if condition() {
			_res = lambda_param_no_default_var
			goto done
		}
		p.mark = _mark
	}
	{ // ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_192: '*' | '**' | '/'
func _tmp_192_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '*'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 16)
			if _literal == nil {
				return false
			} // token='*'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // '**'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 35)
			if _literal == nil {
				return false
			} // token='**'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // '/'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 17)
			if _literal == nil {
				return false
			} // token='/'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_193: ',' | ')' | ':'
func _tmp_193_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 8)
			if _literal == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // ':'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_195: ',' (expression ['as' star_target])
func _loop0_195_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' (expression ['as' star_target])
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = _tmp_240_rule(p)
			if elem == nil {
				return false
			} // expression ['as' star_target]
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_195_type, _seq)
	p.level--
	return _seq
}

// _gather_194: (expression ['as' star_target]) _loop0_195
func _gather_194_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // (expression ['as' star_target]) _loop0_195
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem any
		var seq *asdl_seq
		condition := func() bool {
			elem = _tmp_240_rule(p)
			if elem == nil {
				return false
			} // expression ['as' star_target]
			seq = _loop0_195_rule(p)
			if seq == nil {
				return false
			} // _loop0_195
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_197: ',' (expressions ['as' star_target])
func _loop0_197_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' (expressions ['as' star_target])
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = _tmp_241_rule(p)
			if elem == nil {
				return false
			} // expressions ['as' star_target]
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_197_type, _seq)
	p.level--
	return _seq
}

// _gather_196: (expressions ['as' star_target]) _loop0_197
func _gather_196_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // (expressions ['as' star_target]) _loop0_197
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem any
		var seq *asdl_seq
		condition := func() bool {
			elem = _tmp_241_rule(p)
			if elem == nil {
				return false
			} // expressions ['as' star_target]
			seq = _loop0_197_rule(p)
			if seq == nil {
				return false
			} // _loop0_197
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_199: ',' (expression ['as' star_target])
func _loop0_199_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' (expression ['as' star_target])
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = _tmp_242_rule(p)
			if elem == nil {
				return false
			} // expression ['as' star_target]
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_199_type, _seq)
	p.level--
	return _seq
}

// _gather_198: (expression ['as' star_target]) _loop0_199
func _gather_198_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // (expression ['as' star_target]) _loop0_199
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem any
		var seq *asdl_seq
		condition := func() bool {
			elem = _tmp_242_rule(p)
			if elem == nil {
				return false
			} // expression ['as' star_target]
			seq = _loop0_199_rule(p)
			if seq == nil {
				return false
			} // _loop0_199
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_201: ',' (expressions ['as' star_target])
func _loop0_201_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' (expressions ['as' star_target])
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem any
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = _tmp_243_rule(p)
			if elem == nil {
				return false
			} // expressions ['as' star_target]
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_201_type, _seq)
	p.level--
	return _seq
}

// _gather_200: (expressions ['as' star_target]) _loop0_201
func _gather_200_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // (expressions ['as' star_target]) _loop0_201
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem any
		var seq *asdl_seq
		condition := func() bool {
			elem = _tmp_243_rule(p)
			if elem == nil {
				return false
			} // expressions ['as' star_target]
			seq = _loop0_201_rule(p)
			if seq == nil {
				return false
			} // _loop0_201
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_202: 'except' | 'finally'
func _tmp_202_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'except'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 634)
			if _keyword == nil {
				return false
			} // token='except'
			return true
		}
		if condition() {
			_res = _keyword
			goto done
		}
		p.mark = _mark
	}
	{ // 'finally'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 630)
			if _keyword == nil {
				return false
			} // token='finally'
			return true
		}
		if condition() {
			_res = _keyword
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_203: block
func _loop0_203_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var block_var *asdl_stmt_seq
		condition := func() bool {
			block_var = block_rule(p)
			if block_var == nil {
				return false
			} // block
			return true
		}
		for condition() {
			_res = block_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_203_type, _seq)
	p.level--
	return _seq
}

// _loop1_204: except_block
func _loop1_204_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // except_block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var except_block_var excepthandler_ty
		condition := func() bool {
			except_block_var = except_block_rule(p)
			if except_block_var == nil {
				return false
			} // except_block
			return true
		}
		for condition() {
			_res = except_block_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_204_type, _seq)
	p.level--
	return _seq
}

// _tmp_205: 'as' NAME
func _tmp_205_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'as' NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var name_var expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 637)
			if _keyword == nil {
				return false
			} // token='as'
			name_var = _PyPegen_name_token(p)
			if name_var == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, _keyword, name_var)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_206: block
func _loop0_206_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var block_var *asdl_stmt_seq
		condition := func() bool {
			block_var = block_rule(p)
			if block_var == nil {
				return false
			} // block
			return true
		}
		for condition() {
			_res = block_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_206_type, _seq)
	p.level--
	return _seq
}

// _loop1_207: except_star_block
func _loop1_207_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // except_star_block
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var except_star_block_var excepthandler_ty
		condition := func() bool {
			except_star_block_var = except_star_block_rule(p)
			if except_star_block_var == nil {
				return false
			} // except_star_block
			return true
		}
		for condition() {
			_res = except_star_block_var
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	if _n == 0 || p.error_indicator > 0 {
		p.level--
		return nil
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop1_207_type, _seq)
	p.level--
	return _seq
}

// _tmp_208: expression ['as' NAME]
func _tmp_208_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // expression ['as' NAME]
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var expression_var expr_ty
		condition := func() bool {
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			_opt_var = _tmp_244_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['as' NAME]
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, expression_var, _opt_var)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_209: 'as' NAME
func _tmp_209_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'as' NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var name_var expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 637)
			if _keyword == nil {
				return false
			} // token='as'
			name_var = _PyPegen_name_token(p)
			if name_var == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, _keyword, name_var)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_210: 'as' NAME
func _tmp_210_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'as' NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var name_var expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 637)
			if _keyword == nil {
				return false
			} // token='as'
			name_var = _PyPegen_name_token(p)
			if name_var == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, _keyword, name_var)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_211: NEWLINE | ':'
func _tmp_211_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var newline_var *Token
		condition := func() bool {
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		if condition() {
			_res = newline_var
			goto done
		}
		p.mark = _mark
	}
	{ // ':'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_212: 'as' NAME
func _tmp_212_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'as' NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var name_var expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 637)
			if _keyword == nil {
				return false
			} // token='as'
			name_var = _PyPegen_name_token(p)
			if name_var == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, _keyword, name_var)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_213: 'as' NAME
func _tmp_213_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'as' NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var name_var expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 637)
			if _keyword == nil {
				return false
			} // token='as'
			name_var = _PyPegen_name_token(p)
			if name_var == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, _keyword, name_var)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_214: positional_patterns ','
func _tmp_214_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // positional_patterns ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var positional_patterns_var *asdl_pattern_seq
		condition := func() bool {
			positional_patterns_var = positional_patterns_rule(p)
			if positional_patterns_var == nil {
				return false
			} // positional_patterns
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, positional_patterns_var, _literal)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_215: '->' expression
func _tmp_215_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '->' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var expression_var expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 51)
			if _literal == nil {
				return false
			} // token='->'
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, _literal, expression_var)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_216: '(' arguments? ')'
func _tmp_216_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '(' arguments? ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			_opt_var = arguments_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// arguments?
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, _literal, _opt_var, _literal_1)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_217: '(' arguments? ')'
func _tmp_217_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '(' arguments? ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var _literal_1 *Token
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 7)
			if _literal == nil {
				return false
			} // token='('
			_opt_var = arguments_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// arguments?
			_literal_1 = _PyPegen_expect_token(p, 8)
			if _literal_1 == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, _literal, _opt_var, _literal_1)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _loop0_219: ',' double_starred_kvpair
func _loop0_219_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	_start_mark := p.mark
	_children := []any{}
	_n := 0
	{ // ',' double_starred_kvpair
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var elem *KeyValuePair
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			elem = double_starred_kvpair_rule(p)
			if elem == nil {
				return false
			} // double_starred_kvpair
			return true
		}
		for condition() {
			_res = elem
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			_children = append(_children, _res)
			_mark = p.mark
		}
		p.mark = _mark
	}
	_seq := _Py_asdl_generic_seq_new(_n, p.arena)
	for i := 0; i < _n; i++ {
		asdl_seq_SET_UNTYPED(_seq, i, _children[i])
	}
	_PyPegen_insert_memo(p, _start_mark, _loop0_219_type, _seq)
	p.level--
	return _seq
}

// _gather_218: double_starred_kvpair _loop0_219
func _gather_218_rule(p *Parser) *asdl_seq {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res *asdl_seq
	_mark := p.mark
	{ // double_starred_kvpair _loop0_219
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var elem *KeyValuePair
		var seq *asdl_seq
		condition := func() bool {
			elem = double_starred_kvpair_rule(p)
			if elem == nil {
				return false
			} // double_starred_kvpair
			seq = _loop0_219_rule(p)
			if seq == nil {
				return false
			} // _loop0_219
			return true
		}
		if condition() {
			_res = _PyPegen_seq_insert_in_front(p, elem, seq)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_220: '}' | ','
func _tmp_220_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '}'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 26)
			if _literal == nil {
				return false
			} // token='}'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_221: '}' | ','
func _tmp_221_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '}'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 26)
			if _literal == nil {
				return false
			} // token='}'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // ','
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_222: star_targets '='
func _tmp_222_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // star_targets '='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var z expr_ty
		condition := func() bool {
			z = star_targets_rule(p)
			if z == nil {
				return false
			} // star_targets
			_literal = _PyPegen_expect_token(p, 22)
			if _literal == nil {
				return false
			} // token='='
			return true
		}
		if condition() {
			_res = z
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_223: '.' | '...'
func _tmp_223_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '.'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 23)
			if _literal == nil {
				return false
			} // token='.'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // '...'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 52)
			if _literal == nil {
				return false
			} // token='...'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_224: '.' | '...'
func _tmp_224_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '.'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 23)
			if _literal == nil {
				return false
			} // token='.'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // '...'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 52)
			if _literal == nil {
				return false
			} // token='...'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_225: '@' named_expression NEWLINE
func _tmp_225_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // '@' named_expression NEWLINE
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var f expr_ty
		var newline_var *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 49)
			if _literal == nil {
				return false
			} // token='@'
			f = named_expression_rule(p)
			if f == nil {
				return false
			} // named_expression
			newline_var = _PyPegen_expect_token(p, NEWLINE)
			if newline_var == nil {
				return false
			} // token='NEWLINE'
			return true
		}
		if condition() {
			_res = f
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_226: ',' expression
func _tmp_226_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ',' expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var c expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			c = expression_rule(p)
			if c == nil {
				return false
			} // expression
			return true
		}
		if condition() {
			_res = c
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_227: ',' star_expression
func _tmp_227_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ',' star_expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var c expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			c = star_expression_rule(p)
			if c == nil {
				return false
			} // star_expression
			return true
		}
		if condition() {
			_res = c
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_228: 'or' conjunction
func _tmp_228_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'or' conjunction
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var c expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 574)
			if _keyword == nil {
				return false
			} // token='or'
			c = conjunction_rule(p)
			if c == nil {
				return false
			} // conjunction
			return true
		}
		if condition() {
			_res = c
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_229: 'and' inversion
func _tmp_229_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'and' inversion
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var c expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 575)
			if _keyword == nil {
				return false
			} // token='and'
			c = inversion_rule(p)
			if c == nil {
				return false
			} // inversion
			return true
		}
		if condition() {
			_res = c
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_230: slice | starred_expression
func _tmp_230_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // slice
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var slice_var expr_ty
		condition := func() bool {
			slice_var = slice_rule(p)
			if slice_var == nil {
				return false
			} // slice
			return true
		}
		if condition() {
			_res = slice_var
			goto done
		}
		p.mark = _mark
	}
	{ // starred_expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var starred_expression_var expr_ty
		condition := func() bool {
			starred_expression_var = starred_expression_rule(p)
			if starred_expression_var == nil {
				return false
			} // starred_expression
			return true
		}
		if condition() {
			_res = starred_expression_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_231: 'if' disjunction
func _tmp_231_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'if' disjunction
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var z expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 639)
			if _keyword == nil {
				return false
			} // token='if'
			z = disjunction_rule(p)
			if z == nil {
				return false
			} // disjunction
			return true
		}
		if condition() {
			_res = z
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_232: 'if' disjunction
func _tmp_232_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'if' disjunction
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var z expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 639)
			if _keyword == nil {
				return false
			} // token='if'
			z = disjunction_rule(p)
			if z == nil {
				return false
			} // disjunction
			return true
		}
		if condition() {
			_res = z
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_233: starred_expression | (assignment_expression | expression !':=') !'='
func _tmp_233_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // starred_expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var starred_expression_var expr_ty
		condition := func() bool {
			starred_expression_var = starred_expression_rule(p)
			if starred_expression_var == nil {
				return false
			} // starred_expression
			return true
		}
		if condition() {
			_res = starred_expression_var
			goto done
		}
		p.mark = _mark
	}
	{ // (assignment_expression | expression !':=') !'='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _tmp_245_var any
		condition := func() bool {
			_tmp_245_var = _tmp_245_rule(p)
			if _tmp_245_var == nil {
				return false
			} // assignment_expression | expression !':='
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 22)
			if _tmp == 0 {
				return false
			} // token='='
			return true
		}
		if condition() {
			_res = _tmp_245_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_234: ',' star_target
func _tmp_234_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ',' star_target
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var c expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			c = star_target_rule(p)
			if c == nil {
				return false
			} // star_target
			return true
		}
		if condition() {
			_res = c
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_235: ',' star_target
func _tmp_235_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ',' star_target
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var c expr_ty
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 12)
			if _literal == nil {
				return false
			} // token=','
			c = star_target_rule(p)
			if c == nil {
				return false
			} // star_target
			return true
		}
		if condition() {
			_res = c
			if _res == nil && PyErr_Occurred() {
				p.error_indicator = 1
				p.level--
				return nil
			}
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_236: star_targets '='
func _tmp_236_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // star_targets '='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var star_targets_var expr_ty
		condition := func() bool {
			star_targets_var = star_targets_rule(p)
			if star_targets_var == nil {
				return false
			} // star_targets
			_literal = _PyPegen_expect_token(p, 22)
			if _literal == nil {
				return false
			} // token='='
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, star_targets_var, _literal)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_237: star_targets '='
func _tmp_237_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // star_targets '='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		var star_targets_var expr_ty
		condition := func() bool {
			star_targets_var = star_targets_rule(p)
			if star_targets_var == nil {
				return false
			} // star_targets
			_literal = _PyPegen_expect_token(p, 22)
			if _literal == nil {
				return false
			} // token='='
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, star_targets_var, _literal)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_238: ')' | '**'
func _tmp_238_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ')'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 8)
			if _literal == nil {
				return false
			} // token=')'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // '**'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 35)
			if _literal == nil {
				return false
			} // token='**'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_239: ':' | '**'
func _tmp_239_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // ':'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 11)
			if _literal == nil {
				return false
			} // token=':'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	{ // '**'
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _literal *Token
		condition := func() bool {
			_literal = _PyPegen_expect_token(p, 35)
			if _literal == nil {
				return false
			} // token='**'
			return true
		}
		if condition() {
			_res = _literal
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_240: expression ['as' star_target]
func _tmp_240_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // expression ['as' star_target]
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var expression_var expr_ty
		condition := func() bool {
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			_opt_var = _tmp_246_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['as' star_target]
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, expression_var, _opt_var)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_241: expressions ['as' star_target]
func _tmp_241_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // expressions ['as' star_target]
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var expressions_var expr_ty
		condition := func() bool {
			expressions_var = expressions_rule(p)
			if expressions_var == nil {
				return false
			} // expressions
			_opt_var = _tmp_247_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['as' star_target]
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, expressions_var, _opt_var)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_242: expression ['as' star_target]
func _tmp_242_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // expression ['as' star_target]
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var expression_var expr_ty
		condition := func() bool {
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			_opt_var = _tmp_248_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['as' star_target]
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, expression_var, _opt_var)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_243: expressions ['as' star_target]
func _tmp_243_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // expressions ['as' star_target]
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _opt_var any
		UNUSED(_opt_var) // Silence compiler warnings
		var expressions_var expr_ty
		condition := func() bool {
			expressions_var = expressions_rule(p)
			if expressions_var == nil {
				return false
			} // expressions
			_opt_var = _tmp_249_rule(p)
			if p.error_indicator != 0 {
				return false
			}
			// ['as' star_target]
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, expressions_var, _opt_var)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_244: 'as' NAME
func _tmp_244_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'as' NAME
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var name_var expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 637)
			if _keyword == nil {
				return false
			} // token='as'
			name_var = _PyPegen_name_token(p)
			if name_var == nil {
				return false
			} // NAME
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, _keyword, name_var)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_245: assignment_expression | expression !':='
func _tmp_245_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // assignment_expression
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var assignment_expression_var expr_ty
		condition := func() bool {
			assignment_expression_var = assignment_expression_rule(p)
			if assignment_expression_var == nil {
				return false
			} // assignment_expression
			return true
		}
		if condition() {
			_res = assignment_expression_var
			goto done
		}
		p.mark = _mark
	}
	{ // expression !':='
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var expression_var expr_ty
		condition := func() bool {
			expression_var = expression_rule(p)
			if expression_var == nil {
				return false
			} // expression
			_tmp := _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 53)
			if _tmp == 0 {
				return false
			} // token=':='
			return true
		}
		if condition() {
			_res = expression_var
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_246: 'as' star_target
func _tmp_246_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'as' star_target
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var star_target_var expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 637)
			if _keyword == nil {
				return false
			} // token='as'
			star_target_var = star_target_rule(p)
			if star_target_var == nil {
				return false
			} // star_target
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, _keyword, star_target_var)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_247: 'as' star_target
func _tmp_247_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'as' star_target
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var star_target_var expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 637)
			if _keyword == nil {
				return false
			} // token='as'
			star_target_var = star_target_rule(p)
			if star_target_var == nil {
				return false
			} // star_target
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, _keyword, star_target_var)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_248: 'as' star_target
func _tmp_248_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'as' star_target
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var star_target_var expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 637)
			if _keyword == nil {
				return false
			} // token='as'
			star_target_var = star_target_rule(p)
			if star_target_var == nil {
				return false
			} // star_target
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, _keyword, star_target_var)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

// _tmp_249: 'as' star_target
func _tmp_249_rule(p *Parser) any {
	p.level++
	if p.level == MAXSTACK {
		p.error_indicator = 1
		PyErr_NoMemory()
	}
	if p.error_indicator > 0 {
		p.level--
		return nil
	}
	var _res any
	_mark := p.mark
	{ // 'as' star_target
		if p.error_indicator > 0 {
			p.level--
			return nil
		}
		var _keyword *Token
		var star_target_var expr_ty
		condition := func() bool {
			_keyword = _PyPegen_expect_token(p, 637)
			if _keyword == nil {
				return false
			} // token='as'
			star_target_var = star_target_rule(p)
			if star_target_var == nil {
				return false
			} // star_target
			return true
		}
		if condition() {
			_res = _PyPegen_dummy_name(p, _keyword, star_target_var)
			goto done
		}
		p.mark = _mark
	}
	_res = nil
done:
	p.level--
	return _res
}

func _PyPegen_parse(p *Parser) *AST {
	// Initialize keywords
	p.Keywords = reserved_keywords
	p.SoftKeywords = soft_keywords

	// Run parser
	var result *AST
	switch p.StartRule {
	case Py_file_input:
		return file_rule(p)
	case Py_single_input:
		return interactive_rule(p)
	case Py_eval_input:
		return eval_rule(p)
	case Py_func_type_input:
		return func_type_rule(p)
	case Py_fstring_input:
		return fstring_rule(p)
	}

	return result
}
